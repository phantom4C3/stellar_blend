module.exports = {

"[project]/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var XDR = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)"));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != _typeof(e) && "function" != typeof e) return {
        "default": e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n["default"] = e, t && t.set(e, n), n;
}
// Automatically generated by xdrgen on 2024-09-12T11:09:00-08:00
// DO NOT EDIT or your changes may be overwritten
/* jshint maxstatements:2147483647  */ /* jshint esnext:true  */ var types = XDR.config(function(xdr) {
    // Workaround for https://github.com/stellar/xdrgen/issues/152
    //
    // The "correct" way would be to replace bare instances of each constant with
    // xdr.lookup("..."), but that's more error-prone.
    var SCSYMBOL_LIMIT = 32;
    var SC_SPEC_DOC_LIMIT = 1024;
    // === xdr source ============================================================
    //
    //   typedef opaque Value<>;
    //
    // ===========================================================================
    xdr.typedef("Value", xdr.varOpaque());
    // === xdr source ============================================================
    //
    //   struct SCPBallot
    //   {
    //       uint32 counter; // n
    //       Value value;    // x
    //   };
    //
    // ===========================================================================
    xdr.struct("ScpBallot", [
        [
            "counter",
            xdr.lookup("Uint32")
        ],
        [
            "value",
            xdr.lookup("Value")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum SCPStatementType
    //   {
    //       SCP_ST_PREPARE = 0,
    //       SCP_ST_CONFIRM = 1,
    //       SCP_ST_EXTERNALIZE = 2,
    //       SCP_ST_NOMINATE = 3
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScpStatementType", {
        scpStPrepare: 0,
        scpStConfirm: 1,
        scpStExternalize: 2,
        scpStNominate: 3
    });
    // === xdr source ============================================================
    //
    //   struct SCPNomination
    //   {
    //       Hash quorumSetHash; // D
    //       Value votes<>;      // X
    //       Value accepted<>;   // Y
    //   };
    //
    // ===========================================================================
    xdr.struct("ScpNomination", [
        [
            "quorumSetHash",
            xdr.lookup("Hash")
        ],
        [
            "votes",
            xdr.varArray(xdr.lookup("Value"), 2147483647)
        ],
        [
            "accepted",
            xdr.varArray(xdr.lookup("Value"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //           {
    //               Hash quorumSetHash;       // D
    //               SCPBallot ballot;         // b
    //               SCPBallot* prepared;      // p
    //               SCPBallot* preparedPrime; // p'
    //               uint32 nC;                // c.n
    //               uint32 nH;                // h.n
    //           }
    //
    // ===========================================================================
    xdr.struct("ScpStatementPrepare", [
        [
            "quorumSetHash",
            xdr.lookup("Hash")
        ],
        [
            "ballot",
            xdr.lookup("ScpBallot")
        ],
        [
            "prepared",
            xdr.option(xdr.lookup("ScpBallot"))
        ],
        [
            "preparedPrime",
            xdr.option(xdr.lookup("ScpBallot"))
        ],
        [
            "nC",
            xdr.lookup("Uint32")
        ],
        [
            "nH",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //           {
    //               SCPBallot ballot;   // b
    //               uint32 nPrepared;   // p.n
    //               uint32 nCommit;     // c.n
    //               uint32 nH;          // h.n
    //               Hash quorumSetHash; // D
    //           }
    //
    // ===========================================================================
    xdr.struct("ScpStatementConfirm", [
        [
            "ballot",
            xdr.lookup("ScpBallot")
        ],
        [
            "nPrepared",
            xdr.lookup("Uint32")
        ],
        [
            "nCommit",
            xdr.lookup("Uint32")
        ],
        [
            "nH",
            xdr.lookup("Uint32")
        ],
        [
            "quorumSetHash",
            xdr.lookup("Hash")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //           {
    //               SCPBallot commit;         // c
    //               uint32 nH;                // h.n
    //               Hash commitQuorumSetHash; // D used before EXTERNALIZE
    //           }
    //
    // ===========================================================================
    xdr.struct("ScpStatementExternalize", [
        [
            "commit",
            xdr.lookup("ScpBallot")
        ],
        [
            "nH",
            xdr.lookup("Uint32")
        ],
        [
            "commitQuorumSetHash",
            xdr.lookup("Hash")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (SCPStatementType type)
    //       {
    //       case SCP_ST_PREPARE:
    //           struct
    //           {
    //               Hash quorumSetHash;       // D
    //               SCPBallot ballot;         // b
    //               SCPBallot* prepared;      // p
    //               SCPBallot* preparedPrime; // p'
    //               uint32 nC;                // c.n
    //               uint32 nH;                // h.n
    //           } prepare;
    //       case SCP_ST_CONFIRM:
    //           struct
    //           {
    //               SCPBallot ballot;   // b
    //               uint32 nPrepared;   // p.n
    //               uint32 nCommit;     // c.n
    //               uint32 nH;          // h.n
    //               Hash quorumSetHash; // D
    //           } confirm;
    //       case SCP_ST_EXTERNALIZE:
    //           struct
    //           {
    //               SCPBallot commit;         // c
    //               uint32 nH;                // h.n
    //               Hash commitQuorumSetHash; // D used before EXTERNALIZE
    //           } externalize;
    //       case SCP_ST_NOMINATE:
    //           SCPNomination nominate;
    //       }
    //
    // ===========================================================================
    xdr.union("ScpStatementPledges", {
        switchOn: xdr.lookup("ScpStatementType"),
        switchName: "type",
        switches: [
            [
                "scpStPrepare",
                "prepare"
            ],
            [
                "scpStConfirm",
                "confirm"
            ],
            [
                "scpStExternalize",
                "externalize"
            ],
            [
                "scpStNominate",
                "nominate"
            ]
        ],
        arms: {
            prepare: xdr.lookup("ScpStatementPrepare"),
            confirm: xdr.lookup("ScpStatementConfirm"),
            externalize: xdr.lookup("ScpStatementExternalize"),
            nominate: xdr.lookup("ScpNomination")
        }
    });
    // === xdr source ============================================================
    //
    //   struct SCPStatement
    //   {
    //       NodeID nodeID;    // v
    //       uint64 slotIndex; // i
    //
    //       union switch (SCPStatementType type)
    //       {
    //       case SCP_ST_PREPARE:
    //           struct
    //           {
    //               Hash quorumSetHash;       // D
    //               SCPBallot ballot;         // b
    //               SCPBallot* prepared;      // p
    //               SCPBallot* preparedPrime; // p'
    //               uint32 nC;                // c.n
    //               uint32 nH;                // h.n
    //           } prepare;
    //       case SCP_ST_CONFIRM:
    //           struct
    //           {
    //               SCPBallot ballot;   // b
    //               uint32 nPrepared;   // p.n
    //               uint32 nCommit;     // c.n
    //               uint32 nH;          // h.n
    //               Hash quorumSetHash; // D
    //           } confirm;
    //       case SCP_ST_EXTERNALIZE:
    //           struct
    //           {
    //               SCPBallot commit;         // c
    //               uint32 nH;                // h.n
    //               Hash commitQuorumSetHash; // D used before EXTERNALIZE
    //           } externalize;
    //       case SCP_ST_NOMINATE:
    //           SCPNomination nominate;
    //       }
    //       pledges;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScpStatement", [
        [
            "nodeId",
            xdr.lookup("NodeId")
        ],
        [
            "slotIndex",
            xdr.lookup("Uint64")
        ],
        [
            "pledges",
            xdr.lookup("ScpStatementPledges")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCPEnvelope
    //   {
    //       SCPStatement statement;
    //       Signature signature;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScpEnvelope", [
        [
            "statement",
            xdr.lookup("ScpStatement")
        ],
        [
            "signature",
            xdr.lookup("Signature")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCPQuorumSet
    //   {
    //       uint32 threshold;
    //       NodeID validators<>;
    //       SCPQuorumSet innerSets<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScpQuorumSet", [
        [
            "threshold",
            xdr.lookup("Uint32")
        ],
        [
            "validators",
            xdr.varArray(xdr.lookup("NodeId"), 2147483647)
        ],
        [
            "innerSets",
            xdr.varArray(xdr.lookup("ScpQuorumSet"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   typedef opaque Thresholds[4];
    //
    // ===========================================================================
    xdr.typedef("Thresholds", xdr.opaque(4));
    // === xdr source ============================================================
    //
    //   typedef string string32<32>;
    //
    // ===========================================================================
    xdr.typedef("String32", xdr.string(32));
    // === xdr source ============================================================
    //
    //   typedef string string64<64>;
    //
    // ===========================================================================
    xdr.typedef("String64", xdr.string(64));
    // === xdr source ============================================================
    //
    //   typedef int64 SequenceNumber;
    //
    // ===========================================================================
    xdr.typedef("SequenceNumber", xdr.lookup("Int64"));
    // === xdr source ============================================================
    //
    //   typedef opaque DataValue<64>;
    //
    // ===========================================================================
    xdr.typedef("DataValue", xdr.varOpaque(64));
    // === xdr source ============================================================
    //
    //   typedef Hash PoolID;
    //
    // ===========================================================================
    xdr.typedef("PoolId", xdr.lookup("Hash"));
    // === xdr source ============================================================
    //
    //   typedef opaque AssetCode4[4];
    //
    // ===========================================================================
    xdr.typedef("AssetCode4", xdr.opaque(4));
    // === xdr source ============================================================
    //
    //   typedef opaque AssetCode12[12];
    //
    // ===========================================================================
    xdr.typedef("AssetCode12", xdr.opaque(12));
    // === xdr source ============================================================
    //
    //   enum AssetType
    //   {
    //       ASSET_TYPE_NATIVE = 0,
    //       ASSET_TYPE_CREDIT_ALPHANUM4 = 1,
    //       ASSET_TYPE_CREDIT_ALPHANUM12 = 2,
    //       ASSET_TYPE_POOL_SHARE = 3
    //   };
    //
    // ===========================================================================
    xdr["enum"]("AssetType", {
        assetTypeNative: 0,
        assetTypeCreditAlphanum4: 1,
        assetTypeCreditAlphanum12: 2,
        assetTypePoolShare: 3
    });
    // === xdr source ============================================================
    //
    //   union AssetCode switch (AssetType type)
    //   {
    //   case ASSET_TYPE_CREDIT_ALPHANUM4:
    //       AssetCode4 assetCode4;
    //
    //   case ASSET_TYPE_CREDIT_ALPHANUM12:
    //       AssetCode12 assetCode12;
    //
    //       // add other asset types here in the future
    //   };
    //
    // ===========================================================================
    xdr.union("AssetCode", {
        switchOn: xdr.lookup("AssetType"),
        switchName: "type",
        switches: [
            [
                "assetTypeCreditAlphanum4",
                "assetCode4"
            ],
            [
                "assetTypeCreditAlphanum12",
                "assetCode12"
            ]
        ],
        arms: {
            assetCode4: xdr.lookup("AssetCode4"),
            assetCode12: xdr.lookup("AssetCode12")
        }
    });
    // === xdr source ============================================================
    //
    //   struct AlphaNum4
    //   {
    //       AssetCode4 assetCode;
    //       AccountID issuer;
    //   };
    //
    // ===========================================================================
    xdr.struct("AlphaNum4", [
        [
            "assetCode",
            xdr.lookup("AssetCode4")
        ],
        [
            "issuer",
            xdr.lookup("AccountId")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct AlphaNum12
    //   {
    //       AssetCode12 assetCode;
    //       AccountID issuer;
    //   };
    //
    // ===========================================================================
    xdr.struct("AlphaNum12", [
        [
            "assetCode",
            xdr.lookup("AssetCode12")
        ],
        [
            "issuer",
            xdr.lookup("AccountId")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union Asset switch (AssetType type)
    //   {
    //   case ASSET_TYPE_NATIVE: // Not credit
    //       void;
    //
    //   case ASSET_TYPE_CREDIT_ALPHANUM4:
    //       AlphaNum4 alphaNum4;
    //
    //   case ASSET_TYPE_CREDIT_ALPHANUM12:
    //       AlphaNum12 alphaNum12;
    //
    //       // add other asset types here in the future
    //   };
    //
    // ===========================================================================
    xdr.union("Asset", {
        switchOn: xdr.lookup("AssetType"),
        switchName: "type",
        switches: [
            [
                "assetTypeNative",
                xdr["void"]()
            ],
            [
                "assetTypeCreditAlphanum4",
                "alphaNum4"
            ],
            [
                "assetTypeCreditAlphanum12",
                "alphaNum12"
            ]
        ],
        arms: {
            alphaNum4: xdr.lookup("AlphaNum4"),
            alphaNum12: xdr.lookup("AlphaNum12")
        }
    });
    // === xdr source ============================================================
    //
    //   struct Price
    //   {
    //       int32 n; // numerator
    //       int32 d; // denominator
    //   };
    //
    // ===========================================================================
    xdr.struct("Price", [
        [
            "n",
            xdr.lookup("Int32")
        ],
        [
            "d",
            xdr.lookup("Int32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct Liabilities
    //   {
    //       int64 buying;
    //       int64 selling;
    //   };
    //
    // ===========================================================================
    xdr.struct("Liabilities", [
        [
            "buying",
            xdr.lookup("Int64")
        ],
        [
            "selling",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum ThresholdIndexes
    //   {
    //       THRESHOLD_MASTER_WEIGHT = 0,
    //       THRESHOLD_LOW = 1,
    //       THRESHOLD_MED = 2,
    //       THRESHOLD_HIGH = 3
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ThresholdIndices", {
        thresholdMasterWeight: 0,
        thresholdLow: 1,
        thresholdMed: 2,
        thresholdHigh: 3
    });
    // === xdr source ============================================================
    //
    //   enum LedgerEntryType
    //   {
    //       ACCOUNT = 0,
    //       TRUSTLINE = 1,
    //       OFFER = 2,
    //       DATA = 3,
    //       CLAIMABLE_BALANCE = 4,
    //       LIQUIDITY_POOL = 5,
    //       CONTRACT_DATA = 6,
    //       CONTRACT_CODE = 7,
    //       CONFIG_SETTING = 8,
    //       TTL = 9
    //   };
    //
    // ===========================================================================
    xdr["enum"]("LedgerEntryType", {
        account: 0,
        trustline: 1,
        offer: 2,
        data: 3,
        claimableBalance: 4,
        liquidityPool: 5,
        contractData: 6,
        contractCode: 7,
        configSetting: 8,
        ttl: 9
    });
    // === xdr source ============================================================
    //
    //   struct Signer
    //   {
    //       SignerKey key;
    //       uint32 weight; // really only need 1 byte
    //   };
    //
    // ===========================================================================
    xdr.struct("Signer", [
        [
            "key",
            xdr.lookup("SignerKey")
        ],
        [
            "weight",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum AccountFlags
    //   { // masks for each flag
    //
    //       // Flags set on issuer accounts
    //       // TrustLines are created with authorized set to "false" requiring
    //       // the issuer to set it for each TrustLine
    //       AUTH_REQUIRED_FLAG = 0x1,
    //       // If set, the authorized flag in TrustLines can be cleared
    //       // otherwise, authorization cannot be revoked
    //       AUTH_REVOCABLE_FLAG = 0x2,
    //       // Once set, causes all AUTH_* flags to be read-only
    //       AUTH_IMMUTABLE_FLAG = 0x4,
    //       // Trustlines are created with clawback enabled set to "true",
    //       // and claimable balances created from those trustlines are created
    //       // with clawback enabled set to "true"
    //       AUTH_CLAWBACK_ENABLED_FLAG = 0x8
    //   };
    //
    // ===========================================================================
    xdr["enum"]("AccountFlags", {
        authRequiredFlag: 1,
        authRevocableFlag: 2,
        authImmutableFlag: 4,
        authClawbackEnabledFlag: 8
    });
    // === xdr source ============================================================
    //
    //   const MASK_ACCOUNT_FLAGS = 0x7;
    //
    // ===========================================================================
    xdr["const"]("MASK_ACCOUNT_FLAGS", 0x7);
    // === xdr source ============================================================
    //
    //   const MASK_ACCOUNT_FLAGS_V17 = 0xF;
    //
    // ===========================================================================
    xdr["const"]("MASK_ACCOUNT_FLAGS_V17", 0xF);
    // === xdr source ============================================================
    //
    //   const MAX_SIGNERS = 20;
    //
    // ===========================================================================
    xdr["const"]("MAX_SIGNERS", 20);
    // === xdr source ============================================================
    //
    //   typedef AccountID* SponsorshipDescriptor;
    //
    // ===========================================================================
    xdr.typedef("SponsorshipDescriptor", xdr.option(xdr.lookup("AccountId")));
    // === xdr source ============================================================
    //
    //   struct AccountEntryExtensionV3
    //   {
    //       // We can use this to add more fields, or because it is first, to
    //       // change AccountEntryExtensionV3 into a union.
    //       ExtensionPoint ext;
    //
    //       // Ledger number at which `seqNum` took on its present value.
    //       uint32 seqLedger;
    //
    //       // Time at which `seqNum` took on its present value.
    //       TimePoint seqTime;
    //   };
    //
    // ===========================================================================
    xdr.struct("AccountEntryExtensionV3", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "seqLedger",
            xdr.lookup("Uint32")
        ],
        [
            "seqTime",
            xdr.lookup("TimePoint")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 3:
    //           AccountEntryExtensionV3 v3;
    //       }
    //
    // ===========================================================================
    xdr.union("AccountEntryExtensionV2Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                3,
                "v3"
            ]
        ],
        arms: {
            v3: xdr.lookup("AccountEntryExtensionV3")
        }
    });
    // === xdr source ============================================================
    //
    //   struct AccountEntryExtensionV2
    //   {
    //       uint32 numSponsored;
    //       uint32 numSponsoring;
    //       SponsorshipDescriptor signerSponsoringIDs<MAX_SIGNERS>;
    //
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 3:
    //           AccountEntryExtensionV3 v3;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("AccountEntryExtensionV2", [
        [
            "numSponsored",
            xdr.lookup("Uint32")
        ],
        [
            "numSponsoring",
            xdr.lookup("Uint32")
        ],
        [
            "signerSponsoringIDs",
            xdr.varArray(xdr.lookup("SponsorshipDescriptor"), xdr.lookup("MAX_SIGNERS"))
        ],
        [
            "ext",
            xdr.lookup("AccountEntryExtensionV2Ext")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 2:
    //           AccountEntryExtensionV2 v2;
    //       }
    //
    // ===========================================================================
    xdr.union("AccountEntryExtensionV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                2,
                "v2"
            ]
        ],
        arms: {
            v2: xdr.lookup("AccountEntryExtensionV2")
        }
    });
    // === xdr source ============================================================
    //
    //   struct AccountEntryExtensionV1
    //   {
    //       Liabilities liabilities;
    //
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 2:
    //           AccountEntryExtensionV2 v2;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("AccountEntryExtensionV1", [
        [
            "liabilities",
            xdr.lookup("Liabilities")
        ],
        [
            "ext",
            xdr.lookup("AccountEntryExtensionV1Ext")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           AccountEntryExtensionV1 v1;
    //       }
    //
    // ===========================================================================
    xdr.union("AccountEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "v1"
            ]
        ],
        arms: {
            v1: xdr.lookup("AccountEntryExtensionV1")
        }
    });
    // === xdr source ============================================================
    //
    //   struct AccountEntry
    //   {
    //       AccountID accountID;      // master public key for this account
    //       int64 balance;            // in stroops
    //       SequenceNumber seqNum;    // last sequence number used for this account
    //       uint32 numSubEntries;     // number of sub-entries this account has
    //                                 // drives the reserve
    //       AccountID* inflationDest; // Account to vote for during inflation
    //       uint32 flags;             // see AccountFlags
    //
    //       string32 homeDomain; // can be used for reverse federation and memo lookup
    //
    //       // fields used for signatures
    //       // thresholds stores unsigned bytes: [weight of master|low|medium|high]
    //       Thresholds thresholds;
    //
    //       Signer signers<MAX_SIGNERS>; // possible signers for this account
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           AccountEntryExtensionV1 v1;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("AccountEntry", [
        [
            "accountId",
            xdr.lookup("AccountId")
        ],
        [
            "balance",
            xdr.lookup("Int64")
        ],
        [
            "seqNum",
            xdr.lookup("SequenceNumber")
        ],
        [
            "numSubEntries",
            xdr.lookup("Uint32")
        ],
        [
            "inflationDest",
            xdr.option(xdr.lookup("AccountId"))
        ],
        [
            "flags",
            xdr.lookup("Uint32")
        ],
        [
            "homeDomain",
            xdr.lookup("String32")
        ],
        [
            "thresholds",
            xdr.lookup("Thresholds")
        ],
        [
            "signers",
            xdr.varArray(xdr.lookup("Signer"), xdr.lookup("MAX_SIGNERS"))
        ],
        [
            "ext",
            xdr.lookup("AccountEntryExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum TrustLineFlags
    //   {
    //       // issuer has authorized account to perform transactions with its credit
    //       AUTHORIZED_FLAG = 1,
    //       // issuer has authorized account to maintain and reduce liabilities for its
    //       // credit
    //       AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG = 2,
    //       // issuer has specified that it may clawback its credit, and that claimable
    //       // balances created with its credit may also be clawed back
    //       TRUSTLINE_CLAWBACK_ENABLED_FLAG = 4
    //   };
    //
    // ===========================================================================
    xdr["enum"]("TrustLineFlags", {
        authorizedFlag: 1,
        authorizedToMaintainLiabilitiesFlag: 2,
        trustlineClawbackEnabledFlag: 4
    });
    // === xdr source ============================================================
    //
    //   const MASK_TRUSTLINE_FLAGS = 1;
    //
    // ===========================================================================
    xdr["const"]("MASK_TRUSTLINE_FLAGS", 1);
    // === xdr source ============================================================
    //
    //   const MASK_TRUSTLINE_FLAGS_V13 = 3;
    //
    // ===========================================================================
    xdr["const"]("MASK_TRUSTLINE_FLAGS_V13", 3);
    // === xdr source ============================================================
    //
    //   const MASK_TRUSTLINE_FLAGS_V17 = 7;
    //
    // ===========================================================================
    xdr["const"]("MASK_TRUSTLINE_FLAGS_V17", 7);
    // === xdr source ============================================================
    //
    //   enum LiquidityPoolType
    //   {
    //       LIQUIDITY_POOL_CONSTANT_PRODUCT = 0
    //   };
    //
    // ===========================================================================
    xdr["enum"]("LiquidityPoolType", {
        liquidityPoolConstantProduct: 0
    });
    // === xdr source ============================================================
    //
    //   union TrustLineAsset switch (AssetType type)
    //   {
    //   case ASSET_TYPE_NATIVE: // Not credit
    //       void;
    //
    //   case ASSET_TYPE_CREDIT_ALPHANUM4:
    //       AlphaNum4 alphaNum4;
    //
    //   case ASSET_TYPE_CREDIT_ALPHANUM12:
    //       AlphaNum12 alphaNum12;
    //
    //   case ASSET_TYPE_POOL_SHARE:
    //       PoolID liquidityPoolID;
    //
    //       // add other asset types here in the future
    //   };
    //
    // ===========================================================================
    xdr.union("TrustLineAsset", {
        switchOn: xdr.lookup("AssetType"),
        switchName: "type",
        switches: [
            [
                "assetTypeNative",
                xdr["void"]()
            ],
            [
                "assetTypeCreditAlphanum4",
                "alphaNum4"
            ],
            [
                "assetTypeCreditAlphanum12",
                "alphaNum12"
            ],
            [
                "assetTypePoolShare",
                "liquidityPoolId"
            ]
        ],
        arms: {
            alphaNum4: xdr.lookup("AlphaNum4"),
            alphaNum12: xdr.lookup("AlphaNum12"),
            liquidityPoolId: xdr.lookup("PoolId")
        }
    });
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("TrustLineEntryExtensionV2Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct TrustLineEntryExtensionV2
    //   {
    //       int32 liquidityPoolUseCount;
    //
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("TrustLineEntryExtensionV2", [
        [
            "liquidityPoolUseCount",
            xdr.lookup("Int32")
        ],
        [
            "ext",
            xdr.lookup("TrustLineEntryExtensionV2Ext")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //               {
    //               case 0:
    //                   void;
    //               case 2:
    //                   TrustLineEntryExtensionV2 v2;
    //               }
    //
    // ===========================================================================
    xdr.union("TrustLineEntryV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                2,
                "v2"
            ]
        ],
        arms: {
            v2: xdr.lookup("TrustLineEntryExtensionV2")
        }
    });
    // === xdr source ============================================================
    //
    //   struct
    //           {
    //               Liabilities liabilities;
    //
    //               union switch (int v)
    //               {
    //               case 0:
    //                   void;
    //               case 2:
    //                   TrustLineEntryExtensionV2 v2;
    //               }
    //               ext;
    //           }
    //
    // ===========================================================================
    xdr.struct("TrustLineEntryV1", [
        [
            "liabilities",
            xdr.lookup("Liabilities")
        ],
        [
            "ext",
            xdr.lookup("TrustLineEntryV1Ext")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           struct
    //           {
    //               Liabilities liabilities;
    //
    //               union switch (int v)
    //               {
    //               case 0:
    //                   void;
    //               case 2:
    //                   TrustLineEntryExtensionV2 v2;
    //               }
    //               ext;
    //           } v1;
    //       }
    //
    // ===========================================================================
    xdr.union("TrustLineEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "v1"
            ]
        ],
        arms: {
            v1: xdr.lookup("TrustLineEntryV1")
        }
    });
    // === xdr source ============================================================
    //
    //   struct TrustLineEntry
    //   {
    //       AccountID accountID;  // account this trustline belongs to
    //       TrustLineAsset asset; // type of asset (with issuer)
    //       int64 balance;        // how much of this asset the user has.
    //                             // Asset defines the unit for this;
    //
    //       int64 limit;  // balance cannot be above this
    //       uint32 flags; // see TrustLineFlags
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           struct
    //           {
    //               Liabilities liabilities;
    //
    //               union switch (int v)
    //               {
    //               case 0:
    //                   void;
    //               case 2:
    //                   TrustLineEntryExtensionV2 v2;
    //               }
    //               ext;
    //           } v1;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("TrustLineEntry", [
        [
            "accountId",
            xdr.lookup("AccountId")
        ],
        [
            "asset",
            xdr.lookup("TrustLineAsset")
        ],
        [
            "balance",
            xdr.lookup("Int64")
        ],
        [
            "limit",
            xdr.lookup("Int64")
        ],
        [
            "flags",
            xdr.lookup("Uint32")
        ],
        [
            "ext",
            xdr.lookup("TrustLineEntryExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum OfferEntryFlags
    //   {
    //       // an offer with this flag will not act on and take a reverse offer of equal
    //       // price
    //       PASSIVE_FLAG = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("OfferEntryFlags", {
        passiveFlag: 1
    });
    // === xdr source ============================================================
    //
    //   const MASK_OFFERENTRY_FLAGS = 1;
    //
    // ===========================================================================
    xdr["const"]("MASK_OFFERENTRY_FLAGS", 1);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("OfferEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct OfferEntry
    //   {
    //       AccountID sellerID;
    //       int64 offerID;
    //       Asset selling; // A
    //       Asset buying;  // B
    //       int64 amount;  // amount of A
    //
    //       /* price for this offer:
    //           price of A in terms of B
    //           price=AmountB/AmountA=priceNumerator/priceDenominator
    //           price is after fees
    //       */
    //       Price price;
    //       uint32 flags; // see OfferEntryFlags
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("OfferEntry", [
        [
            "sellerId",
            xdr.lookup("AccountId")
        ],
        [
            "offerId",
            xdr.lookup("Int64")
        ],
        [
            "selling",
            xdr.lookup("Asset")
        ],
        [
            "buying",
            xdr.lookup("Asset")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ],
        [
            "price",
            xdr.lookup("Price")
        ],
        [
            "flags",
            xdr.lookup("Uint32")
        ],
        [
            "ext",
            xdr.lookup("OfferEntryExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("DataEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct DataEntry
    //   {
    //       AccountID accountID; // account this data belongs to
    //       string64 dataName;
    //       DataValue dataValue;
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("DataEntry", [
        [
            "accountId",
            xdr.lookup("AccountId")
        ],
        [
            "dataName",
            xdr.lookup("String64")
        ],
        [
            "dataValue",
            xdr.lookup("DataValue")
        ],
        [
            "ext",
            xdr.lookup("DataEntryExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum ClaimPredicateType
    //   {
    //       CLAIM_PREDICATE_UNCONDITIONAL = 0,
    //       CLAIM_PREDICATE_AND = 1,
    //       CLAIM_PREDICATE_OR = 2,
    //       CLAIM_PREDICATE_NOT = 3,
    //       CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME = 4,
    //       CLAIM_PREDICATE_BEFORE_RELATIVE_TIME = 5
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ClaimPredicateType", {
        claimPredicateUnconditional: 0,
        claimPredicateAnd: 1,
        claimPredicateOr: 2,
        claimPredicateNot: 3,
        claimPredicateBeforeAbsoluteTime: 4,
        claimPredicateBeforeRelativeTime: 5
    });
    // === xdr source ============================================================
    //
    //   union ClaimPredicate switch (ClaimPredicateType type)
    //   {
    //   case CLAIM_PREDICATE_UNCONDITIONAL:
    //       void;
    //   case CLAIM_PREDICATE_AND:
    //       ClaimPredicate andPredicates<2>;
    //   case CLAIM_PREDICATE_OR:
    //       ClaimPredicate orPredicates<2>;
    //   case CLAIM_PREDICATE_NOT:
    //       ClaimPredicate* notPredicate;
    //   case CLAIM_PREDICATE_BEFORE_ABSOLUTE_TIME:
    //       int64 absBefore; // Predicate will be true if closeTime < absBefore
    //   case CLAIM_PREDICATE_BEFORE_RELATIVE_TIME:
    //       int64 relBefore; // Seconds since closeTime of the ledger in which the
    //                        // ClaimableBalanceEntry was created
    //   };
    //
    // ===========================================================================
    xdr.union("ClaimPredicate", {
        switchOn: xdr.lookup("ClaimPredicateType"),
        switchName: "type",
        switches: [
            [
                "claimPredicateUnconditional",
                xdr["void"]()
            ],
            [
                "claimPredicateAnd",
                "andPredicates"
            ],
            [
                "claimPredicateOr",
                "orPredicates"
            ],
            [
                "claimPredicateNot",
                "notPredicate"
            ],
            [
                "claimPredicateBeforeAbsoluteTime",
                "absBefore"
            ],
            [
                "claimPredicateBeforeRelativeTime",
                "relBefore"
            ]
        ],
        arms: {
            andPredicates: xdr.varArray(xdr.lookup("ClaimPredicate"), 2),
            orPredicates: xdr.varArray(xdr.lookup("ClaimPredicate"), 2),
            notPredicate: xdr.option(xdr.lookup("ClaimPredicate")),
            absBefore: xdr.lookup("Int64"),
            relBefore: xdr.lookup("Int64")
        }
    });
    // === xdr source ============================================================
    //
    //   enum ClaimantType
    //   {
    //       CLAIMANT_TYPE_V0 = 0
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ClaimantType", {
        claimantTypeV0: 0
    });
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           AccountID destination;    // The account that can use this condition
    //           ClaimPredicate predicate; // Claimable if predicate is true
    //       }
    //
    // ===========================================================================
    xdr.struct("ClaimantV0", [
        [
            "destination",
            xdr.lookup("AccountId")
        ],
        [
            "predicate",
            xdr.lookup("ClaimPredicate")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union Claimant switch (ClaimantType type)
    //   {
    //   case CLAIMANT_TYPE_V0:
    //       struct
    //       {
    //           AccountID destination;    // The account that can use this condition
    //           ClaimPredicate predicate; // Claimable if predicate is true
    //       } v0;
    //   };
    //
    // ===========================================================================
    xdr.union("Claimant", {
        switchOn: xdr.lookup("ClaimantType"),
        switchName: "type",
        switches: [
            [
                "claimantTypeV0",
                "v0"
            ]
        ],
        arms: {
            v0: xdr.lookup("ClaimantV0")
        }
    });
    // === xdr source ============================================================
    //
    //   enum ClaimableBalanceIDType
    //   {
    //       CLAIMABLE_BALANCE_ID_TYPE_V0 = 0
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ClaimableBalanceIdType", {
        claimableBalanceIdTypeV0: 0
    });
    // === xdr source ============================================================
    //
    //   union ClaimableBalanceID switch (ClaimableBalanceIDType type)
    //   {
    //   case CLAIMABLE_BALANCE_ID_TYPE_V0:
    //       Hash v0;
    //   };
    //
    // ===========================================================================
    xdr.union("ClaimableBalanceId", {
        switchOn: xdr.lookup("ClaimableBalanceIdType"),
        switchName: "type",
        switches: [
            [
                "claimableBalanceIdTypeV0",
                "v0"
            ]
        ],
        arms: {
            v0: xdr.lookup("Hash")
        }
    });
    // === xdr source ============================================================
    //
    //   enum ClaimableBalanceFlags
    //   {
    //       // If set, the issuer account of the asset held by the claimable balance may
    //       // clawback the claimable balance
    //       CLAIMABLE_BALANCE_CLAWBACK_ENABLED_FLAG = 0x1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ClaimableBalanceFlags", {
        claimableBalanceClawbackEnabledFlag: 1
    });
    // === xdr source ============================================================
    //
    //   const MASK_CLAIMABLE_BALANCE_FLAGS = 0x1;
    //
    // ===========================================================================
    xdr["const"]("MASK_CLAIMABLE_BALANCE_FLAGS", 0x1);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("ClaimableBalanceEntryExtensionV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct ClaimableBalanceEntryExtensionV1
    //   {
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //
    //       uint32 flags; // see ClaimableBalanceFlags
    //   };
    //
    // ===========================================================================
    xdr.struct("ClaimableBalanceEntryExtensionV1", [
        [
            "ext",
            xdr.lookup("ClaimableBalanceEntryExtensionV1Ext")
        ],
        [
            "flags",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           ClaimableBalanceEntryExtensionV1 v1;
    //       }
    //
    // ===========================================================================
    xdr.union("ClaimableBalanceEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "v1"
            ]
        ],
        arms: {
            v1: xdr.lookup("ClaimableBalanceEntryExtensionV1")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ClaimableBalanceEntry
    //   {
    //       // Unique identifier for this ClaimableBalanceEntry
    //       ClaimableBalanceID balanceID;
    //
    //       // List of claimants with associated predicate
    //       Claimant claimants<10>;
    //
    //       // Any asset including native
    //       Asset asset;
    //
    //       // Amount of asset
    //       int64 amount;
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           ClaimableBalanceEntryExtensionV1 v1;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("ClaimableBalanceEntry", [
        [
            "balanceId",
            xdr.lookup("ClaimableBalanceId")
        ],
        [
            "claimants",
            xdr.varArray(xdr.lookup("Claimant"), 10)
        ],
        [
            "asset",
            xdr.lookup("Asset")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ],
        [
            "ext",
            xdr.lookup("ClaimableBalanceEntryExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct LiquidityPoolConstantProductParameters
    //   {
    //       Asset assetA; // assetA < assetB
    //       Asset assetB;
    //       int32 fee; // Fee is in basis points, so the actual rate is (fee/100)%
    //   };
    //
    // ===========================================================================
    xdr.struct("LiquidityPoolConstantProductParameters", [
        [
            "assetA",
            xdr.lookup("Asset")
        ],
        [
            "assetB",
            xdr.lookup("Asset")
        ],
        [
            "fee",
            xdr.lookup("Int32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //           {
    //               LiquidityPoolConstantProductParameters params;
    //
    //               int64 reserveA;        // amount of A in the pool
    //               int64 reserveB;        // amount of B in the pool
    //               int64 totalPoolShares; // total number of pool shares issued
    //               int64 poolSharesTrustLineCount; // number of trust lines for the
    //                                               // associated pool shares
    //           }
    //
    // ===========================================================================
    xdr.struct("LiquidityPoolEntryConstantProduct", [
        [
            "params",
            xdr.lookup("LiquidityPoolConstantProductParameters")
        ],
        [
            "reserveA",
            xdr.lookup("Int64")
        ],
        [
            "reserveB",
            xdr.lookup("Int64")
        ],
        [
            "totalPoolShares",
            xdr.lookup("Int64")
        ],
        [
            "poolSharesTrustLineCount",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (LiquidityPoolType type)
    //       {
    //       case LIQUIDITY_POOL_CONSTANT_PRODUCT:
    //           struct
    //           {
    //               LiquidityPoolConstantProductParameters params;
    //
    //               int64 reserveA;        // amount of A in the pool
    //               int64 reserveB;        // amount of B in the pool
    //               int64 totalPoolShares; // total number of pool shares issued
    //               int64 poolSharesTrustLineCount; // number of trust lines for the
    //                                               // associated pool shares
    //           } constantProduct;
    //       }
    //
    // ===========================================================================
    xdr.union("LiquidityPoolEntryBody", {
        switchOn: xdr.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [
            [
                "liquidityPoolConstantProduct",
                "constantProduct"
            ]
        ],
        arms: {
            constantProduct: xdr.lookup("LiquidityPoolEntryConstantProduct")
        }
    });
    // === xdr source ============================================================
    //
    //   struct LiquidityPoolEntry
    //   {
    //       PoolID liquidityPoolID;
    //
    //       union switch (LiquidityPoolType type)
    //       {
    //       case LIQUIDITY_POOL_CONSTANT_PRODUCT:
    //           struct
    //           {
    //               LiquidityPoolConstantProductParameters params;
    //
    //               int64 reserveA;        // amount of A in the pool
    //               int64 reserveB;        // amount of B in the pool
    //               int64 totalPoolShares; // total number of pool shares issued
    //               int64 poolSharesTrustLineCount; // number of trust lines for the
    //                                               // associated pool shares
    //           } constantProduct;
    //       }
    //       body;
    //   };
    //
    // ===========================================================================
    xdr.struct("LiquidityPoolEntry", [
        [
            "liquidityPoolId",
            xdr.lookup("PoolId")
        ],
        [
            "body",
            xdr.lookup("LiquidityPoolEntryBody")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum ContractDataDurability {
    //       TEMPORARY = 0,
    //       PERSISTENT = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ContractDataDurability", {
        temporary: 0,
        persistent: 1
    });
    // === xdr source ============================================================
    //
    //   struct ContractDataEntry {
    //       ExtensionPoint ext;
    //
    //       SCAddress contract;
    //       SCVal key;
    //       ContractDataDurability durability;
    //       SCVal val;
    //   };
    //
    // ===========================================================================
    xdr.struct("ContractDataEntry", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "contract",
            xdr.lookup("ScAddress")
        ],
        [
            "key",
            xdr.lookup("ScVal")
        ],
        [
            "durability",
            xdr.lookup("ContractDataDurability")
        ],
        [
            "val",
            xdr.lookup("ScVal")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ContractCodeCostInputs {
    //       ExtensionPoint ext;
    //       uint32 nInstructions;
    //       uint32 nFunctions;
    //       uint32 nGlobals;
    //       uint32 nTableEntries;
    //       uint32 nTypes;
    //       uint32 nDataSegments;
    //       uint32 nElemSegments;
    //       uint32 nImports;
    //       uint32 nExports;
    //       uint32 nDataSegmentBytes;
    //   };
    //
    // ===========================================================================
    xdr.struct("ContractCodeCostInputs", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "nInstructions",
            xdr.lookup("Uint32")
        ],
        [
            "nFunctions",
            xdr.lookup("Uint32")
        ],
        [
            "nGlobals",
            xdr.lookup("Uint32")
        ],
        [
            "nTableEntries",
            xdr.lookup("Uint32")
        ],
        [
            "nTypes",
            xdr.lookup("Uint32")
        ],
        [
            "nDataSegments",
            xdr.lookup("Uint32")
        ],
        [
            "nElemSegments",
            xdr.lookup("Uint32")
        ],
        [
            "nImports",
            xdr.lookup("Uint32")
        ],
        [
            "nExports",
            xdr.lookup("Uint32")
        ],
        [
            "nDataSegmentBytes",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //               {
    //                   ExtensionPoint ext;
    //                   ContractCodeCostInputs costInputs;
    //               }
    //
    // ===========================================================================
    xdr.struct("ContractCodeEntryV1", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "costInputs",
            xdr.lookup("ContractCodeCostInputs")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //           case 0:
    //               void;
    //           case 1:
    //               struct
    //               {
    //                   ExtensionPoint ext;
    //                   ContractCodeCostInputs costInputs;
    //               } v1;
    //       }
    //
    // ===========================================================================
    xdr.union("ContractCodeEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "v1"
            ]
        ],
        arms: {
            v1: xdr.lookup("ContractCodeEntryV1")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ContractCodeEntry {
    //       union switch (int v)
    //       {
    //           case 0:
    //               void;
    //           case 1:
    //               struct
    //               {
    //                   ExtensionPoint ext;
    //                   ContractCodeCostInputs costInputs;
    //               } v1;
    //       } ext;
    //
    //       Hash hash;
    //       opaque code<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ContractCodeEntry", [
        [
            "ext",
            xdr.lookup("ContractCodeEntryExt")
        ],
        [
            "hash",
            xdr.lookup("Hash")
        ],
        [
            "code",
            xdr.varOpaque()
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TTLEntry {
    //       // Hash of the LedgerKey that is associated with this TTLEntry
    //       Hash keyHash;
    //       uint32 liveUntilLedgerSeq;
    //   };
    //
    // ===========================================================================
    xdr.struct("TtlEntry", [
        [
            "keyHash",
            xdr.lookup("Hash")
        ],
        [
            "liveUntilLedgerSeq",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("LedgerEntryExtensionV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct LedgerEntryExtensionV1
    //   {
    //       SponsorshipDescriptor sponsoringID;
    //
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerEntryExtensionV1", [
        [
            "sponsoringId",
            xdr.lookup("SponsorshipDescriptor")
        ],
        [
            "ext",
            xdr.lookup("LedgerEntryExtensionV1Ext")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (LedgerEntryType type)
    //       {
    //       case ACCOUNT:
    //           AccountEntry account;
    //       case TRUSTLINE:
    //           TrustLineEntry trustLine;
    //       case OFFER:
    //           OfferEntry offer;
    //       case DATA:
    //           DataEntry data;
    //       case CLAIMABLE_BALANCE:
    //           ClaimableBalanceEntry claimableBalance;
    //       case LIQUIDITY_POOL:
    //           LiquidityPoolEntry liquidityPool;
    //       case CONTRACT_DATA:
    //           ContractDataEntry contractData;
    //       case CONTRACT_CODE:
    //           ContractCodeEntry contractCode;
    //       case CONFIG_SETTING:
    //           ConfigSettingEntry configSetting;
    //       case TTL:
    //           TTLEntry ttl;
    //       }
    //
    // ===========================================================================
    xdr.union("LedgerEntryData", {
        switchOn: xdr.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [
            [
                "account",
                "account"
            ],
            [
                "trustline",
                "trustLine"
            ],
            [
                "offer",
                "offer"
            ],
            [
                "data",
                "data"
            ],
            [
                "claimableBalance",
                "claimableBalance"
            ],
            [
                "liquidityPool",
                "liquidityPool"
            ],
            [
                "contractData",
                "contractData"
            ],
            [
                "contractCode",
                "contractCode"
            ],
            [
                "configSetting",
                "configSetting"
            ],
            [
                "ttl",
                "ttl"
            ]
        ],
        arms: {
            account: xdr.lookup("AccountEntry"),
            trustLine: xdr.lookup("TrustLineEntry"),
            offer: xdr.lookup("OfferEntry"),
            data: xdr.lookup("DataEntry"),
            claimableBalance: xdr.lookup("ClaimableBalanceEntry"),
            liquidityPool: xdr.lookup("LiquidityPoolEntry"),
            contractData: xdr.lookup("ContractDataEntry"),
            contractCode: xdr.lookup("ContractCodeEntry"),
            configSetting: xdr.lookup("ConfigSettingEntry"),
            ttl: xdr.lookup("TtlEntry")
        }
    });
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           LedgerEntryExtensionV1 v1;
    //       }
    //
    // ===========================================================================
    xdr.union("LedgerEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "v1"
            ]
        ],
        arms: {
            v1: xdr.lookup("LedgerEntryExtensionV1")
        }
    });
    // === xdr source ============================================================
    //
    //   struct LedgerEntry
    //   {
    //       uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed
    //
    //       union switch (LedgerEntryType type)
    //       {
    //       case ACCOUNT:
    //           AccountEntry account;
    //       case TRUSTLINE:
    //           TrustLineEntry trustLine;
    //       case OFFER:
    //           OfferEntry offer;
    //       case DATA:
    //           DataEntry data;
    //       case CLAIMABLE_BALANCE:
    //           ClaimableBalanceEntry claimableBalance;
    //       case LIQUIDITY_POOL:
    //           LiquidityPoolEntry liquidityPool;
    //       case CONTRACT_DATA:
    //           ContractDataEntry contractData;
    //       case CONTRACT_CODE:
    //           ContractCodeEntry contractCode;
    //       case CONFIG_SETTING:
    //           ConfigSettingEntry configSetting;
    //       case TTL:
    //           TTLEntry ttl;
    //       }
    //       data;
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           LedgerEntryExtensionV1 v1;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerEntry", [
        [
            "lastModifiedLedgerSeq",
            xdr.lookup("Uint32")
        ],
        [
            "data",
            xdr.lookup("LedgerEntryData")
        ],
        [
            "ext",
            xdr.lookup("LedgerEntryExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           AccountID accountID;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyAccount", [
        [
            "accountId",
            xdr.lookup("AccountId")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           AccountID accountID;
    //           TrustLineAsset asset;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyTrustLine", [
        [
            "accountId",
            xdr.lookup("AccountId")
        ],
        [
            "asset",
            xdr.lookup("TrustLineAsset")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           AccountID sellerID;
    //           int64 offerID;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyOffer", [
        [
            "sellerId",
            xdr.lookup("AccountId")
        ],
        [
            "offerId",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           AccountID accountID;
    //           string64 dataName;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyData", [
        [
            "accountId",
            xdr.lookup("AccountId")
        ],
        [
            "dataName",
            xdr.lookup("String64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           ClaimableBalanceID balanceID;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyClaimableBalance", [
        [
            "balanceId",
            xdr.lookup("ClaimableBalanceId")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           PoolID liquidityPoolID;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyLiquidityPool", [
        [
            "liquidityPoolId",
            xdr.lookup("PoolId")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           SCAddress contract;
    //           SCVal key;
    //           ContractDataDurability durability;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyContractData", [
        [
            "contract",
            xdr.lookup("ScAddress")
        ],
        [
            "key",
            xdr.lookup("ScVal")
        ],
        [
            "durability",
            xdr.lookup("ContractDataDurability")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           Hash hash;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyContractCode", [
        [
            "hash",
            xdr.lookup("Hash")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           ConfigSettingID configSettingID;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyConfigSetting", [
        [
            "configSettingId",
            xdr.lookup("ConfigSettingId")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           // Hash of the LedgerKey that is associated with this TTLEntry
    //           Hash keyHash;
    //       }
    //
    // ===========================================================================
    xdr.struct("LedgerKeyTtl", [
        [
            "keyHash",
            xdr.lookup("Hash")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union LedgerKey switch (LedgerEntryType type)
    //   {
    //   case ACCOUNT:
    //       struct
    //       {
    //           AccountID accountID;
    //       } account;
    //
    //   case TRUSTLINE:
    //       struct
    //       {
    //           AccountID accountID;
    //           TrustLineAsset asset;
    //       } trustLine;
    //
    //   case OFFER:
    //       struct
    //       {
    //           AccountID sellerID;
    //           int64 offerID;
    //       } offer;
    //
    //   case DATA:
    //       struct
    //       {
    //           AccountID accountID;
    //           string64 dataName;
    //       } data;
    //
    //   case CLAIMABLE_BALANCE:
    //       struct
    //       {
    //           ClaimableBalanceID balanceID;
    //       } claimableBalance;
    //
    //   case LIQUIDITY_POOL:
    //       struct
    //       {
    //           PoolID liquidityPoolID;
    //       } liquidityPool;
    //   case CONTRACT_DATA:
    //       struct
    //       {
    //           SCAddress contract;
    //           SCVal key;
    //           ContractDataDurability durability;
    //       } contractData;
    //   case CONTRACT_CODE:
    //       struct
    //       {
    //           Hash hash;
    //       } contractCode;
    //   case CONFIG_SETTING:
    //       struct
    //       {
    //           ConfigSettingID configSettingID;
    //       } configSetting;
    //   case TTL:
    //       struct
    //       {
    //           // Hash of the LedgerKey that is associated with this TTLEntry
    //           Hash keyHash;
    //       } ttl;
    //   };
    //
    // ===========================================================================
    xdr.union("LedgerKey", {
        switchOn: xdr.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [
            [
                "account",
                "account"
            ],
            [
                "trustline",
                "trustLine"
            ],
            [
                "offer",
                "offer"
            ],
            [
                "data",
                "data"
            ],
            [
                "claimableBalance",
                "claimableBalance"
            ],
            [
                "liquidityPool",
                "liquidityPool"
            ],
            [
                "contractData",
                "contractData"
            ],
            [
                "contractCode",
                "contractCode"
            ],
            [
                "configSetting",
                "configSetting"
            ],
            [
                "ttl",
                "ttl"
            ]
        ],
        arms: {
            account: xdr.lookup("LedgerKeyAccount"),
            trustLine: xdr.lookup("LedgerKeyTrustLine"),
            offer: xdr.lookup("LedgerKeyOffer"),
            data: xdr.lookup("LedgerKeyData"),
            claimableBalance: xdr.lookup("LedgerKeyClaimableBalance"),
            liquidityPool: xdr.lookup("LedgerKeyLiquidityPool"),
            contractData: xdr.lookup("LedgerKeyContractData"),
            contractCode: xdr.lookup("LedgerKeyContractCode"),
            configSetting: xdr.lookup("LedgerKeyConfigSetting"),
            ttl: xdr.lookup("LedgerKeyTtl")
        }
    });
    // === xdr source ============================================================
    //
    //   enum EnvelopeType
    //   {
    //       ENVELOPE_TYPE_TX_V0 = 0,
    //       ENVELOPE_TYPE_SCP = 1,
    //       ENVELOPE_TYPE_TX = 2,
    //       ENVELOPE_TYPE_AUTH = 3,
    //       ENVELOPE_TYPE_SCPVALUE = 4,
    //       ENVELOPE_TYPE_TX_FEE_BUMP = 5,
    //       ENVELOPE_TYPE_OP_ID = 6,
    //       ENVELOPE_TYPE_POOL_REVOKE_OP_ID = 7,
    //       ENVELOPE_TYPE_CONTRACT_ID = 8,
    //       ENVELOPE_TYPE_SOROBAN_AUTHORIZATION = 9
    //   };
    //
    // ===========================================================================
    xdr["enum"]("EnvelopeType", {
        envelopeTypeTxV0: 0,
        envelopeTypeScp: 1,
        envelopeTypeTx: 2,
        envelopeTypeAuth: 3,
        envelopeTypeScpvalue: 4,
        envelopeTypeTxFeeBump: 5,
        envelopeTypeOpId: 6,
        envelopeTypePoolRevokeOpId: 7,
        envelopeTypeContractId: 8,
        envelopeTypeSorobanAuthorization: 9
    });
    // === xdr source ============================================================
    //
    //   enum BucketListType
    //   {
    //       LIVE = 0,
    //       HOT_ARCHIVE = 1,
    //       COLD_ARCHIVE = 2
    //   };
    //
    // ===========================================================================
    xdr["enum"]("BucketListType", {
        live: 0,
        hotArchive: 1,
        coldArchive: 2
    });
    // === xdr source ============================================================
    //
    //   enum BucketEntryType
    //   {
    //       METAENTRY =
    //           -1, // At-and-after protocol 11: bucket metadata, should come first.
    //       LIVEENTRY = 0, // Before protocol 11: created-or-updated;
    //                      // At-and-after protocol 11: only updated.
    //       DEADENTRY = 1,
    //       INITENTRY = 2 // At-and-after protocol 11: only created.
    //   };
    //
    // ===========================================================================
    xdr["enum"]("BucketEntryType", {
        metaentry: -1,
        liveentry: 0,
        deadentry: 1,
        initentry: 2
    });
    // === xdr source ============================================================
    //
    //   enum HotArchiveBucketEntryType
    //   {
    //       HOT_ARCHIVE_METAENTRY = -1, // Bucket metadata, should come first.
    //       HOT_ARCHIVE_ARCHIVED = 0,   // Entry is Archived
    //       HOT_ARCHIVE_LIVE = 1,       // Entry was previously HOT_ARCHIVE_ARCHIVED, or HOT_ARCHIVE_DELETED, but
    //                                   // has been added back to the live BucketList.
    //                                   // Does not need to be persisted.
    //       HOT_ARCHIVE_DELETED = 2     // Entry deleted (Note: must be persisted in archive)
    //   };
    //
    // ===========================================================================
    xdr["enum"]("HotArchiveBucketEntryType", {
        hotArchiveMetaentry: -1,
        hotArchiveArchived: 0,
        hotArchiveLive: 1,
        hotArchiveDeleted: 2
    });
    // === xdr source ============================================================
    //
    //   enum ColdArchiveBucketEntryType
    //   {
    //       COLD_ARCHIVE_METAENTRY     = -1,  // Bucket metadata, should come first.
    //       COLD_ARCHIVE_ARCHIVED_LEAF = 0,   // Full LedgerEntry that was archived during the epoch
    //       COLD_ARCHIVE_DELETED_LEAF  = 1,   // LedgerKey that was deleted during the epoch
    //       COLD_ARCHIVE_BOUNDARY_LEAF = 2,   // Dummy leaf representing low/high bound
    //       COLD_ARCHIVE_HASH          = 3    // Intermediary Merkle hash entry
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ColdArchiveBucketEntryType", {
        coldArchiveMetaentry: -1,
        coldArchiveArchivedLeaf: 0,
        coldArchiveDeletedLeaf: 1,
        coldArchiveBoundaryLeaf: 2,
        coldArchiveHash: 3
    });
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           BucketListType bucketListType;
    //       }
    //
    // ===========================================================================
    xdr.union("BucketMetadataExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "bucketListType"
            ]
        ],
        arms: {
            bucketListType: xdr.lookup("BucketListType")
        }
    });
    // === xdr source ============================================================
    //
    //   struct BucketMetadata
    //   {
    //       // Indicates the protocol version used to create / merge this bucket.
    //       uint32 ledgerVersion;
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           BucketListType bucketListType;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("BucketMetadata", [
        [
            "ledgerVersion",
            xdr.lookup("Uint32")
        ],
        [
            "ext",
            xdr.lookup("BucketMetadataExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union BucketEntry switch (BucketEntryType type)
    //   {
    //   case LIVEENTRY:
    //   case INITENTRY:
    //       LedgerEntry liveEntry;
    //
    //   case DEADENTRY:
    //       LedgerKey deadEntry;
    //   case METAENTRY:
    //       BucketMetadata metaEntry;
    //   };
    //
    // ===========================================================================
    xdr.union("BucketEntry", {
        switchOn: xdr.lookup("BucketEntryType"),
        switchName: "type",
        switches: [
            [
                "liveentry",
                "liveEntry"
            ],
            [
                "initentry",
                "liveEntry"
            ],
            [
                "deadentry",
                "deadEntry"
            ],
            [
                "metaentry",
                "metaEntry"
            ]
        ],
        arms: {
            liveEntry: xdr.lookup("LedgerEntry"),
            deadEntry: xdr.lookup("LedgerKey"),
            metaEntry: xdr.lookup("BucketMetadata")
        }
    });
    // === xdr source ============================================================
    //
    //   union HotArchiveBucketEntry switch (HotArchiveBucketEntryType type)
    //   {
    //   case HOT_ARCHIVE_ARCHIVED:
    //       LedgerEntry archivedEntry;
    //
    //   case HOT_ARCHIVE_LIVE:
    //   case HOT_ARCHIVE_DELETED:
    //       LedgerKey key;
    //   case HOT_ARCHIVE_METAENTRY:
    //       BucketMetadata metaEntry;
    //   };
    //
    // ===========================================================================
    xdr.union("HotArchiveBucketEntry", {
        switchOn: xdr.lookup("HotArchiveBucketEntryType"),
        switchName: "type",
        switches: [
            [
                "hotArchiveArchived",
                "archivedEntry"
            ],
            [
                "hotArchiveLive",
                "key"
            ],
            [
                "hotArchiveDeleted",
                "key"
            ],
            [
                "hotArchiveMetaentry",
                "metaEntry"
            ]
        ],
        arms: {
            archivedEntry: xdr.lookup("LedgerEntry"),
            key: xdr.lookup("LedgerKey"),
            metaEntry: xdr.lookup("BucketMetadata")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ColdArchiveArchivedLeaf
    //   {
    //       uint32 index;
    //       LedgerEntry archivedEntry;
    //   };
    //
    // ===========================================================================
    xdr.struct("ColdArchiveArchivedLeaf", [
        [
            "index",
            xdr.lookup("Uint32")
        ],
        [
            "archivedEntry",
            xdr.lookup("LedgerEntry")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ColdArchiveDeletedLeaf
    //   {
    //       uint32 index;
    //       LedgerKey deletedKey;
    //   };
    //
    // ===========================================================================
    xdr.struct("ColdArchiveDeletedLeaf", [
        [
            "index",
            xdr.lookup("Uint32")
        ],
        [
            "deletedKey",
            xdr.lookup("LedgerKey")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ColdArchiveBoundaryLeaf
    //   {
    //       uint32 index;
    //       bool isLowerBound;
    //   };
    //
    // ===========================================================================
    xdr.struct("ColdArchiveBoundaryLeaf", [
        [
            "index",
            xdr.lookup("Uint32")
        ],
        [
            "isLowerBound",
            xdr.bool()
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ColdArchiveHashEntry
    //   {
    //       uint32 index;
    //       uint32 level;
    //       Hash hash;
    //   };
    //
    // ===========================================================================
    xdr.struct("ColdArchiveHashEntry", [
        [
            "index",
            xdr.lookup("Uint32")
        ],
        [
            "level",
            xdr.lookup("Uint32")
        ],
        [
            "hash",
            xdr.lookup("Hash")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union ColdArchiveBucketEntry switch (ColdArchiveBucketEntryType type)
    //   {
    //   case COLD_ARCHIVE_METAENTRY:
    //       BucketMetadata metaEntry;
    //   case COLD_ARCHIVE_ARCHIVED_LEAF:
    //       ColdArchiveArchivedLeaf archivedLeaf;
    //   case COLD_ARCHIVE_DELETED_LEAF:
    //       ColdArchiveDeletedLeaf deletedLeaf;
    //   case COLD_ARCHIVE_BOUNDARY_LEAF:
    //       ColdArchiveBoundaryLeaf boundaryLeaf;
    //   case COLD_ARCHIVE_HASH:
    //       ColdArchiveHashEntry hashEntry;
    //   };
    //
    // ===========================================================================
    xdr.union("ColdArchiveBucketEntry", {
        switchOn: xdr.lookup("ColdArchiveBucketEntryType"),
        switchName: "type",
        switches: [
            [
                "coldArchiveMetaentry",
                "metaEntry"
            ],
            [
                "coldArchiveArchivedLeaf",
                "archivedLeaf"
            ],
            [
                "coldArchiveDeletedLeaf",
                "deletedLeaf"
            ],
            [
                "coldArchiveBoundaryLeaf",
                "boundaryLeaf"
            ],
            [
                "coldArchiveHash",
                "hashEntry"
            ]
        ],
        arms: {
            metaEntry: xdr.lookup("BucketMetadata"),
            archivedLeaf: xdr.lookup("ColdArchiveArchivedLeaf"),
            deletedLeaf: xdr.lookup("ColdArchiveDeletedLeaf"),
            boundaryLeaf: xdr.lookup("ColdArchiveBoundaryLeaf"),
            hashEntry: xdr.lookup("ColdArchiveHashEntry")
        }
    });
    // === xdr source ============================================================
    //
    //   typedef opaque UpgradeType<128>;
    //
    // ===========================================================================
    xdr.typedef("UpgradeType", xdr.varOpaque(128));
    // === xdr source ============================================================
    //
    //   enum StellarValueType
    //   {
    //       STELLAR_VALUE_BASIC = 0,
    //       STELLAR_VALUE_SIGNED = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("StellarValueType", {
        stellarValueBasic: 0,
        stellarValueSigned: 1
    });
    // === xdr source ============================================================
    //
    //   struct LedgerCloseValueSignature
    //   {
    //       NodeID nodeID;       // which node introduced the value
    //       Signature signature; // nodeID's signature
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerCloseValueSignature", [
        [
            "nodeId",
            xdr.lookup("NodeId")
        ],
        [
            "signature",
            xdr.lookup("Signature")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (StellarValueType v)
    //       {
    //       case STELLAR_VALUE_BASIC:
    //           void;
    //       case STELLAR_VALUE_SIGNED:
    //           LedgerCloseValueSignature lcValueSignature;
    //       }
    //
    // ===========================================================================
    xdr.union("StellarValueExt", {
        switchOn: xdr.lookup("StellarValueType"),
        switchName: "v",
        switches: [
            [
                "stellarValueBasic",
                xdr["void"]()
            ],
            [
                "stellarValueSigned",
                "lcValueSignature"
            ]
        ],
        arms: {
            lcValueSignature: xdr.lookup("LedgerCloseValueSignature")
        }
    });
    // === xdr source ============================================================
    //
    //   struct StellarValue
    //   {
    //       Hash txSetHash;      // transaction set to apply to previous ledger
    //       TimePoint closeTime; // network close time
    //
    //       // upgrades to apply to the previous ledger (usually empty)
    //       // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
    //       // unknown steps during consensus if needed.
    //       // see notes below on 'LedgerUpgrade' for more detail
    //       // max size is dictated by number of upgrade types (+ room for future)
    //       UpgradeType upgrades<6>;
    //
    //       // reserved for future use
    //       union switch (StellarValueType v)
    //       {
    //       case STELLAR_VALUE_BASIC:
    //           void;
    //       case STELLAR_VALUE_SIGNED:
    //           LedgerCloseValueSignature lcValueSignature;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("StellarValue", [
        [
            "txSetHash",
            xdr.lookup("Hash")
        ],
        [
            "closeTime",
            xdr.lookup("TimePoint")
        ],
        [
            "upgrades",
            xdr.varArray(xdr.lookup("UpgradeType"), 6)
        ],
        [
            "ext",
            xdr.lookup("StellarValueExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   const MASK_LEDGER_HEADER_FLAGS = 0x7;
    //
    // ===========================================================================
    xdr["const"]("MASK_LEDGER_HEADER_FLAGS", 0x7);
    // === xdr source ============================================================
    //
    //   enum LedgerHeaderFlags
    //   {
    //       DISABLE_LIQUIDITY_POOL_TRADING_FLAG = 0x1,
    //       DISABLE_LIQUIDITY_POOL_DEPOSIT_FLAG = 0x2,
    //       DISABLE_LIQUIDITY_POOL_WITHDRAWAL_FLAG = 0x4
    //   };
    //
    // ===========================================================================
    xdr["enum"]("LedgerHeaderFlags", {
        disableLiquidityPoolTradingFlag: 1,
        disableLiquidityPoolDepositFlag: 2,
        disableLiquidityPoolWithdrawalFlag: 4
    });
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("LedgerHeaderExtensionV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct LedgerHeaderExtensionV1
    //   {
    //       uint32 flags; // LedgerHeaderFlags
    //
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerHeaderExtensionV1", [
        [
            "flags",
            xdr.lookup("Uint32")
        ],
        [
            "ext",
            xdr.lookup("LedgerHeaderExtensionV1Ext")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           LedgerHeaderExtensionV1 v1;
    //       }
    //
    // ===========================================================================
    xdr.union("LedgerHeaderExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "v1"
            ]
        ],
        arms: {
            v1: xdr.lookup("LedgerHeaderExtensionV1")
        }
    });
    // === xdr source ============================================================
    //
    //   struct LedgerHeader
    //   {
    //       uint32 ledgerVersion;    // the protocol version of the ledger
    //       Hash previousLedgerHash; // hash of the previous ledger header
    //       StellarValue scpValue;   // what consensus agreed to
    //       Hash txSetResultHash;    // the TransactionResultSet that led to this ledger
    //       Hash bucketListHash;     // hash of the ledger state
    //
    //       uint32 ledgerSeq; // sequence number of this ledger
    //
    //       int64 totalCoins; // total number of stroops in existence.
    //                         // 10,000,000 stroops in 1 XLM
    //
    //       int64 feePool;       // fees burned since last inflation run
    //       uint32 inflationSeq; // inflation sequence number
    //
    //       uint64 idPool; // last used global ID, used for generating objects
    //
    //       uint32 baseFee;     // base fee per operation in stroops
    //       uint32 baseReserve; // account base reserve in stroops
    //
    //       uint32 maxTxSetSize; // maximum size a transaction set can be
    //
    //       Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back
    //                         // in time without walking the chain back ledger by ledger
    //                         // each slot contains the oldest ledger that is mod of
    //                         // either 50  5000  50000 or 500000 depending on index
    //                         // skipList[0] mod(50), skipList[1] mod(5000), etc
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           LedgerHeaderExtensionV1 v1;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerHeader", [
        [
            "ledgerVersion",
            xdr.lookup("Uint32")
        ],
        [
            "previousLedgerHash",
            xdr.lookup("Hash")
        ],
        [
            "scpValue",
            xdr.lookup("StellarValue")
        ],
        [
            "txSetResultHash",
            xdr.lookup("Hash")
        ],
        [
            "bucketListHash",
            xdr.lookup("Hash")
        ],
        [
            "ledgerSeq",
            xdr.lookup("Uint32")
        ],
        [
            "totalCoins",
            xdr.lookup("Int64")
        ],
        [
            "feePool",
            xdr.lookup("Int64")
        ],
        [
            "inflationSeq",
            xdr.lookup("Uint32")
        ],
        [
            "idPool",
            xdr.lookup("Uint64")
        ],
        [
            "baseFee",
            xdr.lookup("Uint32")
        ],
        [
            "baseReserve",
            xdr.lookup("Uint32")
        ],
        [
            "maxTxSetSize",
            xdr.lookup("Uint32")
        ],
        [
            "skipList",
            xdr.array(xdr.lookup("Hash"), 4)
        ],
        [
            "ext",
            xdr.lookup("LedgerHeaderExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum LedgerUpgradeType
    //   {
    //       LEDGER_UPGRADE_VERSION = 1,
    //       LEDGER_UPGRADE_BASE_FEE = 2,
    //       LEDGER_UPGRADE_MAX_TX_SET_SIZE = 3,
    //       LEDGER_UPGRADE_BASE_RESERVE = 4,
    //       LEDGER_UPGRADE_FLAGS = 5,
    //       LEDGER_UPGRADE_CONFIG = 6,
    //       LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE = 7
    //   };
    //
    // ===========================================================================
    xdr["enum"]("LedgerUpgradeType", {
        ledgerUpgradeVersion: 1,
        ledgerUpgradeBaseFee: 2,
        ledgerUpgradeMaxTxSetSize: 3,
        ledgerUpgradeBaseReserve: 4,
        ledgerUpgradeFlags: 5,
        ledgerUpgradeConfig: 6,
        ledgerUpgradeMaxSorobanTxSetSize: 7
    });
    // === xdr source ============================================================
    //
    //   struct ConfigUpgradeSetKey {
    //       Hash contractID;
    //       Hash contentHash;
    //   };
    //
    // ===========================================================================
    xdr.struct("ConfigUpgradeSetKey", [
        [
            "contractId",
            xdr.lookup("Hash")
        ],
        [
            "contentHash",
            xdr.lookup("Hash")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union LedgerUpgrade switch (LedgerUpgradeType type)
    //   {
    //   case LEDGER_UPGRADE_VERSION:
    //       uint32 newLedgerVersion; // update ledgerVersion
    //   case LEDGER_UPGRADE_BASE_FEE:
    //       uint32 newBaseFee; // update baseFee
    //   case LEDGER_UPGRADE_MAX_TX_SET_SIZE:
    //       uint32 newMaxTxSetSize; // update maxTxSetSize
    //   case LEDGER_UPGRADE_BASE_RESERVE:
    //       uint32 newBaseReserve; // update baseReserve
    //   case LEDGER_UPGRADE_FLAGS:
    //       uint32 newFlags; // update flags
    //   case LEDGER_UPGRADE_CONFIG:
    //       // Update arbitrary `ConfigSetting` entries identified by the key.
    //       ConfigUpgradeSetKey newConfig;
    //   case LEDGER_UPGRADE_MAX_SOROBAN_TX_SET_SIZE:
    //       // Update ConfigSettingContractExecutionLanesV0.ledgerMaxTxCount without
    //       // using `LEDGER_UPGRADE_CONFIG`.
    //       uint32 newMaxSorobanTxSetSize;
    //   };
    //
    // ===========================================================================
    xdr.union("LedgerUpgrade", {
        switchOn: xdr.lookup("LedgerUpgradeType"),
        switchName: "type",
        switches: [
            [
                "ledgerUpgradeVersion",
                "newLedgerVersion"
            ],
            [
                "ledgerUpgradeBaseFee",
                "newBaseFee"
            ],
            [
                "ledgerUpgradeMaxTxSetSize",
                "newMaxTxSetSize"
            ],
            [
                "ledgerUpgradeBaseReserve",
                "newBaseReserve"
            ],
            [
                "ledgerUpgradeFlags",
                "newFlags"
            ],
            [
                "ledgerUpgradeConfig",
                "newConfig"
            ],
            [
                "ledgerUpgradeMaxSorobanTxSetSize",
                "newMaxSorobanTxSetSize"
            ]
        ],
        arms: {
            newLedgerVersion: xdr.lookup("Uint32"),
            newBaseFee: xdr.lookup("Uint32"),
            newMaxTxSetSize: xdr.lookup("Uint32"),
            newBaseReserve: xdr.lookup("Uint32"),
            newFlags: xdr.lookup("Uint32"),
            newConfig: xdr.lookup("ConfigUpgradeSetKey"),
            newMaxSorobanTxSetSize: xdr.lookup("Uint32")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ConfigUpgradeSet {
    //       ConfigSettingEntry updatedEntry<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ConfigUpgradeSet", [
        [
            "updatedEntry",
            xdr.varArray(xdr.lookup("ConfigSettingEntry"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum TxSetComponentType
    //   {
    //     // txs with effective fee <= bid derived from a base fee (if any).
    //     // If base fee is not specified, no discount is applied.
    //     TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE = 0
    //   };
    //
    // ===========================================================================
    xdr["enum"]("TxSetComponentType", {
        txsetCompTxsMaybeDiscountedFee: 0
    });
    // === xdr source ============================================================
    //
    //   struct
    //     {
    //       int64* baseFee;
    //       TransactionEnvelope txs<>;
    //     }
    //
    // ===========================================================================
    xdr.struct("TxSetComponentTxsMaybeDiscountedFee", [
        [
            "baseFee",
            xdr.option(xdr.lookup("Int64"))
        ],
        [
            "txes",
            xdr.varArray(xdr.lookup("TransactionEnvelope"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union TxSetComponent switch (TxSetComponentType type)
    //   {
    //   case TXSET_COMP_TXS_MAYBE_DISCOUNTED_FEE:
    //     struct
    //     {
    //       int64* baseFee;
    //       TransactionEnvelope txs<>;
    //     } txsMaybeDiscountedFee;
    //   };
    //
    // ===========================================================================
    xdr.union("TxSetComponent", {
        switchOn: xdr.lookup("TxSetComponentType"),
        switchName: "type",
        switches: [
            [
                "txsetCompTxsMaybeDiscountedFee",
                "txsMaybeDiscountedFee"
            ]
        ],
        arms: {
            txsMaybeDiscountedFee: xdr.lookup("TxSetComponentTxsMaybeDiscountedFee")
        }
    });
    // === xdr source ============================================================
    //
    //   union TransactionPhase switch (int v)
    //   {
    //   case 0:
    //       TxSetComponent v0Components<>;
    //   };
    //
    // ===========================================================================
    xdr.union("TransactionPhase", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                "v0Components"
            ]
        ],
        arms: {
            v0Components: xdr.varArray(xdr.lookup("TxSetComponent"), 2147483647)
        }
    });
    // === xdr source ============================================================
    //
    //   struct TransactionSet
    //   {
    //       Hash previousLedgerHash;
    //       TransactionEnvelope txs<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionSet", [
        [
            "previousLedgerHash",
            xdr.lookup("Hash")
        ],
        [
            "txes",
            xdr.varArray(xdr.lookup("TransactionEnvelope"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TransactionSetV1
    //   {
    //       Hash previousLedgerHash;
    //       TransactionPhase phases<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionSetV1", [
        [
            "previousLedgerHash",
            xdr.lookup("Hash")
        ],
        [
            "phases",
            xdr.varArray(xdr.lookup("TransactionPhase"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union GeneralizedTransactionSet switch (int v)
    //   {
    //   // We consider the legacy TransactionSet to be v0.
    //   case 1:
    //       TransactionSetV1 v1TxSet;
    //   };
    //
    // ===========================================================================
    xdr.union("GeneralizedTransactionSet", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                1,
                "v1TxSet"
            ]
        ],
        arms: {
            v1TxSet: xdr.lookup("TransactionSetV1")
        }
    });
    // === xdr source ============================================================
    //
    //   struct TransactionResultPair
    //   {
    //       Hash transactionHash;
    //       TransactionResult result; // result for the transaction
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionResultPair", [
        [
            "transactionHash",
            xdr.lookup("Hash")
        ],
        [
            "result",
            xdr.lookup("TransactionResult")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TransactionResultSet
    //   {
    //       TransactionResultPair results<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionResultSet", [
        [
            "results",
            xdr.varArray(xdr.lookup("TransactionResultPair"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           GeneralizedTransactionSet generalizedTxSet;
    //       }
    //
    // ===========================================================================
    xdr.union("TransactionHistoryEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "generalizedTxSet"
            ]
        ],
        arms: {
            generalizedTxSet: xdr.lookup("GeneralizedTransactionSet")
        }
    });
    // === xdr source ============================================================
    //
    //   struct TransactionHistoryEntry
    //   {
    //       uint32 ledgerSeq;
    //       TransactionSet txSet;
    //
    //       // when v != 0, txSet must be empty
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           GeneralizedTransactionSet generalizedTxSet;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionHistoryEntry", [
        [
            "ledgerSeq",
            xdr.lookup("Uint32")
        ],
        [
            "txSet",
            xdr.lookup("TransactionSet")
        ],
        [
            "ext",
            xdr.lookup("TransactionHistoryEntryExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("TransactionHistoryResultEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct TransactionHistoryResultEntry
    //   {
    //       uint32 ledgerSeq;
    //       TransactionResultSet txResultSet;
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionHistoryResultEntry", [
        [
            "ledgerSeq",
            xdr.lookup("Uint32")
        ],
        [
            "txResultSet",
            xdr.lookup("TransactionResultSet")
        ],
        [
            "ext",
            xdr.lookup("TransactionHistoryResultEntryExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("LedgerHeaderHistoryEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct LedgerHeaderHistoryEntry
    //   {
    //       Hash hash;
    //       LedgerHeader header;
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerHeaderHistoryEntry", [
        [
            "hash",
            xdr.lookup("Hash")
        ],
        [
            "header",
            xdr.lookup("LedgerHeader")
        ],
        [
            "ext",
            xdr.lookup("LedgerHeaderHistoryEntryExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct LedgerSCPMessages
    //   {
    //       uint32 ledgerSeq;
    //       SCPEnvelope messages<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerScpMessages", [
        [
            "ledgerSeq",
            xdr.lookup("Uint32")
        ],
        [
            "messages",
            xdr.varArray(xdr.lookup("ScpEnvelope"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCPHistoryEntryV0
    //   {
    //       SCPQuorumSet quorumSets<>; // additional quorum sets used by ledgerMessages
    //       LedgerSCPMessages ledgerMessages;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScpHistoryEntryV0", [
        [
            "quorumSets",
            xdr.varArray(xdr.lookup("ScpQuorumSet"), 2147483647)
        ],
        [
            "ledgerMessages",
            xdr.lookup("LedgerScpMessages")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union SCPHistoryEntry switch (int v)
    //   {
    //   case 0:
    //       SCPHistoryEntryV0 v0;
    //   };
    //
    // ===========================================================================
    xdr.union("ScpHistoryEntry", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                "v0"
            ]
        ],
        arms: {
            v0: xdr.lookup("ScpHistoryEntryV0")
        }
    });
    // === xdr source ============================================================
    //
    //   enum LedgerEntryChangeType
    //   {
    //       LEDGER_ENTRY_CREATED = 0, // entry was added to the ledger
    //       LEDGER_ENTRY_UPDATED = 1, // entry was modified in the ledger
    //       LEDGER_ENTRY_REMOVED = 2, // entry was removed from the ledger
    //       LEDGER_ENTRY_STATE = 3    // value of the entry
    //   };
    //
    // ===========================================================================
    xdr["enum"]("LedgerEntryChangeType", {
        ledgerEntryCreated: 0,
        ledgerEntryUpdated: 1,
        ledgerEntryRemoved: 2,
        ledgerEntryState: 3
    });
    // === xdr source ============================================================
    //
    //   union LedgerEntryChange switch (LedgerEntryChangeType type)
    //   {
    //   case LEDGER_ENTRY_CREATED:
    //       LedgerEntry created;
    //   case LEDGER_ENTRY_UPDATED:
    //       LedgerEntry updated;
    //   case LEDGER_ENTRY_REMOVED:
    //       LedgerKey removed;
    //   case LEDGER_ENTRY_STATE:
    //       LedgerEntry state;
    //   };
    //
    // ===========================================================================
    xdr.union("LedgerEntryChange", {
        switchOn: xdr.lookup("LedgerEntryChangeType"),
        switchName: "type",
        switches: [
            [
                "ledgerEntryCreated",
                "created"
            ],
            [
                "ledgerEntryUpdated",
                "updated"
            ],
            [
                "ledgerEntryRemoved",
                "removed"
            ],
            [
                "ledgerEntryState",
                "state"
            ]
        ],
        arms: {
            created: xdr.lookup("LedgerEntry"),
            updated: xdr.lookup("LedgerEntry"),
            removed: xdr.lookup("LedgerKey"),
            state: xdr.lookup("LedgerEntry")
        }
    });
    // === xdr source ============================================================
    //
    //   typedef LedgerEntryChange LedgerEntryChanges<>;
    //
    // ===========================================================================
    xdr.typedef("LedgerEntryChanges", xdr.varArray(xdr.lookup("LedgerEntryChange"), 2147483647));
    // === xdr source ============================================================
    //
    //   struct OperationMeta
    //   {
    //       LedgerEntryChanges changes;
    //   };
    //
    // ===========================================================================
    xdr.struct("OperationMeta", [
        [
            "changes",
            xdr.lookup("LedgerEntryChanges")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TransactionMetaV1
    //   {
    //       LedgerEntryChanges txChanges; // tx level changes if any
    //       OperationMeta operations<>;   // meta for each operation
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionMetaV1", [
        [
            "txChanges",
            xdr.lookup("LedgerEntryChanges")
        ],
        [
            "operations",
            xdr.varArray(xdr.lookup("OperationMeta"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TransactionMetaV2
    //   {
    //       LedgerEntryChanges txChangesBefore; // tx level changes before operations
    //                                           // are applied if any
    //       OperationMeta operations<>;         // meta for each operation
    //       LedgerEntryChanges txChangesAfter;  // tx level changes after operations are
    //                                           // applied if any
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionMetaV2", [
        [
            "txChangesBefore",
            xdr.lookup("LedgerEntryChanges")
        ],
        [
            "operations",
            xdr.varArray(xdr.lookup("OperationMeta"), 2147483647)
        ],
        [
            "txChangesAfter",
            xdr.lookup("LedgerEntryChanges")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum ContractEventType
    //   {
    //       SYSTEM = 0,
    //       CONTRACT = 1,
    //       DIAGNOSTIC = 2
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ContractEventType", {
        system: 0,
        contract: 1,
        diagnostic: 2
    });
    // === xdr source ============================================================
    //
    //   struct
    //           {
    //               SCVal topics<>;
    //               SCVal data;
    //           }
    //
    // ===========================================================================
    xdr.struct("ContractEventV0", [
        [
            "topics",
            xdr.varArray(xdr.lookup("ScVal"), 2147483647)
        ],
        [
            "data",
            xdr.lookup("ScVal")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           struct
    //           {
    //               SCVal topics<>;
    //               SCVal data;
    //           } v0;
    //       }
    //
    // ===========================================================================
    xdr.union("ContractEventBody", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                "v0"
            ]
        ],
        arms: {
            v0: xdr.lookup("ContractEventV0")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ContractEvent
    //   {
    //       // We can use this to add more fields, or because it
    //       // is first, to change ContractEvent into a union.
    //       ExtensionPoint ext;
    //
    //       Hash* contractID;
    //       ContractEventType type;
    //
    //       union switch (int v)
    //       {
    //       case 0:
    //           struct
    //           {
    //               SCVal topics<>;
    //               SCVal data;
    //           } v0;
    //       }
    //       body;
    //   };
    //
    // ===========================================================================
    xdr.struct("ContractEvent", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "contractId",
            xdr.option(xdr.lookup("Hash"))
        ],
        [
            "type",
            xdr.lookup("ContractEventType")
        ],
        [
            "body",
            xdr.lookup("ContractEventBody")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct DiagnosticEvent
    //   {
    //       bool inSuccessfulContractCall;
    //       ContractEvent event;
    //   };
    //
    // ===========================================================================
    xdr.struct("DiagnosticEvent", [
        [
            "inSuccessfulContractCall",
            xdr.bool()
        ],
        [
            "event",
            xdr.lookup("ContractEvent")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   typedef DiagnosticEvent DiagnosticEvents<>;
    //
    // ===========================================================================
    xdr.typedef("DiagnosticEvents", xdr.varArray(xdr.lookup("DiagnosticEvent"), 2147483647));
    // === xdr source ============================================================
    //
    //   struct SorobanTransactionMetaExtV1
    //   {
    //       ExtensionPoint ext;
    //
    //       // The following are the components of the overall Soroban resource fee
    //       // charged for the transaction.
    //       // The following relation holds:
    //       // `resourceFeeCharged = totalNonRefundableResourceFeeCharged + totalRefundableResourceFeeCharged`
    //       // where `resourceFeeCharged` is the overall fee charged for the
    //       // transaction. Also, `resourceFeeCharged` <= `sorobanData.resourceFee`
    //       // i.e.we never charge more than the declared resource fee.
    //       // The inclusion fee for charged the Soroban transaction can be found using
    //       // the following equation:
    //       // `result.feeCharged = resourceFeeCharged + inclusionFeeCharged`.
    //
    //       // Total amount (in stroops) that has been charged for non-refundable
    //       // Soroban resources.
    //       // Non-refundable resources are charged based on the usage declared in
    //       // the transaction envelope (such as `instructions`, `readBytes` etc.) and
    //       // is charged regardless of the success of the transaction.
    //       int64 totalNonRefundableResourceFeeCharged;
    //       // Total amount (in stroops) that has been charged for refundable
    //       // Soroban resource fees.
    //       // Currently this comprises the rent fee (`rentFeeCharged`) and the
    //       // fee for the events and return value.
    //       // Refundable resources are charged based on the actual resources usage.
    //       // Since currently refundable resources are only used for the successful
    //       // transactions, this will be `0` for failed transactions.
    //       int64 totalRefundableResourceFeeCharged;
    //       // Amount (in stroops) that has been charged for rent.
    //       // This is a part of `totalNonRefundableResourceFeeCharged`.
    //       int64 rentFeeCharged;
    //   };
    //
    // ===========================================================================
    xdr.struct("SorobanTransactionMetaExtV1", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "totalNonRefundableResourceFeeCharged",
            xdr.lookup("Int64")
        ],
        [
            "totalRefundableResourceFeeCharged",
            xdr.lookup("Int64")
        ],
        [
            "rentFeeCharged",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union SorobanTransactionMetaExt switch (int v)
    //   {
    //   case 0:
    //       void;
    //   case 1:
    //       SorobanTransactionMetaExtV1 v1;
    //   };
    //
    // ===========================================================================
    xdr.union("SorobanTransactionMetaExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "v1"
            ]
        ],
        arms: {
            v1: xdr.lookup("SorobanTransactionMetaExtV1")
        }
    });
    // === xdr source ============================================================
    //
    //   struct SorobanTransactionMeta
    //   {
    //       SorobanTransactionMetaExt ext;
    //
    //       ContractEvent events<>;             // custom events populated by the
    //                                           // contracts themselves.
    //       SCVal returnValue;                  // return value of the host fn invocation
    //
    //       // Diagnostics events that are not hashed.
    //       // This will contain all contract and diagnostic events. Even ones
    //       // that were emitted in a failed contract call.
    //       DiagnosticEvent diagnosticEvents<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("SorobanTransactionMeta", [
        [
            "ext",
            xdr.lookup("SorobanTransactionMetaExt")
        ],
        [
            "events",
            xdr.varArray(xdr.lookup("ContractEvent"), 2147483647)
        ],
        [
            "returnValue",
            xdr.lookup("ScVal")
        ],
        [
            "diagnosticEvents",
            xdr.varArray(xdr.lookup("DiagnosticEvent"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TransactionMetaV3
    //   {
    //       ExtensionPoint ext;
    //
    //       LedgerEntryChanges txChangesBefore;  // tx level changes before operations
    //                                            // are applied if any
    //       OperationMeta operations<>;          // meta for each operation
    //       LedgerEntryChanges txChangesAfter;   // tx level changes after operations are
    //                                            // applied if any
    //       SorobanTransactionMeta* sorobanMeta; // Soroban-specific meta (only for
    //                                            // Soroban transactions).
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionMetaV3", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "txChangesBefore",
            xdr.lookup("LedgerEntryChanges")
        ],
        [
            "operations",
            xdr.varArray(xdr.lookup("OperationMeta"), 2147483647)
        ],
        [
            "txChangesAfter",
            xdr.lookup("LedgerEntryChanges")
        ],
        [
            "sorobanMeta",
            xdr.option(xdr.lookup("SorobanTransactionMeta"))
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct InvokeHostFunctionSuccessPreImage
    //   {
    //       SCVal returnValue;
    //       ContractEvent events<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("InvokeHostFunctionSuccessPreImage", [
        [
            "returnValue",
            xdr.lookup("ScVal")
        ],
        [
            "events",
            xdr.varArray(xdr.lookup("ContractEvent"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union TransactionMeta switch (int v)
    //   {
    //   case 0:
    //       OperationMeta operations<>;
    //   case 1:
    //       TransactionMetaV1 v1;
    //   case 2:
    //       TransactionMetaV2 v2;
    //   case 3:
    //       TransactionMetaV3 v3;
    //   };
    //
    // ===========================================================================
    xdr.union("TransactionMeta", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                "operations"
            ],
            [
                1,
                "v1"
            ],
            [
                2,
                "v2"
            ],
            [
                3,
                "v3"
            ]
        ],
        arms: {
            operations: xdr.varArray(xdr.lookup("OperationMeta"), 2147483647),
            v1: xdr.lookup("TransactionMetaV1"),
            v2: xdr.lookup("TransactionMetaV2"),
            v3: xdr.lookup("TransactionMetaV3")
        }
    });
    // === xdr source ============================================================
    //
    //   struct TransactionResultMeta
    //   {
    //       TransactionResultPair result;
    //       LedgerEntryChanges feeProcessing;
    //       TransactionMeta txApplyProcessing;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionResultMeta", [
        [
            "result",
            xdr.lookup("TransactionResultPair")
        ],
        [
            "feeProcessing",
            xdr.lookup("LedgerEntryChanges")
        ],
        [
            "txApplyProcessing",
            xdr.lookup("TransactionMeta")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct UpgradeEntryMeta
    //   {
    //       LedgerUpgrade upgrade;
    //       LedgerEntryChanges changes;
    //   };
    //
    // ===========================================================================
    xdr.struct("UpgradeEntryMeta", [
        [
            "upgrade",
            xdr.lookup("LedgerUpgrade")
        ],
        [
            "changes",
            xdr.lookup("LedgerEntryChanges")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct LedgerCloseMetaV0
    //   {
    //       LedgerHeaderHistoryEntry ledgerHeader;
    //       // NB: txSet is sorted in "Hash order"
    //       TransactionSet txSet;
    //
    //       // NB: transactions are sorted in apply order here
    //       // fees for all transactions are processed first
    //       // followed by applying transactions
    //       TransactionResultMeta txProcessing<>;
    //
    //       // upgrades are applied last
    //       UpgradeEntryMeta upgradesProcessing<>;
    //
    //       // other misc information attached to the ledger close
    //       SCPHistoryEntry scpInfo<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerCloseMetaV0", [
        [
            "ledgerHeader",
            xdr.lookup("LedgerHeaderHistoryEntry")
        ],
        [
            "txSet",
            xdr.lookup("TransactionSet")
        ],
        [
            "txProcessing",
            xdr.varArray(xdr.lookup("TransactionResultMeta"), 2147483647)
        ],
        [
            "upgradesProcessing",
            xdr.varArray(xdr.lookup("UpgradeEntryMeta"), 2147483647)
        ],
        [
            "scpInfo",
            xdr.varArray(xdr.lookup("ScpHistoryEntry"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct LedgerCloseMetaExtV1
    //   {
    //       ExtensionPoint ext;
    //       int64 sorobanFeeWrite1KB;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerCloseMetaExtV1", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "sorobanFeeWrite1Kb",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union LedgerCloseMetaExt switch (int v)
    //   {
    //   case 0:
    //       void;
    //   case 1:
    //       LedgerCloseMetaExtV1 v1;
    //   };
    //
    // ===========================================================================
    xdr.union("LedgerCloseMetaExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "v1"
            ]
        ],
        arms: {
            v1: xdr.lookup("LedgerCloseMetaExtV1")
        }
    });
    // === xdr source ============================================================
    //
    //   struct LedgerCloseMetaV1
    //   {
    //       LedgerCloseMetaExt ext;
    //
    //       LedgerHeaderHistoryEntry ledgerHeader;
    //
    //       GeneralizedTransactionSet txSet;
    //
    //       // NB: transactions are sorted in apply order here
    //       // fees for all transactions are processed first
    //       // followed by applying transactions
    //       TransactionResultMeta txProcessing<>;
    //
    //       // upgrades are applied last
    //       UpgradeEntryMeta upgradesProcessing<>;
    //
    //       // other misc information attached to the ledger close
    //       SCPHistoryEntry scpInfo<>;
    //
    //       // Size in bytes of BucketList, to support downstream
    //       // systems calculating storage fees correctly.
    //       uint64 totalByteSizeOfBucketList;
    //
    //       // Temp keys that are being evicted at this ledger.
    //       LedgerKey evictedTemporaryLedgerKeys<>;
    //
    //       // Archived restorable ledger entries that are being
    //       // evicted at this ledger.
    //       LedgerEntry evictedPersistentLedgerEntries<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerCloseMetaV1", [
        [
            "ext",
            xdr.lookup("LedgerCloseMetaExt")
        ],
        [
            "ledgerHeader",
            xdr.lookup("LedgerHeaderHistoryEntry")
        ],
        [
            "txSet",
            xdr.lookup("GeneralizedTransactionSet")
        ],
        [
            "txProcessing",
            xdr.varArray(xdr.lookup("TransactionResultMeta"), 2147483647)
        ],
        [
            "upgradesProcessing",
            xdr.varArray(xdr.lookup("UpgradeEntryMeta"), 2147483647)
        ],
        [
            "scpInfo",
            xdr.varArray(xdr.lookup("ScpHistoryEntry"), 2147483647)
        ],
        [
            "totalByteSizeOfBucketList",
            xdr.lookup("Uint64")
        ],
        [
            "evictedTemporaryLedgerKeys",
            xdr.varArray(xdr.lookup("LedgerKey"), 2147483647)
        ],
        [
            "evictedPersistentLedgerEntries",
            xdr.varArray(xdr.lookup("LedgerEntry"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union LedgerCloseMeta switch (int v)
    //   {
    //   case 0:
    //       LedgerCloseMetaV0 v0;
    //   case 1:
    //       LedgerCloseMetaV1 v1;
    //   };
    //
    // ===========================================================================
    xdr.union("LedgerCloseMeta", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                "v0"
            ],
            [
                1,
                "v1"
            ]
        ],
        arms: {
            v0: xdr.lookup("LedgerCloseMetaV0"),
            v1: xdr.lookup("LedgerCloseMetaV1")
        }
    });
    // === xdr source ============================================================
    //
    //   enum ErrorCode
    //   {
    //       ERR_MISC = 0, // Unspecific error
    //       ERR_DATA = 1, // Malformed data
    //       ERR_CONF = 2, // Misconfiguration error
    //       ERR_AUTH = 3, // Authentication failure
    //       ERR_LOAD = 4  // System overloaded
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ErrorCode", {
        errMisc: 0,
        errData: 1,
        errConf: 2,
        errAuth: 3,
        errLoad: 4
    });
    // === xdr source ============================================================
    //
    //   struct Error
    //   {
    //       ErrorCode code;
    //       string msg<100>;
    //   };
    //
    // ===========================================================================
    xdr.struct("Error", [
        [
            "code",
            xdr.lookup("ErrorCode")
        ],
        [
            "msg",
            xdr.string(100)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SendMore
    //   {
    //       uint32 numMessages;
    //   };
    //
    // ===========================================================================
    xdr.struct("SendMore", [
        [
            "numMessages",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SendMoreExtended
    //   {
    //       uint32 numMessages;
    //       uint32 numBytes;
    //   };
    //
    // ===========================================================================
    xdr.struct("SendMoreExtended", [
        [
            "numMessages",
            xdr.lookup("Uint32")
        ],
        [
            "numBytes",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct AuthCert
    //   {
    //       Curve25519Public pubkey;
    //       uint64 expiration;
    //       Signature sig;
    //   };
    //
    // ===========================================================================
    xdr.struct("AuthCert", [
        [
            "pubkey",
            xdr.lookup("Curve25519Public")
        ],
        [
            "expiration",
            xdr.lookup("Uint64")
        ],
        [
            "sig",
            xdr.lookup("Signature")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct Hello
    //   {
    //       uint32 ledgerVersion;
    //       uint32 overlayVersion;
    //       uint32 overlayMinVersion;
    //       Hash networkID;
    //       string versionStr<100>;
    //       int listeningPort;
    //       NodeID peerID;
    //       AuthCert cert;
    //       uint256 nonce;
    //   };
    //
    // ===========================================================================
    xdr.struct("Hello", [
        [
            "ledgerVersion",
            xdr.lookup("Uint32")
        ],
        [
            "overlayVersion",
            xdr.lookup("Uint32")
        ],
        [
            "overlayMinVersion",
            xdr.lookup("Uint32")
        ],
        [
            "networkId",
            xdr.lookup("Hash")
        ],
        [
            "versionStr",
            xdr.string(100)
        ],
        [
            "listeningPort",
            xdr["int"]()
        ],
        [
            "peerId",
            xdr.lookup("NodeId")
        ],
        [
            "cert",
            xdr.lookup("AuthCert")
        ],
        [
            "nonce",
            xdr.lookup("Uint256")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   const AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED = 200;
    //
    // ===========================================================================
    xdr["const"]("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED", 200);
    // === xdr source ============================================================
    //
    //   struct Auth
    //   {
    //       int flags;
    //   };
    //
    // ===========================================================================
    xdr.struct("Auth", [
        [
            "flags",
            xdr["int"]()
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum IPAddrType
    //   {
    //       IPv4 = 0,
    //       IPv6 = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("IpAddrType", {
        iPv4: 0,
        iPv6: 1
    });
    // === xdr source ============================================================
    //
    //   union switch (IPAddrType type)
    //       {
    //       case IPv4:
    //           opaque ipv4[4];
    //       case IPv6:
    //           opaque ipv6[16];
    //       }
    //
    // ===========================================================================
    xdr.union("PeerAddressIp", {
        switchOn: xdr.lookup("IpAddrType"),
        switchName: "type",
        switches: [
            [
                "iPv4",
                "ipv4"
            ],
            [
                "iPv6",
                "ipv6"
            ]
        ],
        arms: {
            ipv4: xdr.opaque(4),
            ipv6: xdr.opaque(16)
        }
    });
    // === xdr source ============================================================
    //
    //   struct PeerAddress
    //   {
    //       union switch (IPAddrType type)
    //       {
    //       case IPv4:
    //           opaque ipv4[4];
    //       case IPv6:
    //           opaque ipv6[16];
    //       }
    //       ip;
    //       uint32 port;
    //       uint32 numFailures;
    //   };
    //
    // ===========================================================================
    xdr.struct("PeerAddress", [
        [
            "ip",
            xdr.lookup("PeerAddressIp")
        ],
        [
            "port",
            xdr.lookup("Uint32")
        ],
        [
            "numFailures",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum MessageType
    //   {
    //       ERROR_MSG = 0,
    //       AUTH = 2,
    //       DONT_HAVE = 3,
    //
    //       GET_PEERS = 4, // gets a list of peers this guy knows about
    //       PEERS = 5,
    //
    //       GET_TX_SET = 6, // gets a particular txset by hash
    //       TX_SET = 7,
    //       GENERALIZED_TX_SET = 17,
    //
    //       TRANSACTION = 8, // pass on a tx you have heard about
    //
    //       // SCP
    //       GET_SCP_QUORUMSET = 9,
    //       SCP_QUORUMSET = 10,
    //       SCP_MESSAGE = 11,
    //       GET_SCP_STATE = 12,
    //
    //       // new messages
    //       HELLO = 13,
    //
    //       SURVEY_REQUEST = 14,
    //       SURVEY_RESPONSE = 15,
    //
    //       SEND_MORE = 16,
    //       SEND_MORE_EXTENDED = 20,
    //
    //       FLOOD_ADVERT = 18,
    //       FLOOD_DEMAND = 19,
    //
    //       TIME_SLICED_SURVEY_REQUEST = 21,
    //       TIME_SLICED_SURVEY_RESPONSE = 22,
    //       TIME_SLICED_SURVEY_START_COLLECTING = 23,
    //       TIME_SLICED_SURVEY_STOP_COLLECTING = 24
    //   };
    //
    // ===========================================================================
    xdr["enum"]("MessageType", {
        errorMsg: 0,
        auth: 2,
        dontHave: 3,
        getPeers: 4,
        peers: 5,
        getTxSet: 6,
        txSet: 7,
        generalizedTxSet: 17,
        transaction: 8,
        getScpQuorumset: 9,
        scpQuorumset: 10,
        scpMessage: 11,
        getScpState: 12,
        hello: 13,
        surveyRequest: 14,
        surveyResponse: 15,
        sendMore: 16,
        sendMoreExtended: 20,
        floodAdvert: 18,
        floodDemand: 19,
        timeSlicedSurveyRequest: 21,
        timeSlicedSurveyResponse: 22,
        timeSlicedSurveyStartCollecting: 23,
        timeSlicedSurveyStopCollecting: 24
    });
    // === xdr source ============================================================
    //
    //   struct DontHave
    //   {
    //       MessageType type;
    //       uint256 reqHash;
    //   };
    //
    // ===========================================================================
    xdr.struct("DontHave", [
        [
            "type",
            xdr.lookup("MessageType")
        ],
        [
            "reqHash",
            xdr.lookup("Uint256")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum SurveyMessageCommandType
    //   {
    //       SURVEY_TOPOLOGY = 0,
    //       TIME_SLICED_SURVEY_TOPOLOGY = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("SurveyMessageCommandType", {
        surveyTopology: 0,
        timeSlicedSurveyTopology: 1
    });
    // === xdr source ============================================================
    //
    //   enum SurveyMessageResponseType
    //   {
    //       SURVEY_TOPOLOGY_RESPONSE_V0 = 0,
    //       SURVEY_TOPOLOGY_RESPONSE_V1 = 1,
    //       SURVEY_TOPOLOGY_RESPONSE_V2 = 2
    //   };
    //
    // ===========================================================================
    xdr["enum"]("SurveyMessageResponseType", {
        surveyTopologyResponseV0: 0,
        surveyTopologyResponseV1: 1,
        surveyTopologyResponseV2: 2
    });
    // === xdr source ============================================================
    //
    //   struct TimeSlicedSurveyStartCollectingMessage
    //   {
    //       NodeID surveyorID;
    //       uint32 nonce;
    //       uint32 ledgerNum;
    //   };
    //
    // ===========================================================================
    xdr.struct("TimeSlicedSurveyStartCollectingMessage", [
        [
            "surveyorId",
            xdr.lookup("NodeId")
        ],
        [
            "nonce",
            xdr.lookup("Uint32")
        ],
        [
            "ledgerNum",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SignedTimeSlicedSurveyStartCollectingMessage
    //   {
    //       Signature signature;
    //       TimeSlicedSurveyStartCollectingMessage startCollecting;
    //   };
    //
    // ===========================================================================
    xdr.struct("SignedTimeSlicedSurveyStartCollectingMessage", [
        [
            "signature",
            xdr.lookup("Signature")
        ],
        [
            "startCollecting",
            xdr.lookup("TimeSlicedSurveyStartCollectingMessage")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TimeSlicedSurveyStopCollectingMessage
    //   {
    //       NodeID surveyorID;
    //       uint32 nonce;
    //       uint32 ledgerNum;
    //   };
    //
    // ===========================================================================
    xdr.struct("TimeSlicedSurveyStopCollectingMessage", [
        [
            "surveyorId",
            xdr.lookup("NodeId")
        ],
        [
            "nonce",
            xdr.lookup("Uint32")
        ],
        [
            "ledgerNum",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SignedTimeSlicedSurveyStopCollectingMessage
    //   {
    //       Signature signature;
    //       TimeSlicedSurveyStopCollectingMessage stopCollecting;
    //   };
    //
    // ===========================================================================
    xdr.struct("SignedTimeSlicedSurveyStopCollectingMessage", [
        [
            "signature",
            xdr.lookup("Signature")
        ],
        [
            "stopCollecting",
            xdr.lookup("TimeSlicedSurveyStopCollectingMessage")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SurveyRequestMessage
    //   {
    //       NodeID surveyorPeerID;
    //       NodeID surveyedPeerID;
    //       uint32 ledgerNum;
    //       Curve25519Public encryptionKey;
    //       SurveyMessageCommandType commandType;
    //   };
    //
    // ===========================================================================
    xdr.struct("SurveyRequestMessage", [
        [
            "surveyorPeerId",
            xdr.lookup("NodeId")
        ],
        [
            "surveyedPeerId",
            xdr.lookup("NodeId")
        ],
        [
            "ledgerNum",
            xdr.lookup("Uint32")
        ],
        [
            "encryptionKey",
            xdr.lookup("Curve25519Public")
        ],
        [
            "commandType",
            xdr.lookup("SurveyMessageCommandType")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TimeSlicedSurveyRequestMessage
    //   {
    //       SurveyRequestMessage request;
    //       uint32 nonce;
    //       uint32 inboundPeersIndex;
    //       uint32 outboundPeersIndex;
    //   };
    //
    // ===========================================================================
    xdr.struct("TimeSlicedSurveyRequestMessage", [
        [
            "request",
            xdr.lookup("SurveyRequestMessage")
        ],
        [
            "nonce",
            xdr.lookup("Uint32")
        ],
        [
            "inboundPeersIndex",
            xdr.lookup("Uint32")
        ],
        [
            "outboundPeersIndex",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SignedSurveyRequestMessage
    //   {
    //       Signature requestSignature;
    //       SurveyRequestMessage request;
    //   };
    //
    // ===========================================================================
    xdr.struct("SignedSurveyRequestMessage", [
        [
            "requestSignature",
            xdr.lookup("Signature")
        ],
        [
            "request",
            xdr.lookup("SurveyRequestMessage")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SignedTimeSlicedSurveyRequestMessage
    //   {
    //       Signature requestSignature;
    //       TimeSlicedSurveyRequestMessage request;
    //   };
    //
    // ===========================================================================
    xdr.struct("SignedTimeSlicedSurveyRequestMessage", [
        [
            "requestSignature",
            xdr.lookup("Signature")
        ],
        [
            "request",
            xdr.lookup("TimeSlicedSurveyRequestMessage")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   typedef opaque EncryptedBody<64000>;
    //
    // ===========================================================================
    xdr.typedef("EncryptedBody", xdr.varOpaque(64000));
    // === xdr source ============================================================
    //
    //   struct SurveyResponseMessage
    //   {
    //       NodeID surveyorPeerID;
    //       NodeID surveyedPeerID;
    //       uint32 ledgerNum;
    //       SurveyMessageCommandType commandType;
    //       EncryptedBody encryptedBody;
    //   };
    //
    // ===========================================================================
    xdr.struct("SurveyResponseMessage", [
        [
            "surveyorPeerId",
            xdr.lookup("NodeId")
        ],
        [
            "surveyedPeerId",
            xdr.lookup("NodeId")
        ],
        [
            "ledgerNum",
            xdr.lookup("Uint32")
        ],
        [
            "commandType",
            xdr.lookup("SurveyMessageCommandType")
        ],
        [
            "encryptedBody",
            xdr.lookup("EncryptedBody")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TimeSlicedSurveyResponseMessage
    //   {
    //       SurveyResponseMessage response;
    //       uint32 nonce;
    //   };
    //
    // ===========================================================================
    xdr.struct("TimeSlicedSurveyResponseMessage", [
        [
            "response",
            xdr.lookup("SurveyResponseMessage")
        ],
        [
            "nonce",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SignedSurveyResponseMessage
    //   {
    //       Signature responseSignature;
    //       SurveyResponseMessage response;
    //   };
    //
    // ===========================================================================
    xdr.struct("SignedSurveyResponseMessage", [
        [
            "responseSignature",
            xdr.lookup("Signature")
        ],
        [
            "response",
            xdr.lookup("SurveyResponseMessage")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SignedTimeSlicedSurveyResponseMessage
    //   {
    //       Signature responseSignature;
    //       TimeSlicedSurveyResponseMessage response;
    //   };
    //
    // ===========================================================================
    xdr.struct("SignedTimeSlicedSurveyResponseMessage", [
        [
            "responseSignature",
            xdr.lookup("Signature")
        ],
        [
            "response",
            xdr.lookup("TimeSlicedSurveyResponseMessage")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct PeerStats
    //   {
    //       NodeID id;
    //       string versionStr<100>;
    //       uint64 messagesRead;
    //       uint64 messagesWritten;
    //       uint64 bytesRead;
    //       uint64 bytesWritten;
    //       uint64 secondsConnected;
    //
    //       uint64 uniqueFloodBytesRecv;
    //       uint64 duplicateFloodBytesRecv;
    //       uint64 uniqueFetchBytesRecv;
    //       uint64 duplicateFetchBytesRecv;
    //
    //       uint64 uniqueFloodMessageRecv;
    //       uint64 duplicateFloodMessageRecv;
    //       uint64 uniqueFetchMessageRecv;
    //       uint64 duplicateFetchMessageRecv;
    //   };
    //
    // ===========================================================================
    xdr.struct("PeerStats", [
        [
            "id",
            xdr.lookup("NodeId")
        ],
        [
            "versionStr",
            xdr.string(100)
        ],
        [
            "messagesRead",
            xdr.lookup("Uint64")
        ],
        [
            "messagesWritten",
            xdr.lookup("Uint64")
        ],
        [
            "bytesRead",
            xdr.lookup("Uint64")
        ],
        [
            "bytesWritten",
            xdr.lookup("Uint64")
        ],
        [
            "secondsConnected",
            xdr.lookup("Uint64")
        ],
        [
            "uniqueFloodBytesRecv",
            xdr.lookup("Uint64")
        ],
        [
            "duplicateFloodBytesRecv",
            xdr.lookup("Uint64")
        ],
        [
            "uniqueFetchBytesRecv",
            xdr.lookup("Uint64")
        ],
        [
            "duplicateFetchBytesRecv",
            xdr.lookup("Uint64")
        ],
        [
            "uniqueFloodMessageRecv",
            xdr.lookup("Uint64")
        ],
        [
            "duplicateFloodMessageRecv",
            xdr.lookup("Uint64")
        ],
        [
            "uniqueFetchMessageRecv",
            xdr.lookup("Uint64")
        ],
        [
            "duplicateFetchMessageRecv",
            xdr.lookup("Uint64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   typedef PeerStats PeerStatList<25>;
    //
    // ===========================================================================
    xdr.typedef("PeerStatList", xdr.varArray(xdr.lookup("PeerStats"), 25));
    // === xdr source ============================================================
    //
    //   struct TimeSlicedNodeData
    //   {
    //       uint32 addedAuthenticatedPeers;
    //       uint32 droppedAuthenticatedPeers;
    //       uint32 totalInboundPeerCount;
    //       uint32 totalOutboundPeerCount;
    //
    //       // SCP stats
    //       uint32 p75SCPFirstToSelfLatencyMs;
    //       uint32 p75SCPSelfToOtherLatencyMs;
    //
    //       // How many times the node lost sync in the time slice
    //       uint32 lostSyncCount;
    //
    //       // Config data
    //       bool isValidator;
    //       uint32 maxInboundPeerCount;
    //       uint32 maxOutboundPeerCount;
    //   };
    //
    // ===========================================================================
    xdr.struct("TimeSlicedNodeData", [
        [
            "addedAuthenticatedPeers",
            xdr.lookup("Uint32")
        ],
        [
            "droppedAuthenticatedPeers",
            xdr.lookup("Uint32")
        ],
        [
            "totalInboundPeerCount",
            xdr.lookup("Uint32")
        ],
        [
            "totalOutboundPeerCount",
            xdr.lookup("Uint32")
        ],
        [
            "p75ScpFirstToSelfLatencyMs",
            xdr.lookup("Uint32")
        ],
        [
            "p75ScpSelfToOtherLatencyMs",
            xdr.lookup("Uint32")
        ],
        [
            "lostSyncCount",
            xdr.lookup("Uint32")
        ],
        [
            "isValidator",
            xdr.bool()
        ],
        [
            "maxInboundPeerCount",
            xdr.lookup("Uint32")
        ],
        [
            "maxOutboundPeerCount",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TimeSlicedPeerData
    //   {
    //       PeerStats peerStats;
    //       uint32 averageLatencyMs;
    //   };
    //
    // ===========================================================================
    xdr.struct("TimeSlicedPeerData", [
        [
            "peerStats",
            xdr.lookup("PeerStats")
        ],
        [
            "averageLatencyMs",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   typedef TimeSlicedPeerData TimeSlicedPeerDataList<25>;
    //
    // ===========================================================================
    xdr.typedef("TimeSlicedPeerDataList", xdr.varArray(xdr.lookup("TimeSlicedPeerData"), 25));
    // === xdr source ============================================================
    //
    //   struct TopologyResponseBodyV0
    //   {
    //       PeerStatList inboundPeers;
    //       PeerStatList outboundPeers;
    //
    //       uint32 totalInboundPeerCount;
    //       uint32 totalOutboundPeerCount;
    //   };
    //
    // ===========================================================================
    xdr.struct("TopologyResponseBodyV0", [
        [
            "inboundPeers",
            xdr.lookup("PeerStatList")
        ],
        [
            "outboundPeers",
            xdr.lookup("PeerStatList")
        ],
        [
            "totalInboundPeerCount",
            xdr.lookup("Uint32")
        ],
        [
            "totalOutboundPeerCount",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TopologyResponseBodyV1
    //   {
    //       PeerStatList inboundPeers;
    //       PeerStatList outboundPeers;
    //
    //       uint32 totalInboundPeerCount;
    //       uint32 totalOutboundPeerCount;
    //
    //       uint32 maxInboundPeerCount;
    //       uint32 maxOutboundPeerCount;
    //   };
    //
    // ===========================================================================
    xdr.struct("TopologyResponseBodyV1", [
        [
            "inboundPeers",
            xdr.lookup("PeerStatList")
        ],
        [
            "outboundPeers",
            xdr.lookup("PeerStatList")
        ],
        [
            "totalInboundPeerCount",
            xdr.lookup("Uint32")
        ],
        [
            "totalOutboundPeerCount",
            xdr.lookup("Uint32")
        ],
        [
            "maxInboundPeerCount",
            xdr.lookup("Uint32")
        ],
        [
            "maxOutboundPeerCount",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TopologyResponseBodyV2
    //   {
    //       TimeSlicedPeerDataList inboundPeers;
    //       TimeSlicedPeerDataList outboundPeers;
    //       TimeSlicedNodeData nodeData;
    //   };
    //
    // ===========================================================================
    xdr.struct("TopologyResponseBodyV2", [
        [
            "inboundPeers",
            xdr.lookup("TimeSlicedPeerDataList")
        ],
        [
            "outboundPeers",
            xdr.lookup("TimeSlicedPeerDataList")
        ],
        [
            "nodeData",
            xdr.lookup("TimeSlicedNodeData")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union SurveyResponseBody switch (SurveyMessageResponseType type)
    //   {
    //   case SURVEY_TOPOLOGY_RESPONSE_V0:
    //       TopologyResponseBodyV0 topologyResponseBodyV0;
    //   case SURVEY_TOPOLOGY_RESPONSE_V1:
    //       TopologyResponseBodyV1 topologyResponseBodyV1;
    //   case SURVEY_TOPOLOGY_RESPONSE_V2:
    //       TopologyResponseBodyV2 topologyResponseBodyV2;
    //   };
    //
    // ===========================================================================
    xdr.union("SurveyResponseBody", {
        switchOn: xdr.lookup("SurveyMessageResponseType"),
        switchName: "type",
        switches: [
            [
                "surveyTopologyResponseV0",
                "topologyResponseBodyV0"
            ],
            [
                "surveyTopologyResponseV1",
                "topologyResponseBodyV1"
            ],
            [
                "surveyTopologyResponseV2",
                "topologyResponseBodyV2"
            ]
        ],
        arms: {
            topologyResponseBodyV0: xdr.lookup("TopologyResponseBodyV0"),
            topologyResponseBodyV1: xdr.lookup("TopologyResponseBodyV1"),
            topologyResponseBodyV2: xdr.lookup("TopologyResponseBodyV2")
        }
    });
    // === xdr source ============================================================
    //
    //   const TX_ADVERT_VECTOR_MAX_SIZE = 1000;
    //
    // ===========================================================================
    xdr["const"]("TX_ADVERT_VECTOR_MAX_SIZE", 1000);
    // === xdr source ============================================================
    //
    //   typedef Hash TxAdvertVector<TX_ADVERT_VECTOR_MAX_SIZE>;
    //
    // ===========================================================================
    xdr.typedef("TxAdvertVector", xdr.varArray(xdr.lookup("Hash"), xdr.lookup("TX_ADVERT_VECTOR_MAX_SIZE")));
    // === xdr source ============================================================
    //
    //   struct FloodAdvert
    //   {
    //       TxAdvertVector txHashes;
    //   };
    //
    // ===========================================================================
    xdr.struct("FloodAdvert", [
        [
            "txHashes",
            xdr.lookup("TxAdvertVector")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   const TX_DEMAND_VECTOR_MAX_SIZE = 1000;
    //
    // ===========================================================================
    xdr["const"]("TX_DEMAND_VECTOR_MAX_SIZE", 1000);
    // === xdr source ============================================================
    //
    //   typedef Hash TxDemandVector<TX_DEMAND_VECTOR_MAX_SIZE>;
    //
    // ===========================================================================
    xdr.typedef("TxDemandVector", xdr.varArray(xdr.lookup("Hash"), xdr.lookup("TX_DEMAND_VECTOR_MAX_SIZE")));
    // === xdr source ============================================================
    //
    //   struct FloodDemand
    //   {
    //       TxDemandVector txHashes;
    //   };
    //
    // ===========================================================================
    xdr.struct("FloodDemand", [
        [
            "txHashes",
            xdr.lookup("TxDemandVector")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union StellarMessage switch (MessageType type)
    //   {
    //   case ERROR_MSG:
    //       Error error;
    //   case HELLO:
    //       Hello hello;
    //   case AUTH:
    //       Auth auth;
    //   case DONT_HAVE:
    //       DontHave dontHave;
    //   case GET_PEERS:
    //       void;
    //   case PEERS:
    //       PeerAddress peers<100>;
    //
    //   case GET_TX_SET:
    //       uint256 txSetHash;
    //   case TX_SET:
    //       TransactionSet txSet;
    //   case GENERALIZED_TX_SET:
    //       GeneralizedTransactionSet generalizedTxSet;
    //
    //   case TRANSACTION:
    //       TransactionEnvelope transaction;
    //
    //   case SURVEY_REQUEST:
    //       SignedSurveyRequestMessage signedSurveyRequestMessage;
    //
    //   case SURVEY_RESPONSE:
    //       SignedSurveyResponseMessage signedSurveyResponseMessage;
    //
    //   case TIME_SLICED_SURVEY_REQUEST:
    //       SignedTimeSlicedSurveyRequestMessage signedTimeSlicedSurveyRequestMessage;
    //
    //   case TIME_SLICED_SURVEY_RESPONSE:
    //       SignedTimeSlicedSurveyResponseMessage signedTimeSlicedSurveyResponseMessage;
    //
    //   case TIME_SLICED_SURVEY_START_COLLECTING:
    //       SignedTimeSlicedSurveyStartCollectingMessage
    //           signedTimeSlicedSurveyStartCollectingMessage;
    //
    //   case TIME_SLICED_SURVEY_STOP_COLLECTING:
    //       SignedTimeSlicedSurveyStopCollectingMessage
    //           signedTimeSlicedSurveyStopCollectingMessage;
    //
    //   // SCP
    //   case GET_SCP_QUORUMSET:
    //       uint256 qSetHash;
    //   case SCP_QUORUMSET:
    //       SCPQuorumSet qSet;
    //   case SCP_MESSAGE:
    //       SCPEnvelope envelope;
    //   case GET_SCP_STATE:
    //       uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
    //   case SEND_MORE:
    //       SendMore sendMoreMessage;
    //   case SEND_MORE_EXTENDED:
    //       SendMoreExtended sendMoreExtendedMessage;
    //   // Pull mode
    //   case FLOOD_ADVERT:
    //        FloodAdvert floodAdvert;
    //   case FLOOD_DEMAND:
    //        FloodDemand floodDemand;
    //   };
    //
    // ===========================================================================
    xdr.union("StellarMessage", {
        switchOn: xdr.lookup("MessageType"),
        switchName: "type",
        switches: [
            [
                "errorMsg",
                "error"
            ],
            [
                "hello",
                "hello"
            ],
            [
                "auth",
                "auth"
            ],
            [
                "dontHave",
                "dontHave"
            ],
            [
                "getPeers",
                xdr["void"]()
            ],
            [
                "peers",
                "peers"
            ],
            [
                "getTxSet",
                "txSetHash"
            ],
            [
                "txSet",
                "txSet"
            ],
            [
                "generalizedTxSet",
                "generalizedTxSet"
            ],
            [
                "transaction",
                "transaction"
            ],
            [
                "surveyRequest",
                "signedSurveyRequestMessage"
            ],
            [
                "surveyResponse",
                "signedSurveyResponseMessage"
            ],
            [
                "timeSlicedSurveyRequest",
                "signedTimeSlicedSurveyRequestMessage"
            ],
            [
                "timeSlicedSurveyResponse",
                "signedTimeSlicedSurveyResponseMessage"
            ],
            [
                "timeSlicedSurveyStartCollecting",
                "signedTimeSlicedSurveyStartCollectingMessage"
            ],
            [
                "timeSlicedSurveyStopCollecting",
                "signedTimeSlicedSurveyStopCollectingMessage"
            ],
            [
                "getScpQuorumset",
                "qSetHash"
            ],
            [
                "scpQuorumset",
                "qSet"
            ],
            [
                "scpMessage",
                "envelope"
            ],
            [
                "getScpState",
                "getScpLedgerSeq"
            ],
            [
                "sendMore",
                "sendMoreMessage"
            ],
            [
                "sendMoreExtended",
                "sendMoreExtendedMessage"
            ],
            [
                "floodAdvert",
                "floodAdvert"
            ],
            [
                "floodDemand",
                "floodDemand"
            ]
        ],
        arms: {
            error: xdr.lookup("Error"),
            hello: xdr.lookup("Hello"),
            auth: xdr.lookup("Auth"),
            dontHave: xdr.lookup("DontHave"),
            peers: xdr.varArray(xdr.lookup("PeerAddress"), 100),
            txSetHash: xdr.lookup("Uint256"),
            txSet: xdr.lookup("TransactionSet"),
            generalizedTxSet: xdr.lookup("GeneralizedTransactionSet"),
            transaction: xdr.lookup("TransactionEnvelope"),
            signedSurveyRequestMessage: xdr.lookup("SignedSurveyRequestMessage"),
            signedSurveyResponseMessage: xdr.lookup("SignedSurveyResponseMessage"),
            signedTimeSlicedSurveyRequestMessage: xdr.lookup("SignedTimeSlicedSurveyRequestMessage"),
            signedTimeSlicedSurveyResponseMessage: xdr.lookup("SignedTimeSlicedSurveyResponseMessage"),
            signedTimeSlicedSurveyStartCollectingMessage: xdr.lookup("SignedTimeSlicedSurveyStartCollectingMessage"),
            signedTimeSlicedSurveyStopCollectingMessage: xdr.lookup("SignedTimeSlicedSurveyStopCollectingMessage"),
            qSetHash: xdr.lookup("Uint256"),
            qSet: xdr.lookup("ScpQuorumSet"),
            envelope: xdr.lookup("ScpEnvelope"),
            getScpLedgerSeq: xdr.lookup("Uint32"),
            sendMoreMessage: xdr.lookup("SendMore"),
            sendMoreExtendedMessage: xdr.lookup("SendMoreExtended"),
            floodAdvert: xdr.lookup("FloodAdvert"),
            floodDemand: xdr.lookup("FloodDemand")
        }
    });
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           uint64 sequence;
    //           StellarMessage message;
    //           HmacSha256Mac mac;
    //       }
    //
    // ===========================================================================
    xdr.struct("AuthenticatedMessageV0", [
        [
            "sequence",
            xdr.lookup("Uint64")
        ],
        [
            "message",
            xdr.lookup("StellarMessage")
        ],
        [
            "mac",
            xdr.lookup("HmacSha256Mac")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union AuthenticatedMessage switch (uint32 v)
    //   {
    //   case 0:
    //       struct
    //       {
    //           uint64 sequence;
    //           StellarMessage message;
    //           HmacSha256Mac mac;
    //       } v0;
    //   };
    //
    // ===========================================================================
    xdr.union("AuthenticatedMessage", {
        switchOn: xdr.lookup("Uint32"),
        switchName: "v",
        switches: [
            [
                0,
                "v0"
            ]
        ],
        arms: {
            v0: xdr.lookup("AuthenticatedMessageV0")
        }
    });
    // === xdr source ============================================================
    //
    //   const MAX_OPS_PER_TX = 100;
    //
    // ===========================================================================
    xdr["const"]("MAX_OPS_PER_TX", 100);
    // === xdr source ============================================================
    //
    //   union LiquidityPoolParameters switch (LiquidityPoolType type)
    //   {
    //   case LIQUIDITY_POOL_CONSTANT_PRODUCT:
    //       LiquidityPoolConstantProductParameters constantProduct;
    //   };
    //
    // ===========================================================================
    xdr.union("LiquidityPoolParameters", {
        switchOn: xdr.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [
            [
                "liquidityPoolConstantProduct",
                "constantProduct"
            ]
        ],
        arms: {
            constantProduct: xdr.lookup("LiquidityPoolConstantProductParameters")
        }
    });
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           uint64 id;
    //           uint256 ed25519;
    //       }
    //
    // ===========================================================================
    xdr.struct("MuxedAccountMed25519", [
        [
            "id",
            xdr.lookup("Uint64")
        ],
        [
            "ed25519",
            xdr.lookup("Uint256")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union MuxedAccount switch (CryptoKeyType type)
    //   {
    //   case KEY_TYPE_ED25519:
    //       uint256 ed25519;
    //   case KEY_TYPE_MUXED_ED25519:
    //       struct
    //       {
    //           uint64 id;
    //           uint256 ed25519;
    //       } med25519;
    //   };
    //
    // ===========================================================================
    xdr.union("MuxedAccount", {
        switchOn: xdr.lookup("CryptoKeyType"),
        switchName: "type",
        switches: [
            [
                "keyTypeEd25519",
                "ed25519"
            ],
            [
                "keyTypeMuxedEd25519",
                "med25519"
            ]
        ],
        arms: {
            ed25519: xdr.lookup("Uint256"),
            med25519: xdr.lookup("MuxedAccountMed25519")
        }
    });
    // === xdr source ============================================================
    //
    //   struct DecoratedSignature
    //   {
    //       SignatureHint hint;  // last 4 bytes of the public key, used as a hint
    //       Signature signature; // actual signature
    //   };
    //
    // ===========================================================================
    xdr.struct("DecoratedSignature", [
        [
            "hint",
            xdr.lookup("SignatureHint")
        ],
        [
            "signature",
            xdr.lookup("Signature")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum OperationType
    //   {
    //       CREATE_ACCOUNT = 0,
    //       PAYMENT = 1,
    //       PATH_PAYMENT_STRICT_RECEIVE = 2,
    //       MANAGE_SELL_OFFER = 3,
    //       CREATE_PASSIVE_SELL_OFFER = 4,
    //       SET_OPTIONS = 5,
    //       CHANGE_TRUST = 6,
    //       ALLOW_TRUST = 7,
    //       ACCOUNT_MERGE = 8,
    //       INFLATION = 9,
    //       MANAGE_DATA = 10,
    //       BUMP_SEQUENCE = 11,
    //       MANAGE_BUY_OFFER = 12,
    //       PATH_PAYMENT_STRICT_SEND = 13,
    //       CREATE_CLAIMABLE_BALANCE = 14,
    //       CLAIM_CLAIMABLE_BALANCE = 15,
    //       BEGIN_SPONSORING_FUTURE_RESERVES = 16,
    //       END_SPONSORING_FUTURE_RESERVES = 17,
    //       REVOKE_SPONSORSHIP = 18,
    //       CLAWBACK = 19,
    //       CLAWBACK_CLAIMABLE_BALANCE = 20,
    //       SET_TRUST_LINE_FLAGS = 21,
    //       LIQUIDITY_POOL_DEPOSIT = 22,
    //       LIQUIDITY_POOL_WITHDRAW = 23,
    //       INVOKE_HOST_FUNCTION = 24,
    //       EXTEND_FOOTPRINT_TTL = 25,
    //       RESTORE_FOOTPRINT = 26
    //   };
    //
    // ===========================================================================
    xdr["enum"]("OperationType", {
        createAccount: 0,
        payment: 1,
        pathPaymentStrictReceive: 2,
        manageSellOffer: 3,
        createPassiveSellOffer: 4,
        setOptions: 5,
        changeTrust: 6,
        allowTrust: 7,
        accountMerge: 8,
        inflation: 9,
        manageData: 10,
        bumpSequence: 11,
        manageBuyOffer: 12,
        pathPaymentStrictSend: 13,
        createClaimableBalance: 14,
        claimClaimableBalance: 15,
        beginSponsoringFutureReserves: 16,
        endSponsoringFutureReserves: 17,
        revokeSponsorship: 18,
        clawback: 19,
        clawbackClaimableBalance: 20,
        setTrustLineFlags: 21,
        liquidityPoolDeposit: 22,
        liquidityPoolWithdraw: 23,
        invokeHostFunction: 24,
        extendFootprintTtl: 25,
        restoreFootprint: 26
    });
    // === xdr source ============================================================
    //
    //   struct CreateAccountOp
    //   {
    //       AccountID destination; // account to create
    //       int64 startingBalance; // amount they end up with
    //   };
    //
    // ===========================================================================
    xdr.struct("CreateAccountOp", [
        [
            "destination",
            xdr.lookup("AccountId")
        ],
        [
            "startingBalance",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct PaymentOp
    //   {
    //       MuxedAccount destination; // recipient of the payment
    //       Asset asset;              // what they end up with
    //       int64 amount;             // amount they end up with
    //   };
    //
    // ===========================================================================
    xdr.struct("PaymentOp", [
        [
            "destination",
            xdr.lookup("MuxedAccount")
        ],
        [
            "asset",
            xdr.lookup("Asset")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct PathPaymentStrictReceiveOp
    //   {
    //       Asset sendAsset; // asset we pay with
    //       int64 sendMax;   // the maximum amount of sendAsset to
    //                        // send (excluding fees).
    //                        // The operation will fail if can't be met
    //
    //       MuxedAccount destination; // recipient of the payment
    //       Asset destAsset;          // what they end up with
    //       int64 destAmount;         // amount they end up with
    //
    //       Asset path<5>; // additional hops it must go through to get there
    //   };
    //
    // ===========================================================================
    xdr.struct("PathPaymentStrictReceiveOp", [
        [
            "sendAsset",
            xdr.lookup("Asset")
        ],
        [
            "sendMax",
            xdr.lookup("Int64")
        ],
        [
            "destination",
            xdr.lookup("MuxedAccount")
        ],
        [
            "destAsset",
            xdr.lookup("Asset")
        ],
        [
            "destAmount",
            xdr.lookup("Int64")
        ],
        [
            "path",
            xdr.varArray(xdr.lookup("Asset"), 5)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct PathPaymentStrictSendOp
    //   {
    //       Asset sendAsset;  // asset we pay with
    //       int64 sendAmount; // amount of sendAsset to send (excluding fees)
    //
    //       MuxedAccount destination; // recipient of the payment
    //       Asset destAsset;          // what they end up with
    //       int64 destMin;            // the minimum amount of dest asset to
    //                                 // be received
    //                                 // The operation will fail if it can't be met
    //
    //       Asset path<5>; // additional hops it must go through to get there
    //   };
    //
    // ===========================================================================
    xdr.struct("PathPaymentStrictSendOp", [
        [
            "sendAsset",
            xdr.lookup("Asset")
        ],
        [
            "sendAmount",
            xdr.lookup("Int64")
        ],
        [
            "destination",
            xdr.lookup("MuxedAccount")
        ],
        [
            "destAsset",
            xdr.lookup("Asset")
        ],
        [
            "destMin",
            xdr.lookup("Int64")
        ],
        [
            "path",
            xdr.varArray(xdr.lookup("Asset"), 5)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ManageSellOfferOp
    //   {
    //       Asset selling;
    //       Asset buying;
    //       int64 amount; // amount being sold. if set to 0, delete the offer
    //       Price price;  // price of thing being sold in terms of what you are buying
    //
    //       // 0=create a new offer, otherwise edit an existing offer
    //       int64 offerID;
    //   };
    //
    // ===========================================================================
    xdr.struct("ManageSellOfferOp", [
        [
            "selling",
            xdr.lookup("Asset")
        ],
        [
            "buying",
            xdr.lookup("Asset")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ],
        [
            "price",
            xdr.lookup("Price")
        ],
        [
            "offerId",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ManageBuyOfferOp
    //   {
    //       Asset selling;
    //       Asset buying;
    //       int64 buyAmount; // amount being bought. if set to 0, delete the offer
    //       Price price;     // price of thing being bought in terms of what you are
    //                        // selling
    //
    //       // 0=create a new offer, otherwise edit an existing offer
    //       int64 offerID;
    //   };
    //
    // ===========================================================================
    xdr.struct("ManageBuyOfferOp", [
        [
            "selling",
            xdr.lookup("Asset")
        ],
        [
            "buying",
            xdr.lookup("Asset")
        ],
        [
            "buyAmount",
            xdr.lookup("Int64")
        ],
        [
            "price",
            xdr.lookup("Price")
        ],
        [
            "offerId",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct CreatePassiveSellOfferOp
    //   {
    //       Asset selling; // A
    //       Asset buying;  // B
    //       int64 amount;  // amount taker gets
    //       Price price;   // cost of A in terms of B
    //   };
    //
    // ===========================================================================
    xdr.struct("CreatePassiveSellOfferOp", [
        [
            "selling",
            xdr.lookup("Asset")
        ],
        [
            "buying",
            xdr.lookup("Asset")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ],
        [
            "price",
            xdr.lookup("Price")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SetOptionsOp
    //   {
    //       AccountID* inflationDest; // sets the inflation destination
    //
    //       uint32* clearFlags; // which flags to clear
    //       uint32* setFlags;   // which flags to set
    //
    //       // account threshold manipulation
    //       uint32* masterWeight; // weight of the master account
    //       uint32* lowThreshold;
    //       uint32* medThreshold;
    //       uint32* highThreshold;
    //
    //       string32* homeDomain; // sets the home domain
    //
    //       // Add, update or remove a signer for the account
    //       // signer is deleted if the weight is 0
    //       Signer* signer;
    //   };
    //
    // ===========================================================================
    xdr.struct("SetOptionsOp", [
        [
            "inflationDest",
            xdr.option(xdr.lookup("AccountId"))
        ],
        [
            "clearFlags",
            xdr.option(xdr.lookup("Uint32"))
        ],
        [
            "setFlags",
            xdr.option(xdr.lookup("Uint32"))
        ],
        [
            "masterWeight",
            xdr.option(xdr.lookup("Uint32"))
        ],
        [
            "lowThreshold",
            xdr.option(xdr.lookup("Uint32"))
        ],
        [
            "medThreshold",
            xdr.option(xdr.lookup("Uint32"))
        ],
        [
            "highThreshold",
            xdr.option(xdr.lookup("Uint32"))
        ],
        [
            "homeDomain",
            xdr.option(xdr.lookup("String32"))
        ],
        [
            "signer",
            xdr.option(xdr.lookup("Signer"))
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union ChangeTrustAsset switch (AssetType type)
    //   {
    //   case ASSET_TYPE_NATIVE: // Not credit
    //       void;
    //
    //   case ASSET_TYPE_CREDIT_ALPHANUM4:
    //       AlphaNum4 alphaNum4;
    //
    //   case ASSET_TYPE_CREDIT_ALPHANUM12:
    //       AlphaNum12 alphaNum12;
    //
    //   case ASSET_TYPE_POOL_SHARE:
    //       LiquidityPoolParameters liquidityPool;
    //
    //       // add other asset types here in the future
    //   };
    //
    // ===========================================================================
    xdr.union("ChangeTrustAsset", {
        switchOn: xdr.lookup("AssetType"),
        switchName: "type",
        switches: [
            [
                "assetTypeNative",
                xdr["void"]()
            ],
            [
                "assetTypeCreditAlphanum4",
                "alphaNum4"
            ],
            [
                "assetTypeCreditAlphanum12",
                "alphaNum12"
            ],
            [
                "assetTypePoolShare",
                "liquidityPool"
            ]
        ],
        arms: {
            alphaNum4: xdr.lookup("AlphaNum4"),
            alphaNum12: xdr.lookup("AlphaNum12"),
            liquidityPool: xdr.lookup("LiquidityPoolParameters")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ChangeTrustOp
    //   {
    //       ChangeTrustAsset line;
    //
    //       // if limit is set to 0, deletes the trust line
    //       int64 limit;
    //   };
    //
    // ===========================================================================
    xdr.struct("ChangeTrustOp", [
        [
            "line",
            xdr.lookup("ChangeTrustAsset")
        ],
        [
            "limit",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct AllowTrustOp
    //   {
    //       AccountID trustor;
    //       AssetCode asset;
    //
    //       // One of 0, AUTHORIZED_FLAG, or AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG
    //       uint32 authorize;
    //   };
    //
    // ===========================================================================
    xdr.struct("AllowTrustOp", [
        [
            "trustor",
            xdr.lookup("AccountId")
        ],
        [
            "asset",
            xdr.lookup("AssetCode")
        ],
        [
            "authorize",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ManageDataOp
    //   {
    //       string64 dataName;
    //       DataValue* dataValue; // set to null to clear
    //   };
    //
    // ===========================================================================
    xdr.struct("ManageDataOp", [
        [
            "dataName",
            xdr.lookup("String64")
        ],
        [
            "dataValue",
            xdr.option(xdr.lookup("DataValue"))
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct BumpSequenceOp
    //   {
    //       SequenceNumber bumpTo;
    //   };
    //
    // ===========================================================================
    xdr.struct("BumpSequenceOp", [
        [
            "bumpTo",
            xdr.lookup("SequenceNumber")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct CreateClaimableBalanceOp
    //   {
    //       Asset asset;
    //       int64 amount;
    //       Claimant claimants<10>;
    //   };
    //
    // ===========================================================================
    xdr.struct("CreateClaimableBalanceOp", [
        [
            "asset",
            xdr.lookup("Asset")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ],
        [
            "claimants",
            xdr.varArray(xdr.lookup("Claimant"), 10)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ClaimClaimableBalanceOp
    //   {
    //       ClaimableBalanceID balanceID;
    //   };
    //
    // ===========================================================================
    xdr.struct("ClaimClaimableBalanceOp", [
        [
            "balanceId",
            xdr.lookup("ClaimableBalanceId")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct BeginSponsoringFutureReservesOp
    //   {
    //       AccountID sponsoredID;
    //   };
    //
    // ===========================================================================
    xdr.struct("BeginSponsoringFutureReservesOp", [
        [
            "sponsoredId",
            xdr.lookup("AccountId")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum RevokeSponsorshipType
    //   {
    //       REVOKE_SPONSORSHIP_LEDGER_ENTRY = 0,
    //       REVOKE_SPONSORSHIP_SIGNER = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("RevokeSponsorshipType", {
        revokeSponsorshipLedgerEntry: 0,
        revokeSponsorshipSigner: 1
    });
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           AccountID accountID;
    //           SignerKey signerKey;
    //       }
    //
    // ===========================================================================
    xdr.struct("RevokeSponsorshipOpSigner", [
        [
            "accountId",
            xdr.lookup("AccountId")
        ],
        [
            "signerKey",
            xdr.lookup("SignerKey")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union RevokeSponsorshipOp switch (RevokeSponsorshipType type)
    //   {
    //   case REVOKE_SPONSORSHIP_LEDGER_ENTRY:
    //       LedgerKey ledgerKey;
    //   case REVOKE_SPONSORSHIP_SIGNER:
    //       struct
    //       {
    //           AccountID accountID;
    //           SignerKey signerKey;
    //       } signer;
    //   };
    //
    // ===========================================================================
    xdr.union("RevokeSponsorshipOp", {
        switchOn: xdr.lookup("RevokeSponsorshipType"),
        switchName: "type",
        switches: [
            [
                "revokeSponsorshipLedgerEntry",
                "ledgerKey"
            ],
            [
                "revokeSponsorshipSigner",
                "signer"
            ]
        ],
        arms: {
            ledgerKey: xdr.lookup("LedgerKey"),
            signer: xdr.lookup("RevokeSponsorshipOpSigner")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ClawbackOp
    //   {
    //       Asset asset;
    //       MuxedAccount from;
    //       int64 amount;
    //   };
    //
    // ===========================================================================
    xdr.struct("ClawbackOp", [
        [
            "asset",
            xdr.lookup("Asset")
        ],
        [
            "from",
            xdr.lookup("MuxedAccount")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ClawbackClaimableBalanceOp
    //   {
    //       ClaimableBalanceID balanceID;
    //   };
    //
    // ===========================================================================
    xdr.struct("ClawbackClaimableBalanceOp", [
        [
            "balanceId",
            xdr.lookup("ClaimableBalanceId")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SetTrustLineFlagsOp
    //   {
    //       AccountID trustor;
    //       Asset asset;
    //
    //       uint32 clearFlags; // which flags to clear
    //       uint32 setFlags;   // which flags to set
    //   };
    //
    // ===========================================================================
    xdr.struct("SetTrustLineFlagsOp", [
        [
            "trustor",
            xdr.lookup("AccountId")
        ],
        [
            "asset",
            xdr.lookup("Asset")
        ],
        [
            "clearFlags",
            xdr.lookup("Uint32")
        ],
        [
            "setFlags",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   const LIQUIDITY_POOL_FEE_V18 = 30;
    //
    // ===========================================================================
    xdr["const"]("LIQUIDITY_POOL_FEE_V18", 30);
    // === xdr source ============================================================
    //
    //   struct LiquidityPoolDepositOp
    //   {
    //       PoolID liquidityPoolID;
    //       int64 maxAmountA; // maximum amount of first asset to deposit
    //       int64 maxAmountB; // maximum amount of second asset to deposit
    //       Price minPrice;   // minimum depositA/depositB
    //       Price maxPrice;   // maximum depositA/depositB
    //   };
    //
    // ===========================================================================
    xdr.struct("LiquidityPoolDepositOp", [
        [
            "liquidityPoolId",
            xdr.lookup("PoolId")
        ],
        [
            "maxAmountA",
            xdr.lookup("Int64")
        ],
        [
            "maxAmountB",
            xdr.lookup("Int64")
        ],
        [
            "minPrice",
            xdr.lookup("Price")
        ],
        [
            "maxPrice",
            xdr.lookup("Price")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct LiquidityPoolWithdrawOp
    //   {
    //       PoolID liquidityPoolID;
    //       int64 amount;     // amount of pool shares to withdraw
    //       int64 minAmountA; // minimum amount of first asset to withdraw
    //       int64 minAmountB; // minimum amount of second asset to withdraw
    //   };
    //
    // ===========================================================================
    xdr.struct("LiquidityPoolWithdrawOp", [
        [
            "liquidityPoolId",
            xdr.lookup("PoolId")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ],
        [
            "minAmountA",
            xdr.lookup("Int64")
        ],
        [
            "minAmountB",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum HostFunctionType
    //   {
    //       HOST_FUNCTION_TYPE_INVOKE_CONTRACT = 0,
    //       HOST_FUNCTION_TYPE_CREATE_CONTRACT = 1,
    //       HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM = 2,
    //       HOST_FUNCTION_TYPE_CREATE_CONTRACT_V2 = 3
    //   };
    //
    // ===========================================================================
    xdr["enum"]("HostFunctionType", {
        hostFunctionTypeInvokeContract: 0,
        hostFunctionTypeCreateContract: 1,
        hostFunctionTypeUploadContractWasm: 2,
        hostFunctionTypeCreateContractV2: 3
    });
    // === xdr source ============================================================
    //
    //   enum ContractIDPreimageType
    //   {
    //       CONTRACT_ID_PREIMAGE_FROM_ADDRESS = 0,
    //       CONTRACT_ID_PREIMAGE_FROM_ASSET = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ContractIdPreimageType", {
        contractIdPreimageFromAddress: 0,
        contractIdPreimageFromAsset: 1
    });
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           SCAddress address;
    //           uint256 salt;
    //       }
    //
    // ===========================================================================
    xdr.struct("ContractIdPreimageFromAddress", [
        [
            "address",
            xdr.lookup("ScAddress")
        ],
        [
            "salt",
            xdr.lookup("Uint256")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union ContractIDPreimage switch (ContractIDPreimageType type)
    //   {
    //   case CONTRACT_ID_PREIMAGE_FROM_ADDRESS:
    //       struct
    //       {
    //           SCAddress address;
    //           uint256 salt;
    //       } fromAddress;
    //   case CONTRACT_ID_PREIMAGE_FROM_ASSET:
    //       Asset fromAsset;
    //   };
    //
    // ===========================================================================
    xdr.union("ContractIdPreimage", {
        switchOn: xdr.lookup("ContractIdPreimageType"),
        switchName: "type",
        switches: [
            [
                "contractIdPreimageFromAddress",
                "fromAddress"
            ],
            [
                "contractIdPreimageFromAsset",
                "fromAsset"
            ]
        ],
        arms: {
            fromAddress: xdr.lookup("ContractIdPreimageFromAddress"),
            fromAsset: xdr.lookup("Asset")
        }
    });
    // === xdr source ============================================================
    //
    //   struct CreateContractArgs
    //   {
    //       ContractIDPreimage contractIDPreimage;
    //       ContractExecutable executable;
    //   };
    //
    // ===========================================================================
    xdr.struct("CreateContractArgs", [
        [
            "contractIdPreimage",
            xdr.lookup("ContractIdPreimage")
        ],
        [
            "executable",
            xdr.lookup("ContractExecutable")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct CreateContractArgsV2
    //   {
    //       ContractIDPreimage contractIDPreimage;
    //       ContractExecutable executable;
    //       // Arguments of the contract's constructor.
    //       SCVal constructorArgs<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("CreateContractArgsV2", [
        [
            "contractIdPreimage",
            xdr.lookup("ContractIdPreimage")
        ],
        [
            "executable",
            xdr.lookup("ContractExecutable")
        ],
        [
            "constructorArgs",
            xdr.varArray(xdr.lookup("ScVal"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct InvokeContractArgs {
    //       SCAddress contractAddress;
    //       SCSymbol functionName;
    //       SCVal args<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("InvokeContractArgs", [
        [
            "contractAddress",
            xdr.lookup("ScAddress")
        ],
        [
            "functionName",
            xdr.lookup("ScSymbol")
        ],
        [
            "args",
            xdr.varArray(xdr.lookup("ScVal"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union HostFunction switch (HostFunctionType type)
    //   {
    //   case HOST_FUNCTION_TYPE_INVOKE_CONTRACT:
    //       InvokeContractArgs invokeContract;
    //   case HOST_FUNCTION_TYPE_CREATE_CONTRACT:
    //       CreateContractArgs createContract;
    //   case HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM:
    //       opaque wasm<>;
    //   case HOST_FUNCTION_TYPE_CREATE_CONTRACT_V2:
    //       CreateContractArgsV2 createContractV2;
    //   };
    //
    // ===========================================================================
    xdr.union("HostFunction", {
        switchOn: xdr.lookup("HostFunctionType"),
        switchName: "type",
        switches: [
            [
                "hostFunctionTypeInvokeContract",
                "invokeContract"
            ],
            [
                "hostFunctionTypeCreateContract",
                "createContract"
            ],
            [
                "hostFunctionTypeUploadContractWasm",
                "wasm"
            ],
            [
                "hostFunctionTypeCreateContractV2",
                "createContractV2"
            ]
        ],
        arms: {
            invokeContract: xdr.lookup("InvokeContractArgs"),
            createContract: xdr.lookup("CreateContractArgs"),
            wasm: xdr.varOpaque(),
            createContractV2: xdr.lookup("CreateContractArgsV2")
        }
    });
    // === xdr source ============================================================
    //
    //   enum SorobanAuthorizedFunctionType
    //   {
    //       SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN = 0,
    //       SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN = 1,
    //       SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_V2_HOST_FN = 2
    //   };
    //
    // ===========================================================================
    xdr["enum"]("SorobanAuthorizedFunctionType", {
        sorobanAuthorizedFunctionTypeContractFn: 0,
        sorobanAuthorizedFunctionTypeCreateContractHostFn: 1,
        sorobanAuthorizedFunctionTypeCreateContractV2HostFn: 2
    });
    // === xdr source ============================================================
    //
    //   union SorobanAuthorizedFunction switch (SorobanAuthorizedFunctionType type)
    //   {
    //   case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN:
    //       InvokeContractArgs contractFn;
    //   // This variant of auth payload for creating new contract instances
    //   // doesn't allow specifying the constructor arguments, creating contracts
    //   // with constructors that take arguments is only possible by authorizing
    //   // `SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_V2_HOST_FN`
    //   // (protocol 22+).
    //   case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN:
    //       CreateContractArgs createContractHostFn;
    //   // This variant of auth payload for creating new contract instances
    //   // is only accepted in and after protocol 22. It allows authorizing the
    //   // contract constructor arguments.
    //   case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_V2_HOST_FN:
    //       CreateContractArgsV2 createContractV2HostFn;
    //   };
    //
    // ===========================================================================
    xdr.union("SorobanAuthorizedFunction", {
        switchOn: xdr.lookup("SorobanAuthorizedFunctionType"),
        switchName: "type",
        switches: [
            [
                "sorobanAuthorizedFunctionTypeContractFn",
                "contractFn"
            ],
            [
                "sorobanAuthorizedFunctionTypeCreateContractHostFn",
                "createContractHostFn"
            ],
            [
                "sorobanAuthorizedFunctionTypeCreateContractV2HostFn",
                "createContractV2HostFn"
            ]
        ],
        arms: {
            contractFn: xdr.lookup("InvokeContractArgs"),
            createContractHostFn: xdr.lookup("CreateContractArgs"),
            createContractV2HostFn: xdr.lookup("CreateContractArgsV2")
        }
    });
    // === xdr source ============================================================
    //
    //   struct SorobanAuthorizedInvocation
    //   {
    //       SorobanAuthorizedFunction function;
    //       SorobanAuthorizedInvocation subInvocations<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("SorobanAuthorizedInvocation", [
        [
            "function",
            xdr.lookup("SorobanAuthorizedFunction")
        ],
        [
            "subInvocations",
            xdr.varArray(xdr.lookup("SorobanAuthorizedInvocation"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SorobanAddressCredentials
    //   {
    //       SCAddress address;
    //       int64 nonce;
    //       uint32 signatureExpirationLedger;
    //       SCVal signature;
    //   };
    //
    // ===========================================================================
    xdr.struct("SorobanAddressCredentials", [
        [
            "address",
            xdr.lookup("ScAddress")
        ],
        [
            "nonce",
            xdr.lookup("Int64")
        ],
        [
            "signatureExpirationLedger",
            xdr.lookup("Uint32")
        ],
        [
            "signature",
            xdr.lookup("ScVal")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum SorobanCredentialsType
    //   {
    //       SOROBAN_CREDENTIALS_SOURCE_ACCOUNT = 0,
    //       SOROBAN_CREDENTIALS_ADDRESS = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("SorobanCredentialsType", {
        sorobanCredentialsSourceAccount: 0,
        sorobanCredentialsAddress: 1
    });
    // === xdr source ============================================================
    //
    //   union SorobanCredentials switch (SorobanCredentialsType type)
    //   {
    //   case SOROBAN_CREDENTIALS_SOURCE_ACCOUNT:
    //       void;
    //   case SOROBAN_CREDENTIALS_ADDRESS:
    //       SorobanAddressCredentials address;
    //   };
    //
    // ===========================================================================
    xdr.union("SorobanCredentials", {
        switchOn: xdr.lookup("SorobanCredentialsType"),
        switchName: "type",
        switches: [
            [
                "sorobanCredentialsSourceAccount",
                xdr["void"]()
            ],
            [
                "sorobanCredentialsAddress",
                "address"
            ]
        ],
        arms: {
            address: xdr.lookup("SorobanAddressCredentials")
        }
    });
    // === xdr source ============================================================
    //
    //   struct SorobanAuthorizationEntry
    //   {
    //       SorobanCredentials credentials;
    //       SorobanAuthorizedInvocation rootInvocation;
    //   };
    //
    // ===========================================================================
    xdr.struct("SorobanAuthorizationEntry", [
        [
            "credentials",
            xdr.lookup("SorobanCredentials")
        ],
        [
            "rootInvocation",
            xdr.lookup("SorobanAuthorizedInvocation")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct InvokeHostFunctionOp
    //   {
    //       // Host function to invoke.
    //       HostFunction hostFunction;
    //       // Per-address authorizations for this host function.
    //       SorobanAuthorizationEntry auth<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("InvokeHostFunctionOp", [
        [
            "hostFunction",
            xdr.lookup("HostFunction")
        ],
        [
            "auth",
            xdr.varArray(xdr.lookup("SorobanAuthorizationEntry"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ExtendFootprintTTLOp
    //   {
    //       ExtensionPoint ext;
    //       uint32 extendTo;
    //   };
    //
    // ===========================================================================
    xdr.struct("ExtendFootprintTtlOp", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "extendTo",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct RestoreFootprintOp
    //   {
    //       ExtensionPoint ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("RestoreFootprintOp", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (OperationType type)
    //       {
    //       case CREATE_ACCOUNT:
    //           CreateAccountOp createAccountOp;
    //       case PAYMENT:
    //           PaymentOp paymentOp;
    //       case PATH_PAYMENT_STRICT_RECEIVE:
    //           PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp;
    //       case MANAGE_SELL_OFFER:
    //           ManageSellOfferOp manageSellOfferOp;
    //       case CREATE_PASSIVE_SELL_OFFER:
    //           CreatePassiveSellOfferOp createPassiveSellOfferOp;
    //       case SET_OPTIONS:
    //           SetOptionsOp setOptionsOp;
    //       case CHANGE_TRUST:
    //           ChangeTrustOp changeTrustOp;
    //       case ALLOW_TRUST:
    //           AllowTrustOp allowTrustOp;
    //       case ACCOUNT_MERGE:
    //           MuxedAccount destination;
    //       case INFLATION:
    //           void;
    //       case MANAGE_DATA:
    //           ManageDataOp manageDataOp;
    //       case BUMP_SEQUENCE:
    //           BumpSequenceOp bumpSequenceOp;
    //       case MANAGE_BUY_OFFER:
    //           ManageBuyOfferOp manageBuyOfferOp;
    //       case PATH_PAYMENT_STRICT_SEND:
    //           PathPaymentStrictSendOp pathPaymentStrictSendOp;
    //       case CREATE_CLAIMABLE_BALANCE:
    //           CreateClaimableBalanceOp createClaimableBalanceOp;
    //       case CLAIM_CLAIMABLE_BALANCE:
    //           ClaimClaimableBalanceOp claimClaimableBalanceOp;
    //       case BEGIN_SPONSORING_FUTURE_RESERVES:
    //           BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp;
    //       case END_SPONSORING_FUTURE_RESERVES:
    //           void;
    //       case REVOKE_SPONSORSHIP:
    //           RevokeSponsorshipOp revokeSponsorshipOp;
    //       case CLAWBACK:
    //           ClawbackOp clawbackOp;
    //       case CLAWBACK_CLAIMABLE_BALANCE:
    //           ClawbackClaimableBalanceOp clawbackClaimableBalanceOp;
    //       case SET_TRUST_LINE_FLAGS:
    //           SetTrustLineFlagsOp setTrustLineFlagsOp;
    //       case LIQUIDITY_POOL_DEPOSIT:
    //           LiquidityPoolDepositOp liquidityPoolDepositOp;
    //       case LIQUIDITY_POOL_WITHDRAW:
    //           LiquidityPoolWithdrawOp liquidityPoolWithdrawOp;
    //       case INVOKE_HOST_FUNCTION:
    //           InvokeHostFunctionOp invokeHostFunctionOp;
    //       case EXTEND_FOOTPRINT_TTL:
    //           ExtendFootprintTTLOp extendFootprintTTLOp;
    //       case RESTORE_FOOTPRINT:
    //           RestoreFootprintOp restoreFootprintOp;
    //       }
    //
    // ===========================================================================
    xdr.union("OperationBody", {
        switchOn: xdr.lookup("OperationType"),
        switchName: "type",
        switches: [
            [
                "createAccount",
                "createAccountOp"
            ],
            [
                "payment",
                "paymentOp"
            ],
            [
                "pathPaymentStrictReceive",
                "pathPaymentStrictReceiveOp"
            ],
            [
                "manageSellOffer",
                "manageSellOfferOp"
            ],
            [
                "createPassiveSellOffer",
                "createPassiveSellOfferOp"
            ],
            [
                "setOptions",
                "setOptionsOp"
            ],
            [
                "changeTrust",
                "changeTrustOp"
            ],
            [
                "allowTrust",
                "allowTrustOp"
            ],
            [
                "accountMerge",
                "destination"
            ],
            [
                "inflation",
                xdr["void"]()
            ],
            [
                "manageData",
                "manageDataOp"
            ],
            [
                "bumpSequence",
                "bumpSequenceOp"
            ],
            [
                "manageBuyOffer",
                "manageBuyOfferOp"
            ],
            [
                "pathPaymentStrictSend",
                "pathPaymentStrictSendOp"
            ],
            [
                "createClaimableBalance",
                "createClaimableBalanceOp"
            ],
            [
                "claimClaimableBalance",
                "claimClaimableBalanceOp"
            ],
            [
                "beginSponsoringFutureReserves",
                "beginSponsoringFutureReservesOp"
            ],
            [
                "endSponsoringFutureReserves",
                xdr["void"]()
            ],
            [
                "revokeSponsorship",
                "revokeSponsorshipOp"
            ],
            [
                "clawback",
                "clawbackOp"
            ],
            [
                "clawbackClaimableBalance",
                "clawbackClaimableBalanceOp"
            ],
            [
                "setTrustLineFlags",
                "setTrustLineFlagsOp"
            ],
            [
                "liquidityPoolDeposit",
                "liquidityPoolDepositOp"
            ],
            [
                "liquidityPoolWithdraw",
                "liquidityPoolWithdrawOp"
            ],
            [
                "invokeHostFunction",
                "invokeHostFunctionOp"
            ],
            [
                "extendFootprintTtl",
                "extendFootprintTtlOp"
            ],
            [
                "restoreFootprint",
                "restoreFootprintOp"
            ]
        ],
        arms: {
            createAccountOp: xdr.lookup("CreateAccountOp"),
            paymentOp: xdr.lookup("PaymentOp"),
            pathPaymentStrictReceiveOp: xdr.lookup("PathPaymentStrictReceiveOp"),
            manageSellOfferOp: xdr.lookup("ManageSellOfferOp"),
            createPassiveSellOfferOp: xdr.lookup("CreatePassiveSellOfferOp"),
            setOptionsOp: xdr.lookup("SetOptionsOp"),
            changeTrustOp: xdr.lookup("ChangeTrustOp"),
            allowTrustOp: xdr.lookup("AllowTrustOp"),
            destination: xdr.lookup("MuxedAccount"),
            manageDataOp: xdr.lookup("ManageDataOp"),
            bumpSequenceOp: xdr.lookup("BumpSequenceOp"),
            manageBuyOfferOp: xdr.lookup("ManageBuyOfferOp"),
            pathPaymentStrictSendOp: xdr.lookup("PathPaymentStrictSendOp"),
            createClaimableBalanceOp: xdr.lookup("CreateClaimableBalanceOp"),
            claimClaimableBalanceOp: xdr.lookup("ClaimClaimableBalanceOp"),
            beginSponsoringFutureReservesOp: xdr.lookup("BeginSponsoringFutureReservesOp"),
            revokeSponsorshipOp: xdr.lookup("RevokeSponsorshipOp"),
            clawbackOp: xdr.lookup("ClawbackOp"),
            clawbackClaimableBalanceOp: xdr.lookup("ClawbackClaimableBalanceOp"),
            setTrustLineFlagsOp: xdr.lookup("SetTrustLineFlagsOp"),
            liquidityPoolDepositOp: xdr.lookup("LiquidityPoolDepositOp"),
            liquidityPoolWithdrawOp: xdr.lookup("LiquidityPoolWithdrawOp"),
            invokeHostFunctionOp: xdr.lookup("InvokeHostFunctionOp"),
            extendFootprintTtlOp: xdr.lookup("ExtendFootprintTtlOp"),
            restoreFootprintOp: xdr.lookup("RestoreFootprintOp")
        }
    });
    // === xdr source ============================================================
    //
    //   struct Operation
    //   {
    //       // sourceAccount is the account used to run the operation
    //       // if not set, the runtime defaults to "sourceAccount" specified at
    //       // the transaction level
    //       MuxedAccount* sourceAccount;
    //
    //       union switch (OperationType type)
    //       {
    //       case CREATE_ACCOUNT:
    //           CreateAccountOp createAccountOp;
    //       case PAYMENT:
    //           PaymentOp paymentOp;
    //       case PATH_PAYMENT_STRICT_RECEIVE:
    //           PathPaymentStrictReceiveOp pathPaymentStrictReceiveOp;
    //       case MANAGE_SELL_OFFER:
    //           ManageSellOfferOp manageSellOfferOp;
    //       case CREATE_PASSIVE_SELL_OFFER:
    //           CreatePassiveSellOfferOp createPassiveSellOfferOp;
    //       case SET_OPTIONS:
    //           SetOptionsOp setOptionsOp;
    //       case CHANGE_TRUST:
    //           ChangeTrustOp changeTrustOp;
    //       case ALLOW_TRUST:
    //           AllowTrustOp allowTrustOp;
    //       case ACCOUNT_MERGE:
    //           MuxedAccount destination;
    //       case INFLATION:
    //           void;
    //       case MANAGE_DATA:
    //           ManageDataOp manageDataOp;
    //       case BUMP_SEQUENCE:
    //           BumpSequenceOp bumpSequenceOp;
    //       case MANAGE_BUY_OFFER:
    //           ManageBuyOfferOp manageBuyOfferOp;
    //       case PATH_PAYMENT_STRICT_SEND:
    //           PathPaymentStrictSendOp pathPaymentStrictSendOp;
    //       case CREATE_CLAIMABLE_BALANCE:
    //           CreateClaimableBalanceOp createClaimableBalanceOp;
    //       case CLAIM_CLAIMABLE_BALANCE:
    //           ClaimClaimableBalanceOp claimClaimableBalanceOp;
    //       case BEGIN_SPONSORING_FUTURE_RESERVES:
    //           BeginSponsoringFutureReservesOp beginSponsoringFutureReservesOp;
    //       case END_SPONSORING_FUTURE_RESERVES:
    //           void;
    //       case REVOKE_SPONSORSHIP:
    //           RevokeSponsorshipOp revokeSponsorshipOp;
    //       case CLAWBACK:
    //           ClawbackOp clawbackOp;
    //       case CLAWBACK_CLAIMABLE_BALANCE:
    //           ClawbackClaimableBalanceOp clawbackClaimableBalanceOp;
    //       case SET_TRUST_LINE_FLAGS:
    //           SetTrustLineFlagsOp setTrustLineFlagsOp;
    //       case LIQUIDITY_POOL_DEPOSIT:
    //           LiquidityPoolDepositOp liquidityPoolDepositOp;
    //       case LIQUIDITY_POOL_WITHDRAW:
    //           LiquidityPoolWithdrawOp liquidityPoolWithdrawOp;
    //       case INVOKE_HOST_FUNCTION:
    //           InvokeHostFunctionOp invokeHostFunctionOp;
    //       case EXTEND_FOOTPRINT_TTL:
    //           ExtendFootprintTTLOp extendFootprintTTLOp;
    //       case RESTORE_FOOTPRINT:
    //           RestoreFootprintOp restoreFootprintOp;
    //       }
    //       body;
    //   };
    //
    // ===========================================================================
    xdr.struct("Operation", [
        [
            "sourceAccount",
            xdr.option(xdr.lookup("MuxedAccount"))
        ],
        [
            "body",
            xdr.lookup("OperationBody")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           AccountID sourceAccount;
    //           SequenceNumber seqNum;
    //           uint32 opNum;
    //       }
    //
    // ===========================================================================
    xdr.struct("HashIdPreimageOperationId", [
        [
            "sourceAccount",
            xdr.lookup("AccountId")
        ],
        [
            "seqNum",
            xdr.lookup("SequenceNumber")
        ],
        [
            "opNum",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           AccountID sourceAccount;
    //           SequenceNumber seqNum;
    //           uint32 opNum;
    //           PoolID liquidityPoolID;
    //           Asset asset;
    //       }
    //
    // ===========================================================================
    xdr.struct("HashIdPreimageRevokeId", [
        [
            "sourceAccount",
            xdr.lookup("AccountId")
        ],
        [
            "seqNum",
            xdr.lookup("SequenceNumber")
        ],
        [
            "opNum",
            xdr.lookup("Uint32")
        ],
        [
            "liquidityPoolId",
            xdr.lookup("PoolId")
        ],
        [
            "asset",
            xdr.lookup("Asset")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           Hash networkID;
    //           ContractIDPreimage contractIDPreimage;
    //       }
    //
    // ===========================================================================
    xdr.struct("HashIdPreimageContractId", [
        [
            "networkId",
            xdr.lookup("Hash")
        ],
        [
            "contractIdPreimage",
            xdr.lookup("ContractIdPreimage")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           Hash networkID;
    //           int64 nonce;
    //           uint32 signatureExpirationLedger;
    //           SorobanAuthorizedInvocation invocation;
    //       }
    //
    // ===========================================================================
    xdr.struct("HashIdPreimageSorobanAuthorization", [
        [
            "networkId",
            xdr.lookup("Hash")
        ],
        [
            "nonce",
            xdr.lookup("Int64")
        ],
        [
            "signatureExpirationLedger",
            xdr.lookup("Uint32")
        ],
        [
            "invocation",
            xdr.lookup("SorobanAuthorizedInvocation")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union HashIDPreimage switch (EnvelopeType type)
    //   {
    //   case ENVELOPE_TYPE_OP_ID:
    //       struct
    //       {
    //           AccountID sourceAccount;
    //           SequenceNumber seqNum;
    //           uint32 opNum;
    //       } operationID;
    //   case ENVELOPE_TYPE_POOL_REVOKE_OP_ID:
    //       struct
    //       {
    //           AccountID sourceAccount;
    //           SequenceNumber seqNum;
    //           uint32 opNum;
    //           PoolID liquidityPoolID;
    //           Asset asset;
    //       } revokeID;
    //   case ENVELOPE_TYPE_CONTRACT_ID:
    //       struct
    //       {
    //           Hash networkID;
    //           ContractIDPreimage contractIDPreimage;
    //       } contractID;
    //   case ENVELOPE_TYPE_SOROBAN_AUTHORIZATION:
    //       struct
    //       {
    //           Hash networkID;
    //           int64 nonce;
    //           uint32 signatureExpirationLedger;
    //           SorobanAuthorizedInvocation invocation;
    //       } sorobanAuthorization;
    //   };
    //
    // ===========================================================================
    xdr.union("HashIdPreimage", {
        switchOn: xdr.lookup("EnvelopeType"),
        switchName: "type",
        switches: [
            [
                "envelopeTypeOpId",
                "operationId"
            ],
            [
                "envelopeTypePoolRevokeOpId",
                "revokeId"
            ],
            [
                "envelopeTypeContractId",
                "contractId"
            ],
            [
                "envelopeTypeSorobanAuthorization",
                "sorobanAuthorization"
            ]
        ],
        arms: {
            operationId: xdr.lookup("HashIdPreimageOperationId"),
            revokeId: xdr.lookup("HashIdPreimageRevokeId"),
            contractId: xdr.lookup("HashIdPreimageContractId"),
            sorobanAuthorization: xdr.lookup("HashIdPreimageSorobanAuthorization")
        }
    });
    // === xdr source ============================================================
    //
    //   enum MemoType
    //   {
    //       MEMO_NONE = 0,
    //       MEMO_TEXT = 1,
    //       MEMO_ID = 2,
    //       MEMO_HASH = 3,
    //       MEMO_RETURN = 4
    //   };
    //
    // ===========================================================================
    xdr["enum"]("MemoType", {
        memoNone: 0,
        memoText: 1,
        memoId: 2,
        memoHash: 3,
        memoReturn: 4
    });
    // === xdr source ============================================================
    //
    //   union Memo switch (MemoType type)
    //   {
    //   case MEMO_NONE:
    //       void;
    //   case MEMO_TEXT:
    //       string text<28>;
    //   case MEMO_ID:
    //       uint64 id;
    //   case MEMO_HASH:
    //       Hash hash; // the hash of what to pull from the content server
    //   case MEMO_RETURN:
    //       Hash retHash; // the hash of the tx you are rejecting
    //   };
    //
    // ===========================================================================
    xdr.union("Memo", {
        switchOn: xdr.lookup("MemoType"),
        switchName: "type",
        switches: [
            [
                "memoNone",
                xdr["void"]()
            ],
            [
                "memoText",
                "text"
            ],
            [
                "memoId",
                "id"
            ],
            [
                "memoHash",
                "hash"
            ],
            [
                "memoReturn",
                "retHash"
            ]
        ],
        arms: {
            text: xdr.string(28),
            id: xdr.lookup("Uint64"),
            hash: xdr.lookup("Hash"),
            retHash: xdr.lookup("Hash")
        }
    });
    // === xdr source ============================================================
    //
    //   struct TimeBounds
    //   {
    //       TimePoint minTime;
    //       TimePoint maxTime; // 0 here means no maxTime
    //   };
    //
    // ===========================================================================
    xdr.struct("TimeBounds", [
        [
            "minTime",
            xdr.lookup("TimePoint")
        ],
        [
            "maxTime",
            xdr.lookup("TimePoint")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct LedgerBounds
    //   {
    //       uint32 minLedger;
    //       uint32 maxLedger; // 0 here means no maxLedger
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerBounds", [
        [
            "minLedger",
            xdr.lookup("Uint32")
        ],
        [
            "maxLedger",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct PreconditionsV2
    //   {
    //       TimeBounds* timeBounds;
    //
    //       // Transaction only valid for ledger numbers n such that
    //       // minLedger <= n < maxLedger (if maxLedger == 0, then
    //       // only minLedger is checked)
    //       LedgerBounds* ledgerBounds;
    //
    //       // If NULL, only valid when sourceAccount's sequence number
    //       // is seqNum - 1.  Otherwise, valid when sourceAccount's
    //       // sequence number n satisfies minSeqNum <= n < tx.seqNum.
    //       // Note that after execution the account's sequence number
    //       // is always raised to tx.seqNum, and a transaction is not
    //       // valid if tx.seqNum is too high to ensure replay protection.
    //       SequenceNumber* minSeqNum;
    //
    //       // For the transaction to be valid, the current ledger time must
    //       // be at least minSeqAge greater than sourceAccount's seqTime.
    //       Duration minSeqAge;
    //
    //       // For the transaction to be valid, the current ledger number
    //       // must be at least minSeqLedgerGap greater than sourceAccount's
    //       // seqLedger.
    //       uint32 minSeqLedgerGap;
    //
    //       // For the transaction to be valid, there must be a signature
    //       // corresponding to every Signer in this array, even if the
    //       // signature is not otherwise required by the sourceAccount or
    //       // operations.
    //       SignerKey extraSigners<2>;
    //   };
    //
    // ===========================================================================
    xdr.struct("PreconditionsV2", [
        [
            "timeBounds",
            xdr.option(xdr.lookup("TimeBounds"))
        ],
        [
            "ledgerBounds",
            xdr.option(xdr.lookup("LedgerBounds"))
        ],
        [
            "minSeqNum",
            xdr.option(xdr.lookup("SequenceNumber"))
        ],
        [
            "minSeqAge",
            xdr.lookup("Duration")
        ],
        [
            "minSeqLedgerGap",
            xdr.lookup("Uint32")
        ],
        [
            "extraSigners",
            xdr.varArray(xdr.lookup("SignerKey"), 2)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum PreconditionType
    //   {
    //       PRECOND_NONE = 0,
    //       PRECOND_TIME = 1,
    //       PRECOND_V2 = 2
    //   };
    //
    // ===========================================================================
    xdr["enum"]("PreconditionType", {
        precondNone: 0,
        precondTime: 1,
        precondV2: 2
    });
    // === xdr source ============================================================
    //
    //   union Preconditions switch (PreconditionType type)
    //   {
    //   case PRECOND_NONE:
    //       void;
    //   case PRECOND_TIME:
    //       TimeBounds timeBounds;
    //   case PRECOND_V2:
    //       PreconditionsV2 v2;
    //   };
    //
    // ===========================================================================
    xdr.union("Preconditions", {
        switchOn: xdr.lookup("PreconditionType"),
        switchName: "type",
        switches: [
            [
                "precondNone",
                xdr["void"]()
            ],
            [
                "precondTime",
                "timeBounds"
            ],
            [
                "precondV2",
                "v2"
            ]
        ],
        arms: {
            timeBounds: xdr.lookup("TimeBounds"),
            v2: xdr.lookup("PreconditionsV2")
        }
    });
    // === xdr source ============================================================
    //
    //   struct LedgerFootprint
    //   {
    //       LedgerKey readOnly<>;
    //       LedgerKey readWrite<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("LedgerFootprint", [
        [
            "readOnly",
            xdr.varArray(xdr.lookup("LedgerKey"), 2147483647)
        ],
        [
            "readWrite",
            xdr.varArray(xdr.lookup("LedgerKey"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum ArchivalProofType
    //   {
    //       EXISTENCE = 0,
    //       NONEXISTENCE = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ArchivalProofType", {
        existence: 0,
        nonexistence: 1
    });
    // === xdr source ============================================================
    //
    //   struct ArchivalProofNode
    //   {
    //       uint32 index;
    //       Hash hash;
    //   };
    //
    // ===========================================================================
    xdr.struct("ArchivalProofNode", [
        [
            "index",
            xdr.lookup("Uint32")
        ],
        [
            "hash",
            xdr.lookup("Hash")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   typedef ArchivalProofNode ProofLevel<>;
    //
    // ===========================================================================
    xdr.typedef("ProofLevel", xdr.varArray(xdr.lookup("ArchivalProofNode"), 2147483647));
    // === xdr source ============================================================
    //
    //   struct NonexistenceProofBody
    //   {
    //       ColdArchiveBucketEntry entriesToProve<>;
    //
    //       // Vector of vectors, where proofLevels[level]
    //       // contains all HashNodes that correspond with that level
    //       ProofLevel proofLevels<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("NonexistenceProofBody", [
        [
            "entriesToProve",
            xdr.varArray(xdr.lookup("ColdArchiveBucketEntry"), 2147483647)
        ],
        [
            "proofLevels",
            xdr.varArray(xdr.lookup("ProofLevel"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ExistenceProofBody
    //   {
    //       LedgerKey keysToProve<>;
    //
    //       // Bounds for each key being proved, where bound[n]
    //       // corresponds to keysToProve[n]
    //       ColdArchiveBucketEntry lowBoundEntries<>;
    //       ColdArchiveBucketEntry highBoundEntries<>;
    //
    //       // Vector of vectors, where proofLevels[level]
    //       // contains all HashNodes that correspond with that level
    //       ProofLevel proofLevels<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ExistenceProofBody", [
        [
            "keysToProve",
            xdr.varArray(xdr.lookup("LedgerKey"), 2147483647)
        ],
        [
            "lowBoundEntries",
            xdr.varArray(xdr.lookup("ColdArchiveBucketEntry"), 2147483647)
        ],
        [
            "highBoundEntries",
            xdr.varArray(xdr.lookup("ColdArchiveBucketEntry"), 2147483647)
        ],
        [
            "proofLevels",
            xdr.varArray(xdr.lookup("ProofLevel"), 2147483647)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (ArchivalProofType t)
    //       {
    //       case EXISTENCE:
    //           NonexistenceProofBody nonexistenceProof;
    //       case NONEXISTENCE:
    //           ExistenceProofBody existenceProof;
    //       }
    //
    // ===========================================================================
    xdr.union("ArchivalProofBody", {
        switchOn: xdr.lookup("ArchivalProofType"),
        switchName: "t",
        switches: [
            [
                "existence",
                "nonexistenceProof"
            ],
            [
                "nonexistence",
                "existenceProof"
            ]
        ],
        arms: {
            nonexistenceProof: xdr.lookup("NonexistenceProofBody"),
            existenceProof: xdr.lookup("ExistenceProofBody")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ArchivalProof
    //   {
    //       uint32 epoch; // AST Subtree for this proof
    //
    //       union switch (ArchivalProofType t)
    //       {
    //       case EXISTENCE:
    //           NonexistenceProofBody nonexistenceProof;
    //       case NONEXISTENCE:
    //           ExistenceProofBody existenceProof;
    //       } body;
    //   };
    //
    // ===========================================================================
    xdr.struct("ArchivalProof", [
        [
            "epoch",
            xdr.lookup("Uint32")
        ],
        [
            "body",
            xdr.lookup("ArchivalProofBody")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SorobanResources
    //   {
    //       // The ledger footprint of the transaction.
    //       LedgerFootprint footprint;
    //       // The maximum number of instructions this transaction can use
    //       uint32 instructions;
    //
    //       // The maximum number of bytes this transaction can read from ledger
    //       uint32 readBytes;
    //       // The maximum number of bytes this transaction can write to ledger
    //       uint32 writeBytes;
    //   };
    //
    // ===========================================================================
    xdr.struct("SorobanResources", [
        [
            "footprint",
            xdr.lookup("LedgerFootprint")
        ],
        [
            "instructions",
            xdr.lookup("Uint32")
        ],
        [
            "readBytes",
            xdr.lookup("Uint32")
        ],
        [
            "writeBytes",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SorobanTransactionData
    //   {
    //       ExtensionPoint ext;
    //       SorobanResources resources;
    //       // Amount of the transaction `fee` allocated to the Soroban resource fees.
    //       // The fraction of `resourceFee` corresponding to `resources` specified
    //       // above is *not* refundable (i.e. fees for instructions, ledger I/O), as
    //       // well as fees for the transaction size.
    //       // The remaining part of the fee is refundable and the charged value is
    //       // based on the actual consumption of refundable resources (events, ledger
    //       // rent bumps).
    //       // The `inclusionFee` used for prioritization of the transaction is defined
    //       // as `tx.fee - resourceFee`.
    //       int64 resourceFee;
    //   };
    //
    // ===========================================================================
    xdr.struct("SorobanTransactionData", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "resources",
            xdr.lookup("SorobanResources")
        ],
        [
            "resourceFee",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("TransactionV0Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct TransactionV0
    //   {
    //       uint256 sourceAccountEd25519;
    //       uint32 fee;
    //       SequenceNumber seqNum;
    //       TimeBounds* timeBounds;
    //       Memo memo;
    //       Operation operations<MAX_OPS_PER_TX>;
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionV0", [
        [
            "sourceAccountEd25519",
            xdr.lookup("Uint256")
        ],
        [
            "fee",
            xdr.lookup("Uint32")
        ],
        [
            "seqNum",
            xdr.lookup("SequenceNumber")
        ],
        [
            "timeBounds",
            xdr.option(xdr.lookup("TimeBounds"))
        ],
        [
            "memo",
            xdr.lookup("Memo")
        ],
        [
            "operations",
            xdr.varArray(xdr.lookup("Operation"), xdr.lookup("MAX_OPS_PER_TX"))
        ],
        [
            "ext",
            xdr.lookup("TransactionV0Ext")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TransactionV0Envelope
    //   {
    //       TransactionV0 tx;
    //       /* Each decorated signature is a signature over the SHA256 hash of
    //        * a TransactionSignaturePayload */
    //       DecoratedSignature signatures<20>;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionV0Envelope", [
        [
            "tx",
            xdr.lookup("TransactionV0")
        ],
        [
            "signatures",
            xdr.varArray(xdr.lookup("DecoratedSignature"), 20)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           SorobanTransactionData sorobanData;
    //       }
    //
    // ===========================================================================
    xdr.union("TransactionExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ],
            [
                1,
                "sorobanData"
            ]
        ],
        arms: {
            sorobanData: xdr.lookup("SorobanTransactionData")
        }
    });
    // === xdr source ============================================================
    //
    //   struct Transaction
    //   {
    //       // account used to run the transaction
    //       MuxedAccount sourceAccount;
    //
    //       // the fee the sourceAccount will pay
    //       uint32 fee;
    //
    //       // sequence number to consume in the account
    //       SequenceNumber seqNum;
    //
    //       // validity conditions
    //       Preconditions cond;
    //
    //       Memo memo;
    //
    //       Operation operations<MAX_OPS_PER_TX>;
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       case 1:
    //           SorobanTransactionData sorobanData;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("Transaction", [
        [
            "sourceAccount",
            xdr.lookup("MuxedAccount")
        ],
        [
            "fee",
            xdr.lookup("Uint32")
        ],
        [
            "seqNum",
            xdr.lookup("SequenceNumber")
        ],
        [
            "cond",
            xdr.lookup("Preconditions")
        ],
        [
            "memo",
            xdr.lookup("Memo")
        ],
        [
            "operations",
            xdr.varArray(xdr.lookup("Operation"), xdr.lookup("MAX_OPS_PER_TX"))
        ],
        [
            "ext",
            xdr.lookup("TransactionExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct TransactionV1Envelope
    //   {
    //       Transaction tx;
    //       /* Each decorated signature is a signature over the SHA256 hash of
    //        * a TransactionSignaturePayload */
    //       DecoratedSignature signatures<20>;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionV1Envelope", [
        [
            "tx",
            xdr.lookup("Transaction")
        ],
        [
            "signatures",
            xdr.varArray(xdr.lookup("DecoratedSignature"), 20)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (EnvelopeType type)
    //       {
    //       case ENVELOPE_TYPE_TX:
    //           TransactionV1Envelope v1;
    //       }
    //
    // ===========================================================================
    xdr.union("FeeBumpTransactionInnerTx", {
        switchOn: xdr.lookup("EnvelopeType"),
        switchName: "type",
        switches: [
            [
                "envelopeTypeTx",
                "v1"
            ]
        ],
        arms: {
            v1: xdr.lookup("TransactionV1Envelope")
        }
    });
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("FeeBumpTransactionExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct FeeBumpTransaction
    //   {
    //       MuxedAccount feeSource;
    //       int64 fee;
    //       union switch (EnvelopeType type)
    //       {
    //       case ENVELOPE_TYPE_TX:
    //           TransactionV1Envelope v1;
    //       }
    //       innerTx;
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("FeeBumpTransaction", [
        [
            "feeSource",
            xdr.lookup("MuxedAccount")
        ],
        [
            "fee",
            xdr.lookup("Int64")
        ],
        [
            "innerTx",
            xdr.lookup("FeeBumpTransactionInnerTx")
        ],
        [
            "ext",
            xdr.lookup("FeeBumpTransactionExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct FeeBumpTransactionEnvelope
    //   {
    //       FeeBumpTransaction tx;
    //       /* Each decorated signature is a signature over the SHA256 hash of
    //        * a TransactionSignaturePayload */
    //       DecoratedSignature signatures<20>;
    //   };
    //
    // ===========================================================================
    xdr.struct("FeeBumpTransactionEnvelope", [
        [
            "tx",
            xdr.lookup("FeeBumpTransaction")
        ],
        [
            "signatures",
            xdr.varArray(xdr.lookup("DecoratedSignature"), 20)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union TransactionEnvelope switch (EnvelopeType type)
    //   {
    //   case ENVELOPE_TYPE_TX_V0:
    //       TransactionV0Envelope v0;
    //   case ENVELOPE_TYPE_TX:
    //       TransactionV1Envelope v1;
    //   case ENVELOPE_TYPE_TX_FEE_BUMP:
    //       FeeBumpTransactionEnvelope feeBump;
    //   };
    //
    // ===========================================================================
    xdr.union("TransactionEnvelope", {
        switchOn: xdr.lookup("EnvelopeType"),
        switchName: "type",
        switches: [
            [
                "envelopeTypeTxV0",
                "v0"
            ],
            [
                "envelopeTypeTx",
                "v1"
            ],
            [
                "envelopeTypeTxFeeBump",
                "feeBump"
            ]
        ],
        arms: {
            v0: xdr.lookup("TransactionV0Envelope"),
            v1: xdr.lookup("TransactionV1Envelope"),
            feeBump: xdr.lookup("FeeBumpTransactionEnvelope")
        }
    });
    // === xdr source ============================================================
    //
    //   union switch (EnvelopeType type)
    //       {
    //       // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0
    //       case ENVELOPE_TYPE_TX:
    //           Transaction tx;
    //       case ENVELOPE_TYPE_TX_FEE_BUMP:
    //           FeeBumpTransaction feeBump;
    //       }
    //
    // ===========================================================================
    xdr.union("TransactionSignaturePayloadTaggedTransaction", {
        switchOn: xdr.lookup("EnvelopeType"),
        switchName: "type",
        switches: [
            [
                "envelopeTypeTx",
                "tx"
            ],
            [
                "envelopeTypeTxFeeBump",
                "feeBump"
            ]
        ],
        arms: {
            tx: xdr.lookup("Transaction"),
            feeBump: xdr.lookup("FeeBumpTransaction")
        }
    });
    // === xdr source ============================================================
    //
    //   struct TransactionSignaturePayload
    //   {
    //       Hash networkId;
    //       union switch (EnvelopeType type)
    //       {
    //       // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0
    //       case ENVELOPE_TYPE_TX:
    //           Transaction tx;
    //       case ENVELOPE_TYPE_TX_FEE_BUMP:
    //           FeeBumpTransaction feeBump;
    //       }
    //       taggedTransaction;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionSignaturePayload", [
        [
            "networkId",
            xdr.lookup("Hash")
        ],
        [
            "taggedTransaction",
            xdr.lookup("TransactionSignaturePayloadTaggedTransaction")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum ClaimAtomType
    //   {
    //       CLAIM_ATOM_TYPE_V0 = 0,
    //       CLAIM_ATOM_TYPE_ORDER_BOOK = 1,
    //       CLAIM_ATOM_TYPE_LIQUIDITY_POOL = 2
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ClaimAtomType", {
        claimAtomTypeV0: 0,
        claimAtomTypeOrderBook: 1,
        claimAtomTypeLiquidityPool: 2
    });
    // === xdr source ============================================================
    //
    //   struct ClaimOfferAtomV0
    //   {
    //       // emitted to identify the offer
    //       uint256 sellerEd25519; // Account that owns the offer
    //       int64 offerID;
    //
    //       // amount and asset taken from the owner
    //       Asset assetSold;
    //       int64 amountSold;
    //
    //       // amount and asset sent to the owner
    //       Asset assetBought;
    //       int64 amountBought;
    //   };
    //
    // ===========================================================================
    xdr.struct("ClaimOfferAtomV0", [
        [
            "sellerEd25519",
            xdr.lookup("Uint256")
        ],
        [
            "offerId",
            xdr.lookup("Int64")
        ],
        [
            "assetSold",
            xdr.lookup("Asset")
        ],
        [
            "amountSold",
            xdr.lookup("Int64")
        ],
        [
            "assetBought",
            xdr.lookup("Asset")
        ],
        [
            "amountBought",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ClaimOfferAtom
    //   {
    //       // emitted to identify the offer
    //       AccountID sellerID; // Account that owns the offer
    //       int64 offerID;
    //
    //       // amount and asset taken from the owner
    //       Asset assetSold;
    //       int64 amountSold;
    //
    //       // amount and asset sent to the owner
    //       Asset assetBought;
    //       int64 amountBought;
    //   };
    //
    // ===========================================================================
    xdr.struct("ClaimOfferAtom", [
        [
            "sellerId",
            xdr.lookup("AccountId")
        ],
        [
            "offerId",
            xdr.lookup("Int64")
        ],
        [
            "assetSold",
            xdr.lookup("Asset")
        ],
        [
            "amountSold",
            xdr.lookup("Int64")
        ],
        [
            "assetBought",
            xdr.lookup("Asset")
        ],
        [
            "amountBought",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ClaimLiquidityAtom
    //   {
    //       PoolID liquidityPoolID;
    //
    //       // amount and asset taken from the pool
    //       Asset assetSold;
    //       int64 amountSold;
    //
    //       // amount and asset sent to the pool
    //       Asset assetBought;
    //       int64 amountBought;
    //   };
    //
    // ===========================================================================
    xdr.struct("ClaimLiquidityAtom", [
        [
            "liquidityPoolId",
            xdr.lookup("PoolId")
        ],
        [
            "assetSold",
            xdr.lookup("Asset")
        ],
        [
            "amountSold",
            xdr.lookup("Int64")
        ],
        [
            "assetBought",
            xdr.lookup("Asset")
        ],
        [
            "amountBought",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union ClaimAtom switch (ClaimAtomType type)
    //   {
    //   case CLAIM_ATOM_TYPE_V0:
    //       ClaimOfferAtomV0 v0;
    //   case CLAIM_ATOM_TYPE_ORDER_BOOK:
    //       ClaimOfferAtom orderBook;
    //   case CLAIM_ATOM_TYPE_LIQUIDITY_POOL:
    //       ClaimLiquidityAtom liquidityPool;
    //   };
    //
    // ===========================================================================
    xdr.union("ClaimAtom", {
        switchOn: xdr.lookup("ClaimAtomType"),
        switchName: "type",
        switches: [
            [
                "claimAtomTypeV0",
                "v0"
            ],
            [
                "claimAtomTypeOrderBook",
                "orderBook"
            ],
            [
                "claimAtomTypeLiquidityPool",
                "liquidityPool"
            ]
        ],
        arms: {
            v0: xdr.lookup("ClaimOfferAtomV0"),
            orderBook: xdr.lookup("ClaimOfferAtom"),
            liquidityPool: xdr.lookup("ClaimLiquidityAtom")
        }
    });
    // === xdr source ============================================================
    //
    //   enum CreateAccountResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       CREATE_ACCOUNT_SUCCESS = 0, // account was created
    //
    //       // codes considered as "failure" for the operation
    //       CREATE_ACCOUNT_MALFORMED = -1,   // invalid destination
    //       CREATE_ACCOUNT_UNDERFUNDED = -2, // not enough funds in source account
    //       CREATE_ACCOUNT_LOW_RESERVE =
    //           -3, // would create an account below the min reserve
    //       CREATE_ACCOUNT_ALREADY_EXIST = -4 // account already exists
    //   };
    //
    // ===========================================================================
    xdr["enum"]("CreateAccountResultCode", {
        createAccountSuccess: 0,
        createAccountMalformed: -1,
        createAccountUnderfunded: -2,
        createAccountLowReserve: -3,
        createAccountAlreadyExist: -4
    });
    // === xdr source ============================================================
    //
    //   union CreateAccountResult switch (CreateAccountResultCode code)
    //   {
    //   case CREATE_ACCOUNT_SUCCESS:
    //       void;
    //   case CREATE_ACCOUNT_MALFORMED:
    //   case CREATE_ACCOUNT_UNDERFUNDED:
    //   case CREATE_ACCOUNT_LOW_RESERVE:
    //   case CREATE_ACCOUNT_ALREADY_EXIST:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("CreateAccountResult", {
        switchOn: xdr.lookup("CreateAccountResultCode"),
        switchName: "code",
        switches: [
            [
                "createAccountSuccess",
                xdr["void"]()
            ],
            [
                "createAccountMalformed",
                xdr["void"]()
            ],
            [
                "createAccountUnderfunded",
                xdr["void"]()
            ],
            [
                "createAccountLowReserve",
                xdr["void"]()
            ],
            [
                "createAccountAlreadyExist",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum PaymentResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       PAYMENT_SUCCESS = 0, // payment successfully completed
    //
    //       // codes considered as "failure" for the operation
    //       PAYMENT_MALFORMED = -1,          // bad input
    //       PAYMENT_UNDERFUNDED = -2,        // not enough funds in source account
    //       PAYMENT_SRC_NO_TRUST = -3,       // no trust line on source account
    //       PAYMENT_SRC_NOT_AUTHORIZED = -4, // source not authorized to transfer
    //       PAYMENT_NO_DESTINATION = -5,     // destination account does not exist
    //       PAYMENT_NO_TRUST = -6,       // destination missing a trust line for asset
    //       PAYMENT_NOT_AUTHORIZED = -7, // destination not authorized to hold asset
    //       PAYMENT_LINE_FULL = -8,      // destination would go above their limit
    //       PAYMENT_NO_ISSUER = -9       // missing issuer on asset
    //   };
    //
    // ===========================================================================
    xdr["enum"]("PaymentResultCode", {
        paymentSuccess: 0,
        paymentMalformed: -1,
        paymentUnderfunded: -2,
        paymentSrcNoTrust: -3,
        paymentSrcNotAuthorized: -4,
        paymentNoDestination: -5,
        paymentNoTrust: -6,
        paymentNotAuthorized: -7,
        paymentLineFull: -8,
        paymentNoIssuer: -9
    });
    // === xdr source ============================================================
    //
    //   union PaymentResult switch (PaymentResultCode code)
    //   {
    //   case PAYMENT_SUCCESS:
    //       void;
    //   case PAYMENT_MALFORMED:
    //   case PAYMENT_UNDERFUNDED:
    //   case PAYMENT_SRC_NO_TRUST:
    //   case PAYMENT_SRC_NOT_AUTHORIZED:
    //   case PAYMENT_NO_DESTINATION:
    //   case PAYMENT_NO_TRUST:
    //   case PAYMENT_NOT_AUTHORIZED:
    //   case PAYMENT_LINE_FULL:
    //   case PAYMENT_NO_ISSUER:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("PaymentResult", {
        switchOn: xdr.lookup("PaymentResultCode"),
        switchName: "code",
        switches: [
            [
                "paymentSuccess",
                xdr["void"]()
            ],
            [
                "paymentMalformed",
                xdr["void"]()
            ],
            [
                "paymentUnderfunded",
                xdr["void"]()
            ],
            [
                "paymentSrcNoTrust",
                xdr["void"]()
            ],
            [
                "paymentSrcNotAuthorized",
                xdr["void"]()
            ],
            [
                "paymentNoDestination",
                xdr["void"]()
            ],
            [
                "paymentNoTrust",
                xdr["void"]()
            ],
            [
                "paymentNotAuthorized",
                xdr["void"]()
            ],
            [
                "paymentLineFull",
                xdr["void"]()
            ],
            [
                "paymentNoIssuer",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum PathPaymentStrictReceiveResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       PATH_PAYMENT_STRICT_RECEIVE_SUCCESS = 0, // success
    //
    //       // codes considered as "failure" for the operation
    //       PATH_PAYMENT_STRICT_RECEIVE_MALFORMED = -1, // bad input
    //       PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED =
    //           -2, // not enough funds in source account
    //       PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST =
    //           -3, // no trust line on source account
    //       PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED =
    //           -4, // source not authorized to transfer
    //       PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION =
    //           -5, // destination account does not exist
    //       PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST =
    //           -6, // dest missing a trust line for asset
    //       PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED =
    //           -7, // dest not authorized to hold asset
    //       PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL =
    //           -8, // dest would go above their limit
    //       PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER = -9, // missing issuer on one asset
    //       PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS =
    //           -10, // not enough offers to satisfy path
    //       PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF =
    //           -11, // would cross one of its own offers
    //       PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX = -12 // could not satisfy sendmax
    //   };
    //
    // ===========================================================================
    xdr["enum"]("PathPaymentStrictReceiveResultCode", {
        pathPaymentStrictReceiveSuccess: 0,
        pathPaymentStrictReceiveMalformed: -1,
        pathPaymentStrictReceiveUnderfunded: -2,
        pathPaymentStrictReceiveSrcNoTrust: -3,
        pathPaymentStrictReceiveSrcNotAuthorized: -4,
        pathPaymentStrictReceiveNoDestination: -5,
        pathPaymentStrictReceiveNoTrust: -6,
        pathPaymentStrictReceiveNotAuthorized: -7,
        pathPaymentStrictReceiveLineFull: -8,
        pathPaymentStrictReceiveNoIssuer: -9,
        pathPaymentStrictReceiveTooFewOffers: -10,
        pathPaymentStrictReceiveOfferCrossSelf: -11,
        pathPaymentStrictReceiveOverSendmax: -12
    });
    // === xdr source ============================================================
    //
    //   struct SimplePaymentResult
    //   {
    //       AccountID destination;
    //       Asset asset;
    //       int64 amount;
    //   };
    //
    // ===========================================================================
    xdr.struct("SimplePaymentResult", [
        [
            "destination",
            xdr.lookup("AccountId")
        ],
        [
            "asset",
            xdr.lookup("Asset")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           ClaimAtom offers<>;
    //           SimplePaymentResult last;
    //       }
    //
    // ===========================================================================
    xdr.struct("PathPaymentStrictReceiveResultSuccess", [
        [
            "offers",
            xdr.varArray(xdr.lookup("ClaimAtom"), 2147483647)
        ],
        [
            "last",
            xdr.lookup("SimplePaymentResult")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union PathPaymentStrictReceiveResult switch (
    //       PathPaymentStrictReceiveResultCode code)
    //   {
    //   case PATH_PAYMENT_STRICT_RECEIVE_SUCCESS:
    //       struct
    //       {
    //           ClaimAtom offers<>;
    //           SimplePaymentResult last;
    //       } success;
    //   case PATH_PAYMENT_STRICT_RECEIVE_MALFORMED:
    //   case PATH_PAYMENT_STRICT_RECEIVE_UNDERFUNDED:
    //   case PATH_PAYMENT_STRICT_RECEIVE_SRC_NO_TRUST:
    //   case PATH_PAYMENT_STRICT_RECEIVE_SRC_NOT_AUTHORIZED:
    //   case PATH_PAYMENT_STRICT_RECEIVE_NO_DESTINATION:
    //   case PATH_PAYMENT_STRICT_RECEIVE_NO_TRUST:
    //   case PATH_PAYMENT_STRICT_RECEIVE_NOT_AUTHORIZED:
    //   case PATH_PAYMENT_STRICT_RECEIVE_LINE_FULL:
    //       void;
    //   case PATH_PAYMENT_STRICT_RECEIVE_NO_ISSUER:
    //       Asset noIssuer; // the asset that caused the error
    //   case PATH_PAYMENT_STRICT_RECEIVE_TOO_FEW_OFFERS:
    //   case PATH_PAYMENT_STRICT_RECEIVE_OFFER_CROSS_SELF:
    //   case PATH_PAYMENT_STRICT_RECEIVE_OVER_SENDMAX:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("PathPaymentStrictReceiveResult", {
        switchOn: xdr.lookup("PathPaymentStrictReceiveResultCode"),
        switchName: "code",
        switches: [
            [
                "pathPaymentStrictReceiveSuccess",
                "success"
            ],
            [
                "pathPaymentStrictReceiveMalformed",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveUnderfunded",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveSrcNoTrust",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveSrcNotAuthorized",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveNoDestination",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveNoTrust",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveNotAuthorized",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveLineFull",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveNoIssuer",
                "noIssuer"
            ],
            [
                "pathPaymentStrictReceiveTooFewOffers",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveOfferCrossSelf",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictReceiveOverSendmax",
                xdr["void"]()
            ]
        ],
        arms: {
            success: xdr.lookup("PathPaymentStrictReceiveResultSuccess"),
            noIssuer: xdr.lookup("Asset")
        }
    });
    // === xdr source ============================================================
    //
    //   enum PathPaymentStrictSendResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       PATH_PAYMENT_STRICT_SEND_SUCCESS = 0, // success
    //
    //       // codes considered as "failure" for the operation
    //       PATH_PAYMENT_STRICT_SEND_MALFORMED = -1, // bad input
    //       PATH_PAYMENT_STRICT_SEND_UNDERFUNDED =
    //           -2, // not enough funds in source account
    //       PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST =
    //           -3, // no trust line on source account
    //       PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED =
    //           -4, // source not authorized to transfer
    //       PATH_PAYMENT_STRICT_SEND_NO_DESTINATION =
    //           -5, // destination account does not exist
    //       PATH_PAYMENT_STRICT_SEND_NO_TRUST =
    //           -6, // dest missing a trust line for asset
    //       PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED =
    //           -7, // dest not authorized to hold asset
    //       PATH_PAYMENT_STRICT_SEND_LINE_FULL = -8, // dest would go above their limit
    //       PATH_PAYMENT_STRICT_SEND_NO_ISSUER = -9, // missing issuer on one asset
    //       PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS =
    //           -10, // not enough offers to satisfy path
    //       PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF =
    //           -11, // would cross one of its own offers
    //       PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN = -12 // could not satisfy destMin
    //   };
    //
    // ===========================================================================
    xdr["enum"]("PathPaymentStrictSendResultCode", {
        pathPaymentStrictSendSuccess: 0,
        pathPaymentStrictSendMalformed: -1,
        pathPaymentStrictSendUnderfunded: -2,
        pathPaymentStrictSendSrcNoTrust: -3,
        pathPaymentStrictSendSrcNotAuthorized: -4,
        pathPaymentStrictSendNoDestination: -5,
        pathPaymentStrictSendNoTrust: -6,
        pathPaymentStrictSendNotAuthorized: -7,
        pathPaymentStrictSendLineFull: -8,
        pathPaymentStrictSendNoIssuer: -9,
        pathPaymentStrictSendTooFewOffers: -10,
        pathPaymentStrictSendOfferCrossSelf: -11,
        pathPaymentStrictSendUnderDestmin: -12
    });
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           ClaimAtom offers<>;
    //           SimplePaymentResult last;
    //       }
    //
    // ===========================================================================
    xdr.struct("PathPaymentStrictSendResultSuccess", [
        [
            "offers",
            xdr.varArray(xdr.lookup("ClaimAtom"), 2147483647)
        ],
        [
            "last",
            xdr.lookup("SimplePaymentResult")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union PathPaymentStrictSendResult switch (PathPaymentStrictSendResultCode code)
    //   {
    //   case PATH_PAYMENT_STRICT_SEND_SUCCESS:
    //       struct
    //       {
    //           ClaimAtom offers<>;
    //           SimplePaymentResult last;
    //       } success;
    //   case PATH_PAYMENT_STRICT_SEND_MALFORMED:
    //   case PATH_PAYMENT_STRICT_SEND_UNDERFUNDED:
    //   case PATH_PAYMENT_STRICT_SEND_SRC_NO_TRUST:
    //   case PATH_PAYMENT_STRICT_SEND_SRC_NOT_AUTHORIZED:
    //   case PATH_PAYMENT_STRICT_SEND_NO_DESTINATION:
    //   case PATH_PAYMENT_STRICT_SEND_NO_TRUST:
    //   case PATH_PAYMENT_STRICT_SEND_NOT_AUTHORIZED:
    //   case PATH_PAYMENT_STRICT_SEND_LINE_FULL:
    //       void;
    //   case PATH_PAYMENT_STRICT_SEND_NO_ISSUER:
    //       Asset noIssuer; // the asset that caused the error
    //   case PATH_PAYMENT_STRICT_SEND_TOO_FEW_OFFERS:
    //   case PATH_PAYMENT_STRICT_SEND_OFFER_CROSS_SELF:
    //   case PATH_PAYMENT_STRICT_SEND_UNDER_DESTMIN:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("PathPaymentStrictSendResult", {
        switchOn: xdr.lookup("PathPaymentStrictSendResultCode"),
        switchName: "code",
        switches: [
            [
                "pathPaymentStrictSendSuccess",
                "success"
            ],
            [
                "pathPaymentStrictSendMalformed",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendUnderfunded",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendSrcNoTrust",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendSrcNotAuthorized",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendNoDestination",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendNoTrust",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendNotAuthorized",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendLineFull",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendNoIssuer",
                "noIssuer"
            ],
            [
                "pathPaymentStrictSendTooFewOffers",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendOfferCrossSelf",
                xdr["void"]()
            ],
            [
                "pathPaymentStrictSendUnderDestmin",
                xdr["void"]()
            ]
        ],
        arms: {
            success: xdr.lookup("PathPaymentStrictSendResultSuccess"),
            noIssuer: xdr.lookup("Asset")
        }
    });
    // === xdr source ============================================================
    //
    //   enum ManageSellOfferResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       MANAGE_SELL_OFFER_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       MANAGE_SELL_OFFER_MALFORMED = -1, // generated offer would be invalid
    //       MANAGE_SELL_OFFER_SELL_NO_TRUST =
    //           -2,                              // no trust line for what we're selling
    //       MANAGE_SELL_OFFER_BUY_NO_TRUST = -3, // no trust line for what we're buying
    //       MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell
    //       MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy
    //       MANAGE_SELL_OFFER_LINE_FULL = -6, // can't receive more of what it's buying
    //       MANAGE_SELL_OFFER_UNDERFUNDED = -7, // doesn't hold what it's trying to sell
    //       MANAGE_SELL_OFFER_CROSS_SELF =
    //           -8, // would cross an offer from the same user
    //       MANAGE_SELL_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling
    //       MANAGE_SELL_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying
    //
    //       // update errors
    //       MANAGE_SELL_OFFER_NOT_FOUND =
    //           -11, // offerID does not match an existing offer
    //
    //       MANAGE_SELL_OFFER_LOW_RESERVE =
    //           -12 // not enough funds to create a new Offer
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ManageSellOfferResultCode", {
        manageSellOfferSuccess: 0,
        manageSellOfferMalformed: -1,
        manageSellOfferSellNoTrust: -2,
        manageSellOfferBuyNoTrust: -3,
        manageSellOfferSellNotAuthorized: -4,
        manageSellOfferBuyNotAuthorized: -5,
        manageSellOfferLineFull: -6,
        manageSellOfferUnderfunded: -7,
        manageSellOfferCrossSelf: -8,
        manageSellOfferSellNoIssuer: -9,
        manageSellOfferBuyNoIssuer: -10,
        manageSellOfferNotFound: -11,
        manageSellOfferLowReserve: -12
    });
    // === xdr source ============================================================
    //
    //   enum ManageOfferEffect
    //   {
    //       MANAGE_OFFER_CREATED = 0,
    //       MANAGE_OFFER_UPDATED = 1,
    //       MANAGE_OFFER_DELETED = 2
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ManageOfferEffect", {
        manageOfferCreated: 0,
        manageOfferUpdated: 1,
        manageOfferDeleted: 2
    });
    // === xdr source ============================================================
    //
    //   union switch (ManageOfferEffect effect)
    //       {
    //       case MANAGE_OFFER_CREATED:
    //       case MANAGE_OFFER_UPDATED:
    //           OfferEntry offer;
    //       case MANAGE_OFFER_DELETED:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("ManageOfferSuccessResultOffer", {
        switchOn: xdr.lookup("ManageOfferEffect"),
        switchName: "effect",
        switches: [
            [
                "manageOfferCreated",
                "offer"
            ],
            [
                "manageOfferUpdated",
                "offer"
            ],
            [
                "manageOfferDeleted",
                xdr["void"]()
            ]
        ],
        arms: {
            offer: xdr.lookup("OfferEntry")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ManageOfferSuccessResult
    //   {
    //       // offers that got claimed while creating this offer
    //       ClaimAtom offersClaimed<>;
    //
    //       union switch (ManageOfferEffect effect)
    //       {
    //       case MANAGE_OFFER_CREATED:
    //       case MANAGE_OFFER_UPDATED:
    //           OfferEntry offer;
    //       case MANAGE_OFFER_DELETED:
    //           void;
    //       }
    //       offer;
    //   };
    //
    // ===========================================================================
    xdr.struct("ManageOfferSuccessResult", [
        [
            "offersClaimed",
            xdr.varArray(xdr.lookup("ClaimAtom"), 2147483647)
        ],
        [
            "offer",
            xdr.lookup("ManageOfferSuccessResultOffer")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union ManageSellOfferResult switch (ManageSellOfferResultCode code)
    //   {
    //   case MANAGE_SELL_OFFER_SUCCESS:
    //       ManageOfferSuccessResult success;
    //   case MANAGE_SELL_OFFER_MALFORMED:
    //   case MANAGE_SELL_OFFER_SELL_NO_TRUST:
    //   case MANAGE_SELL_OFFER_BUY_NO_TRUST:
    //   case MANAGE_SELL_OFFER_SELL_NOT_AUTHORIZED:
    //   case MANAGE_SELL_OFFER_BUY_NOT_AUTHORIZED:
    //   case MANAGE_SELL_OFFER_LINE_FULL:
    //   case MANAGE_SELL_OFFER_UNDERFUNDED:
    //   case MANAGE_SELL_OFFER_CROSS_SELF:
    //   case MANAGE_SELL_OFFER_SELL_NO_ISSUER:
    //   case MANAGE_SELL_OFFER_BUY_NO_ISSUER:
    //   case MANAGE_SELL_OFFER_NOT_FOUND:
    //   case MANAGE_SELL_OFFER_LOW_RESERVE:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ManageSellOfferResult", {
        switchOn: xdr.lookup("ManageSellOfferResultCode"),
        switchName: "code",
        switches: [
            [
                "manageSellOfferSuccess",
                "success"
            ],
            [
                "manageSellOfferMalformed",
                xdr["void"]()
            ],
            [
                "manageSellOfferSellNoTrust",
                xdr["void"]()
            ],
            [
                "manageSellOfferBuyNoTrust",
                xdr["void"]()
            ],
            [
                "manageSellOfferSellNotAuthorized",
                xdr["void"]()
            ],
            [
                "manageSellOfferBuyNotAuthorized",
                xdr["void"]()
            ],
            [
                "manageSellOfferLineFull",
                xdr["void"]()
            ],
            [
                "manageSellOfferUnderfunded",
                xdr["void"]()
            ],
            [
                "manageSellOfferCrossSelf",
                xdr["void"]()
            ],
            [
                "manageSellOfferSellNoIssuer",
                xdr["void"]()
            ],
            [
                "manageSellOfferBuyNoIssuer",
                xdr["void"]()
            ],
            [
                "manageSellOfferNotFound",
                xdr["void"]()
            ],
            [
                "manageSellOfferLowReserve",
                xdr["void"]()
            ]
        ],
        arms: {
            success: xdr.lookup("ManageOfferSuccessResult")
        }
    });
    // === xdr source ============================================================
    //
    //   enum ManageBuyOfferResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       MANAGE_BUY_OFFER_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       MANAGE_BUY_OFFER_MALFORMED = -1,     // generated offer would be invalid
    //       MANAGE_BUY_OFFER_SELL_NO_TRUST = -2, // no trust line for what we're selling
    //       MANAGE_BUY_OFFER_BUY_NO_TRUST = -3,  // no trust line for what we're buying
    //       MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED = -4, // not authorized to sell
    //       MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED = -5,  // not authorized to buy
    //       MANAGE_BUY_OFFER_LINE_FULL = -6,   // can't receive more of what it's buying
    //       MANAGE_BUY_OFFER_UNDERFUNDED = -7, // doesn't hold what it's trying to sell
    //       MANAGE_BUY_OFFER_CROSS_SELF = -8, // would cross an offer from the same user
    //       MANAGE_BUY_OFFER_SELL_NO_ISSUER = -9, // no issuer for what we're selling
    //       MANAGE_BUY_OFFER_BUY_NO_ISSUER = -10, // no issuer for what we're buying
    //
    //       // update errors
    //       MANAGE_BUY_OFFER_NOT_FOUND =
    //           -11, // offerID does not match an existing offer
    //
    //       MANAGE_BUY_OFFER_LOW_RESERVE = -12 // not enough funds to create a new Offer
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ManageBuyOfferResultCode", {
        manageBuyOfferSuccess: 0,
        manageBuyOfferMalformed: -1,
        manageBuyOfferSellNoTrust: -2,
        manageBuyOfferBuyNoTrust: -3,
        manageBuyOfferSellNotAuthorized: -4,
        manageBuyOfferBuyNotAuthorized: -5,
        manageBuyOfferLineFull: -6,
        manageBuyOfferUnderfunded: -7,
        manageBuyOfferCrossSelf: -8,
        manageBuyOfferSellNoIssuer: -9,
        manageBuyOfferBuyNoIssuer: -10,
        manageBuyOfferNotFound: -11,
        manageBuyOfferLowReserve: -12
    });
    // === xdr source ============================================================
    //
    //   union ManageBuyOfferResult switch (ManageBuyOfferResultCode code)
    //   {
    //   case MANAGE_BUY_OFFER_SUCCESS:
    //       ManageOfferSuccessResult success;
    //   case MANAGE_BUY_OFFER_MALFORMED:
    //   case MANAGE_BUY_OFFER_SELL_NO_TRUST:
    //   case MANAGE_BUY_OFFER_BUY_NO_TRUST:
    //   case MANAGE_BUY_OFFER_SELL_NOT_AUTHORIZED:
    //   case MANAGE_BUY_OFFER_BUY_NOT_AUTHORIZED:
    //   case MANAGE_BUY_OFFER_LINE_FULL:
    //   case MANAGE_BUY_OFFER_UNDERFUNDED:
    //   case MANAGE_BUY_OFFER_CROSS_SELF:
    //   case MANAGE_BUY_OFFER_SELL_NO_ISSUER:
    //   case MANAGE_BUY_OFFER_BUY_NO_ISSUER:
    //   case MANAGE_BUY_OFFER_NOT_FOUND:
    //   case MANAGE_BUY_OFFER_LOW_RESERVE:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ManageBuyOfferResult", {
        switchOn: xdr.lookup("ManageBuyOfferResultCode"),
        switchName: "code",
        switches: [
            [
                "manageBuyOfferSuccess",
                "success"
            ],
            [
                "manageBuyOfferMalformed",
                xdr["void"]()
            ],
            [
                "manageBuyOfferSellNoTrust",
                xdr["void"]()
            ],
            [
                "manageBuyOfferBuyNoTrust",
                xdr["void"]()
            ],
            [
                "manageBuyOfferSellNotAuthorized",
                xdr["void"]()
            ],
            [
                "manageBuyOfferBuyNotAuthorized",
                xdr["void"]()
            ],
            [
                "manageBuyOfferLineFull",
                xdr["void"]()
            ],
            [
                "manageBuyOfferUnderfunded",
                xdr["void"]()
            ],
            [
                "manageBuyOfferCrossSelf",
                xdr["void"]()
            ],
            [
                "manageBuyOfferSellNoIssuer",
                xdr["void"]()
            ],
            [
                "manageBuyOfferBuyNoIssuer",
                xdr["void"]()
            ],
            [
                "manageBuyOfferNotFound",
                xdr["void"]()
            ],
            [
                "manageBuyOfferLowReserve",
                xdr["void"]()
            ]
        ],
        arms: {
            success: xdr.lookup("ManageOfferSuccessResult")
        }
    });
    // === xdr source ============================================================
    //
    //   enum SetOptionsResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       SET_OPTIONS_SUCCESS = 0,
    //       // codes considered as "failure" for the operation
    //       SET_OPTIONS_LOW_RESERVE = -1,      // not enough funds to add a signer
    //       SET_OPTIONS_TOO_MANY_SIGNERS = -2, // max number of signers already reached
    //       SET_OPTIONS_BAD_FLAGS = -3,        // invalid combination of clear/set flags
    //       SET_OPTIONS_INVALID_INFLATION = -4,      // inflation account does not exist
    //       SET_OPTIONS_CANT_CHANGE = -5,            // can no longer change this option
    //       SET_OPTIONS_UNKNOWN_FLAG = -6,           // can't set an unknown flag
    //       SET_OPTIONS_THRESHOLD_OUT_OF_RANGE = -7, // bad value for weight/threshold
    //       SET_OPTIONS_BAD_SIGNER = -8,             // signer cannot be masterkey
    //       SET_OPTIONS_INVALID_HOME_DOMAIN = -9,    // malformed home domain
    //       SET_OPTIONS_AUTH_REVOCABLE_REQUIRED =
    //           -10 // auth revocable is required for clawback
    //   };
    //
    // ===========================================================================
    xdr["enum"]("SetOptionsResultCode", {
        setOptionsSuccess: 0,
        setOptionsLowReserve: -1,
        setOptionsTooManySigners: -2,
        setOptionsBadFlags: -3,
        setOptionsInvalidInflation: -4,
        setOptionsCantChange: -5,
        setOptionsUnknownFlag: -6,
        setOptionsThresholdOutOfRange: -7,
        setOptionsBadSigner: -8,
        setOptionsInvalidHomeDomain: -9,
        setOptionsAuthRevocableRequired: -10
    });
    // === xdr source ============================================================
    //
    //   union SetOptionsResult switch (SetOptionsResultCode code)
    //   {
    //   case SET_OPTIONS_SUCCESS:
    //       void;
    //   case SET_OPTIONS_LOW_RESERVE:
    //   case SET_OPTIONS_TOO_MANY_SIGNERS:
    //   case SET_OPTIONS_BAD_FLAGS:
    //   case SET_OPTIONS_INVALID_INFLATION:
    //   case SET_OPTIONS_CANT_CHANGE:
    //   case SET_OPTIONS_UNKNOWN_FLAG:
    //   case SET_OPTIONS_THRESHOLD_OUT_OF_RANGE:
    //   case SET_OPTIONS_BAD_SIGNER:
    //   case SET_OPTIONS_INVALID_HOME_DOMAIN:
    //   case SET_OPTIONS_AUTH_REVOCABLE_REQUIRED:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("SetOptionsResult", {
        switchOn: xdr.lookup("SetOptionsResultCode"),
        switchName: "code",
        switches: [
            [
                "setOptionsSuccess",
                xdr["void"]()
            ],
            [
                "setOptionsLowReserve",
                xdr["void"]()
            ],
            [
                "setOptionsTooManySigners",
                xdr["void"]()
            ],
            [
                "setOptionsBadFlags",
                xdr["void"]()
            ],
            [
                "setOptionsInvalidInflation",
                xdr["void"]()
            ],
            [
                "setOptionsCantChange",
                xdr["void"]()
            ],
            [
                "setOptionsUnknownFlag",
                xdr["void"]()
            ],
            [
                "setOptionsThresholdOutOfRange",
                xdr["void"]()
            ],
            [
                "setOptionsBadSigner",
                xdr["void"]()
            ],
            [
                "setOptionsInvalidHomeDomain",
                xdr["void"]()
            ],
            [
                "setOptionsAuthRevocableRequired",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum ChangeTrustResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       CHANGE_TRUST_SUCCESS = 0,
    //       // codes considered as "failure" for the operation
    //       CHANGE_TRUST_MALFORMED = -1,     // bad input
    //       CHANGE_TRUST_NO_ISSUER = -2,     // could not find issuer
    //       CHANGE_TRUST_INVALID_LIMIT = -3, // cannot drop limit below balance
    //                                        // cannot create with a limit of 0
    //       CHANGE_TRUST_LOW_RESERVE =
    //           -4, // not enough funds to create a new trust line,
    //       CHANGE_TRUST_SELF_NOT_ALLOWED = -5,   // trusting self is not allowed
    //       CHANGE_TRUST_TRUST_LINE_MISSING = -6, // Asset trustline is missing for pool
    //       CHANGE_TRUST_CANNOT_DELETE =
    //           -7, // Asset trustline is still referenced in a pool
    //       CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES =
    //           -8 // Asset trustline is deauthorized
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ChangeTrustResultCode", {
        changeTrustSuccess: 0,
        changeTrustMalformed: -1,
        changeTrustNoIssuer: -2,
        changeTrustInvalidLimit: -3,
        changeTrustLowReserve: -4,
        changeTrustSelfNotAllowed: -5,
        changeTrustTrustLineMissing: -6,
        changeTrustCannotDelete: -7,
        changeTrustNotAuthMaintainLiabilities: -8
    });
    // === xdr source ============================================================
    //
    //   union ChangeTrustResult switch (ChangeTrustResultCode code)
    //   {
    //   case CHANGE_TRUST_SUCCESS:
    //       void;
    //   case CHANGE_TRUST_MALFORMED:
    //   case CHANGE_TRUST_NO_ISSUER:
    //   case CHANGE_TRUST_INVALID_LIMIT:
    //   case CHANGE_TRUST_LOW_RESERVE:
    //   case CHANGE_TRUST_SELF_NOT_ALLOWED:
    //   case CHANGE_TRUST_TRUST_LINE_MISSING:
    //   case CHANGE_TRUST_CANNOT_DELETE:
    //   case CHANGE_TRUST_NOT_AUTH_MAINTAIN_LIABILITIES:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ChangeTrustResult", {
        switchOn: xdr.lookup("ChangeTrustResultCode"),
        switchName: "code",
        switches: [
            [
                "changeTrustSuccess",
                xdr["void"]()
            ],
            [
                "changeTrustMalformed",
                xdr["void"]()
            ],
            [
                "changeTrustNoIssuer",
                xdr["void"]()
            ],
            [
                "changeTrustInvalidLimit",
                xdr["void"]()
            ],
            [
                "changeTrustLowReserve",
                xdr["void"]()
            ],
            [
                "changeTrustSelfNotAllowed",
                xdr["void"]()
            ],
            [
                "changeTrustTrustLineMissing",
                xdr["void"]()
            ],
            [
                "changeTrustCannotDelete",
                xdr["void"]()
            ],
            [
                "changeTrustNotAuthMaintainLiabilities",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum AllowTrustResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       ALLOW_TRUST_SUCCESS = 0,
    //       // codes considered as "failure" for the operation
    //       ALLOW_TRUST_MALFORMED = -1,     // asset is not ASSET_TYPE_ALPHANUM
    //       ALLOW_TRUST_NO_TRUST_LINE = -2, // trustor does not have a trustline
    //                                       // source account does not require trust
    //       ALLOW_TRUST_TRUST_NOT_REQUIRED = -3,
    //       ALLOW_TRUST_CANT_REVOKE = -4,      // source account can't revoke trust,
    //       ALLOW_TRUST_SELF_NOT_ALLOWED = -5, // trusting self is not allowed
    //       ALLOW_TRUST_LOW_RESERVE = -6       // claimable balances can't be created
    //                                          // on revoke due to low reserves
    //   };
    //
    // ===========================================================================
    xdr["enum"]("AllowTrustResultCode", {
        allowTrustSuccess: 0,
        allowTrustMalformed: -1,
        allowTrustNoTrustLine: -2,
        allowTrustTrustNotRequired: -3,
        allowTrustCantRevoke: -4,
        allowTrustSelfNotAllowed: -5,
        allowTrustLowReserve: -6
    });
    // === xdr source ============================================================
    //
    //   union AllowTrustResult switch (AllowTrustResultCode code)
    //   {
    //   case ALLOW_TRUST_SUCCESS:
    //       void;
    //   case ALLOW_TRUST_MALFORMED:
    //   case ALLOW_TRUST_NO_TRUST_LINE:
    //   case ALLOW_TRUST_TRUST_NOT_REQUIRED:
    //   case ALLOW_TRUST_CANT_REVOKE:
    //   case ALLOW_TRUST_SELF_NOT_ALLOWED:
    //   case ALLOW_TRUST_LOW_RESERVE:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("AllowTrustResult", {
        switchOn: xdr.lookup("AllowTrustResultCode"),
        switchName: "code",
        switches: [
            [
                "allowTrustSuccess",
                xdr["void"]()
            ],
            [
                "allowTrustMalformed",
                xdr["void"]()
            ],
            [
                "allowTrustNoTrustLine",
                xdr["void"]()
            ],
            [
                "allowTrustTrustNotRequired",
                xdr["void"]()
            ],
            [
                "allowTrustCantRevoke",
                xdr["void"]()
            ],
            [
                "allowTrustSelfNotAllowed",
                xdr["void"]()
            ],
            [
                "allowTrustLowReserve",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum AccountMergeResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       ACCOUNT_MERGE_SUCCESS = 0,
    //       // codes considered as "failure" for the operation
    //       ACCOUNT_MERGE_MALFORMED = -1,       // can't merge onto itself
    //       ACCOUNT_MERGE_NO_ACCOUNT = -2,      // destination does not exist
    //       ACCOUNT_MERGE_IMMUTABLE_SET = -3,   // source account has AUTH_IMMUTABLE set
    //       ACCOUNT_MERGE_HAS_SUB_ENTRIES = -4, // account has trust lines/offers
    //       ACCOUNT_MERGE_SEQNUM_TOO_FAR = -5,  // sequence number is over max allowed
    //       ACCOUNT_MERGE_DEST_FULL = -6,       // can't add source balance to
    //                                           // destination balance
    //       ACCOUNT_MERGE_IS_SPONSOR = -7       // can't merge account that is a sponsor
    //   };
    //
    // ===========================================================================
    xdr["enum"]("AccountMergeResultCode", {
        accountMergeSuccess: 0,
        accountMergeMalformed: -1,
        accountMergeNoAccount: -2,
        accountMergeImmutableSet: -3,
        accountMergeHasSubEntries: -4,
        accountMergeSeqnumTooFar: -5,
        accountMergeDestFull: -6,
        accountMergeIsSponsor: -7
    });
    // === xdr source ============================================================
    //
    //   union AccountMergeResult switch (AccountMergeResultCode code)
    //   {
    //   case ACCOUNT_MERGE_SUCCESS:
    //       int64 sourceAccountBalance; // how much got transferred from source account
    //   case ACCOUNT_MERGE_MALFORMED:
    //   case ACCOUNT_MERGE_NO_ACCOUNT:
    //   case ACCOUNT_MERGE_IMMUTABLE_SET:
    //   case ACCOUNT_MERGE_HAS_SUB_ENTRIES:
    //   case ACCOUNT_MERGE_SEQNUM_TOO_FAR:
    //   case ACCOUNT_MERGE_DEST_FULL:
    //   case ACCOUNT_MERGE_IS_SPONSOR:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("AccountMergeResult", {
        switchOn: xdr.lookup("AccountMergeResultCode"),
        switchName: "code",
        switches: [
            [
                "accountMergeSuccess",
                "sourceAccountBalance"
            ],
            [
                "accountMergeMalformed",
                xdr["void"]()
            ],
            [
                "accountMergeNoAccount",
                xdr["void"]()
            ],
            [
                "accountMergeImmutableSet",
                xdr["void"]()
            ],
            [
                "accountMergeHasSubEntries",
                xdr["void"]()
            ],
            [
                "accountMergeSeqnumTooFar",
                xdr["void"]()
            ],
            [
                "accountMergeDestFull",
                xdr["void"]()
            ],
            [
                "accountMergeIsSponsor",
                xdr["void"]()
            ]
        ],
        arms: {
            sourceAccountBalance: xdr.lookup("Int64")
        }
    });
    // === xdr source ============================================================
    //
    //   enum InflationResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       INFLATION_SUCCESS = 0,
    //       // codes considered as "failure" for the operation
    //       INFLATION_NOT_TIME = -1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("InflationResultCode", {
        inflationSuccess: 0,
        inflationNotTime: -1
    });
    // === xdr source ============================================================
    //
    //   struct InflationPayout // or use PaymentResultAtom to limit types?
    //   {
    //       AccountID destination;
    //       int64 amount;
    //   };
    //
    // ===========================================================================
    xdr.struct("InflationPayout", [
        [
            "destination",
            xdr.lookup("AccountId")
        ],
        [
            "amount",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union InflationResult switch (InflationResultCode code)
    //   {
    //   case INFLATION_SUCCESS:
    //       InflationPayout payouts<>;
    //   case INFLATION_NOT_TIME:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("InflationResult", {
        switchOn: xdr.lookup("InflationResultCode"),
        switchName: "code",
        switches: [
            [
                "inflationSuccess",
                "payouts"
            ],
            [
                "inflationNotTime",
                xdr["void"]()
            ]
        ],
        arms: {
            payouts: xdr.varArray(xdr.lookup("InflationPayout"), 2147483647)
        }
    });
    // === xdr source ============================================================
    //
    //   enum ManageDataResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       MANAGE_DATA_SUCCESS = 0,
    //       // codes considered as "failure" for the operation
    //       MANAGE_DATA_NOT_SUPPORTED_YET =
    //           -1, // The network hasn't moved to this protocol change yet
    //       MANAGE_DATA_NAME_NOT_FOUND =
    //           -2, // Trying to remove a Data Entry that isn't there
    //       MANAGE_DATA_LOW_RESERVE = -3, // not enough funds to create a new Data Entry
    //       MANAGE_DATA_INVALID_NAME = -4 // Name not a valid string
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ManageDataResultCode", {
        manageDataSuccess: 0,
        manageDataNotSupportedYet: -1,
        manageDataNameNotFound: -2,
        manageDataLowReserve: -3,
        manageDataInvalidName: -4
    });
    // === xdr source ============================================================
    //
    //   union ManageDataResult switch (ManageDataResultCode code)
    //   {
    //   case MANAGE_DATA_SUCCESS:
    //       void;
    //   case MANAGE_DATA_NOT_SUPPORTED_YET:
    //   case MANAGE_DATA_NAME_NOT_FOUND:
    //   case MANAGE_DATA_LOW_RESERVE:
    //   case MANAGE_DATA_INVALID_NAME:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ManageDataResult", {
        switchOn: xdr.lookup("ManageDataResultCode"),
        switchName: "code",
        switches: [
            [
                "manageDataSuccess",
                xdr["void"]()
            ],
            [
                "manageDataNotSupportedYet",
                xdr["void"]()
            ],
            [
                "manageDataNameNotFound",
                xdr["void"]()
            ],
            [
                "manageDataLowReserve",
                xdr["void"]()
            ],
            [
                "manageDataInvalidName",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum BumpSequenceResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       BUMP_SEQUENCE_SUCCESS = 0,
    //       // codes considered as "failure" for the operation
    //       BUMP_SEQUENCE_BAD_SEQ = -1 // `bumpTo` is not within bounds
    //   };
    //
    // ===========================================================================
    xdr["enum"]("BumpSequenceResultCode", {
        bumpSequenceSuccess: 0,
        bumpSequenceBadSeq: -1
    });
    // === xdr source ============================================================
    //
    //   union BumpSequenceResult switch (BumpSequenceResultCode code)
    //   {
    //   case BUMP_SEQUENCE_SUCCESS:
    //       void;
    //   case BUMP_SEQUENCE_BAD_SEQ:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("BumpSequenceResult", {
        switchOn: xdr.lookup("BumpSequenceResultCode"),
        switchName: "code",
        switches: [
            [
                "bumpSequenceSuccess",
                xdr["void"]()
            ],
            [
                "bumpSequenceBadSeq",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum CreateClaimableBalanceResultCode
    //   {
    //       CREATE_CLAIMABLE_BALANCE_SUCCESS = 0,
    //       CREATE_CLAIMABLE_BALANCE_MALFORMED = -1,
    //       CREATE_CLAIMABLE_BALANCE_LOW_RESERVE = -2,
    //       CREATE_CLAIMABLE_BALANCE_NO_TRUST = -3,
    //       CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED = -4,
    //       CREATE_CLAIMABLE_BALANCE_UNDERFUNDED = -5
    //   };
    //
    // ===========================================================================
    xdr["enum"]("CreateClaimableBalanceResultCode", {
        createClaimableBalanceSuccess: 0,
        createClaimableBalanceMalformed: -1,
        createClaimableBalanceLowReserve: -2,
        createClaimableBalanceNoTrust: -3,
        createClaimableBalanceNotAuthorized: -4,
        createClaimableBalanceUnderfunded: -5
    });
    // === xdr source ============================================================
    //
    //   union CreateClaimableBalanceResult switch (
    //       CreateClaimableBalanceResultCode code)
    //   {
    //   case CREATE_CLAIMABLE_BALANCE_SUCCESS:
    //       ClaimableBalanceID balanceID;
    //   case CREATE_CLAIMABLE_BALANCE_MALFORMED:
    //   case CREATE_CLAIMABLE_BALANCE_LOW_RESERVE:
    //   case CREATE_CLAIMABLE_BALANCE_NO_TRUST:
    //   case CREATE_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
    //   case CREATE_CLAIMABLE_BALANCE_UNDERFUNDED:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("CreateClaimableBalanceResult", {
        switchOn: xdr.lookup("CreateClaimableBalanceResultCode"),
        switchName: "code",
        switches: [
            [
                "createClaimableBalanceSuccess",
                "balanceId"
            ],
            [
                "createClaimableBalanceMalformed",
                xdr["void"]()
            ],
            [
                "createClaimableBalanceLowReserve",
                xdr["void"]()
            ],
            [
                "createClaimableBalanceNoTrust",
                xdr["void"]()
            ],
            [
                "createClaimableBalanceNotAuthorized",
                xdr["void"]()
            ],
            [
                "createClaimableBalanceUnderfunded",
                xdr["void"]()
            ]
        ],
        arms: {
            balanceId: xdr.lookup("ClaimableBalanceId")
        }
    });
    // === xdr source ============================================================
    //
    //   enum ClaimClaimableBalanceResultCode
    //   {
    //       CLAIM_CLAIMABLE_BALANCE_SUCCESS = 0,
    //       CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST = -1,
    //       CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM = -2,
    //       CLAIM_CLAIMABLE_BALANCE_LINE_FULL = -3,
    //       CLAIM_CLAIMABLE_BALANCE_NO_TRUST = -4,
    //       CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED = -5
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ClaimClaimableBalanceResultCode", {
        claimClaimableBalanceSuccess: 0,
        claimClaimableBalanceDoesNotExist: -1,
        claimClaimableBalanceCannotClaim: -2,
        claimClaimableBalanceLineFull: -3,
        claimClaimableBalanceNoTrust: -4,
        claimClaimableBalanceNotAuthorized: -5
    });
    // === xdr source ============================================================
    //
    //   union ClaimClaimableBalanceResult switch (ClaimClaimableBalanceResultCode code)
    //   {
    //   case CLAIM_CLAIMABLE_BALANCE_SUCCESS:
    //       void;
    //   case CLAIM_CLAIMABLE_BALANCE_DOES_NOT_EXIST:
    //   case CLAIM_CLAIMABLE_BALANCE_CANNOT_CLAIM:
    //   case CLAIM_CLAIMABLE_BALANCE_LINE_FULL:
    //   case CLAIM_CLAIMABLE_BALANCE_NO_TRUST:
    //   case CLAIM_CLAIMABLE_BALANCE_NOT_AUTHORIZED:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ClaimClaimableBalanceResult", {
        switchOn: xdr.lookup("ClaimClaimableBalanceResultCode"),
        switchName: "code",
        switches: [
            [
                "claimClaimableBalanceSuccess",
                xdr["void"]()
            ],
            [
                "claimClaimableBalanceDoesNotExist",
                xdr["void"]()
            ],
            [
                "claimClaimableBalanceCannotClaim",
                xdr["void"]()
            ],
            [
                "claimClaimableBalanceLineFull",
                xdr["void"]()
            ],
            [
                "claimClaimableBalanceNoTrust",
                xdr["void"]()
            ],
            [
                "claimClaimableBalanceNotAuthorized",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum BeginSponsoringFutureReservesResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED = -1,
    //       BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED = -2,
    //       BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE = -3
    //   };
    //
    // ===========================================================================
    xdr["enum"]("BeginSponsoringFutureReservesResultCode", {
        beginSponsoringFutureReservesSuccess: 0,
        beginSponsoringFutureReservesMalformed: -1,
        beginSponsoringFutureReservesAlreadySponsored: -2,
        beginSponsoringFutureReservesRecursive: -3
    });
    // === xdr source ============================================================
    //
    //   union BeginSponsoringFutureReservesResult switch (
    //       BeginSponsoringFutureReservesResultCode code)
    //   {
    //   case BEGIN_SPONSORING_FUTURE_RESERVES_SUCCESS:
    //       void;
    //   case BEGIN_SPONSORING_FUTURE_RESERVES_MALFORMED:
    //   case BEGIN_SPONSORING_FUTURE_RESERVES_ALREADY_SPONSORED:
    //   case BEGIN_SPONSORING_FUTURE_RESERVES_RECURSIVE:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("BeginSponsoringFutureReservesResult", {
        switchOn: xdr.lookup("BeginSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [
            [
                "beginSponsoringFutureReservesSuccess",
                xdr["void"]()
            ],
            [
                "beginSponsoringFutureReservesMalformed",
                xdr["void"]()
            ],
            [
                "beginSponsoringFutureReservesAlreadySponsored",
                xdr["void"]()
            ],
            [
                "beginSponsoringFutureReservesRecursive",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum EndSponsoringFutureReservesResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       END_SPONSORING_FUTURE_RESERVES_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED = -1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("EndSponsoringFutureReservesResultCode", {
        endSponsoringFutureReservesSuccess: 0,
        endSponsoringFutureReservesNotSponsored: -1
    });
    // === xdr source ============================================================
    //
    //   union EndSponsoringFutureReservesResult switch (
    //       EndSponsoringFutureReservesResultCode code)
    //   {
    //   case END_SPONSORING_FUTURE_RESERVES_SUCCESS:
    //       void;
    //   case END_SPONSORING_FUTURE_RESERVES_NOT_SPONSORED:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("EndSponsoringFutureReservesResult", {
        switchOn: xdr.lookup("EndSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [
            [
                "endSponsoringFutureReservesSuccess",
                xdr["void"]()
            ],
            [
                "endSponsoringFutureReservesNotSponsored",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum RevokeSponsorshipResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       REVOKE_SPONSORSHIP_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       REVOKE_SPONSORSHIP_DOES_NOT_EXIST = -1,
    //       REVOKE_SPONSORSHIP_NOT_SPONSOR = -2,
    //       REVOKE_SPONSORSHIP_LOW_RESERVE = -3,
    //       REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE = -4,
    //       REVOKE_SPONSORSHIP_MALFORMED = -5
    //   };
    //
    // ===========================================================================
    xdr["enum"]("RevokeSponsorshipResultCode", {
        revokeSponsorshipSuccess: 0,
        revokeSponsorshipDoesNotExist: -1,
        revokeSponsorshipNotSponsor: -2,
        revokeSponsorshipLowReserve: -3,
        revokeSponsorshipOnlyTransferable: -4,
        revokeSponsorshipMalformed: -5
    });
    // === xdr source ============================================================
    //
    //   union RevokeSponsorshipResult switch (RevokeSponsorshipResultCode code)
    //   {
    //   case REVOKE_SPONSORSHIP_SUCCESS:
    //       void;
    //   case REVOKE_SPONSORSHIP_DOES_NOT_EXIST:
    //   case REVOKE_SPONSORSHIP_NOT_SPONSOR:
    //   case REVOKE_SPONSORSHIP_LOW_RESERVE:
    //   case REVOKE_SPONSORSHIP_ONLY_TRANSFERABLE:
    //   case REVOKE_SPONSORSHIP_MALFORMED:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("RevokeSponsorshipResult", {
        switchOn: xdr.lookup("RevokeSponsorshipResultCode"),
        switchName: "code",
        switches: [
            [
                "revokeSponsorshipSuccess",
                xdr["void"]()
            ],
            [
                "revokeSponsorshipDoesNotExist",
                xdr["void"]()
            ],
            [
                "revokeSponsorshipNotSponsor",
                xdr["void"]()
            ],
            [
                "revokeSponsorshipLowReserve",
                xdr["void"]()
            ],
            [
                "revokeSponsorshipOnlyTransferable",
                xdr["void"]()
            ],
            [
                "revokeSponsorshipMalformed",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum ClawbackResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       CLAWBACK_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       CLAWBACK_MALFORMED = -1,
    //       CLAWBACK_NOT_CLAWBACK_ENABLED = -2,
    //       CLAWBACK_NO_TRUST = -3,
    //       CLAWBACK_UNDERFUNDED = -4
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ClawbackResultCode", {
        clawbackSuccess: 0,
        clawbackMalformed: -1,
        clawbackNotClawbackEnabled: -2,
        clawbackNoTrust: -3,
        clawbackUnderfunded: -4
    });
    // === xdr source ============================================================
    //
    //   union ClawbackResult switch (ClawbackResultCode code)
    //   {
    //   case CLAWBACK_SUCCESS:
    //       void;
    //   case CLAWBACK_MALFORMED:
    //   case CLAWBACK_NOT_CLAWBACK_ENABLED:
    //   case CLAWBACK_NO_TRUST:
    //   case CLAWBACK_UNDERFUNDED:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ClawbackResult", {
        switchOn: xdr.lookup("ClawbackResultCode"),
        switchName: "code",
        switches: [
            [
                "clawbackSuccess",
                xdr["void"]()
            ],
            [
                "clawbackMalformed",
                xdr["void"]()
            ],
            [
                "clawbackNotClawbackEnabled",
                xdr["void"]()
            ],
            [
                "clawbackNoTrust",
                xdr["void"]()
            ],
            [
                "clawbackUnderfunded",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum ClawbackClaimableBalanceResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       CLAWBACK_CLAIMABLE_BALANCE_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST = -1,
    //       CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER = -2,
    //       CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED = -3
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ClawbackClaimableBalanceResultCode", {
        clawbackClaimableBalanceSuccess: 0,
        clawbackClaimableBalanceDoesNotExist: -1,
        clawbackClaimableBalanceNotIssuer: -2,
        clawbackClaimableBalanceNotClawbackEnabled: -3
    });
    // === xdr source ============================================================
    //
    //   union ClawbackClaimableBalanceResult switch (
    //       ClawbackClaimableBalanceResultCode code)
    //   {
    //   case CLAWBACK_CLAIMABLE_BALANCE_SUCCESS:
    //       void;
    //   case CLAWBACK_CLAIMABLE_BALANCE_DOES_NOT_EXIST:
    //   case CLAWBACK_CLAIMABLE_BALANCE_NOT_ISSUER:
    //   case CLAWBACK_CLAIMABLE_BALANCE_NOT_CLAWBACK_ENABLED:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ClawbackClaimableBalanceResult", {
        switchOn: xdr.lookup("ClawbackClaimableBalanceResultCode"),
        switchName: "code",
        switches: [
            [
                "clawbackClaimableBalanceSuccess",
                xdr["void"]()
            ],
            [
                "clawbackClaimableBalanceDoesNotExist",
                xdr["void"]()
            ],
            [
                "clawbackClaimableBalanceNotIssuer",
                xdr["void"]()
            ],
            [
                "clawbackClaimableBalanceNotClawbackEnabled",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum SetTrustLineFlagsResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       SET_TRUST_LINE_FLAGS_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       SET_TRUST_LINE_FLAGS_MALFORMED = -1,
    //       SET_TRUST_LINE_FLAGS_NO_TRUST_LINE = -2,
    //       SET_TRUST_LINE_FLAGS_CANT_REVOKE = -3,
    //       SET_TRUST_LINE_FLAGS_INVALID_STATE = -4,
    //       SET_TRUST_LINE_FLAGS_LOW_RESERVE = -5 // claimable balances can't be created
    //                                             // on revoke due to low reserves
    //   };
    //
    // ===========================================================================
    xdr["enum"]("SetTrustLineFlagsResultCode", {
        setTrustLineFlagsSuccess: 0,
        setTrustLineFlagsMalformed: -1,
        setTrustLineFlagsNoTrustLine: -2,
        setTrustLineFlagsCantRevoke: -3,
        setTrustLineFlagsInvalidState: -4,
        setTrustLineFlagsLowReserve: -5
    });
    // === xdr source ============================================================
    //
    //   union SetTrustLineFlagsResult switch (SetTrustLineFlagsResultCode code)
    //   {
    //   case SET_TRUST_LINE_FLAGS_SUCCESS:
    //       void;
    //   case SET_TRUST_LINE_FLAGS_MALFORMED:
    //   case SET_TRUST_LINE_FLAGS_NO_TRUST_LINE:
    //   case SET_TRUST_LINE_FLAGS_CANT_REVOKE:
    //   case SET_TRUST_LINE_FLAGS_INVALID_STATE:
    //   case SET_TRUST_LINE_FLAGS_LOW_RESERVE:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("SetTrustLineFlagsResult", {
        switchOn: xdr.lookup("SetTrustLineFlagsResultCode"),
        switchName: "code",
        switches: [
            [
                "setTrustLineFlagsSuccess",
                xdr["void"]()
            ],
            [
                "setTrustLineFlagsMalformed",
                xdr["void"]()
            ],
            [
                "setTrustLineFlagsNoTrustLine",
                xdr["void"]()
            ],
            [
                "setTrustLineFlagsCantRevoke",
                xdr["void"]()
            ],
            [
                "setTrustLineFlagsInvalidState",
                xdr["void"]()
            ],
            [
                "setTrustLineFlagsLowReserve",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum LiquidityPoolDepositResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       LIQUIDITY_POOL_DEPOSIT_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       LIQUIDITY_POOL_DEPOSIT_MALFORMED = -1,      // bad input
    //       LIQUIDITY_POOL_DEPOSIT_NO_TRUST = -2,       // no trust line for one of the
    //                                                   // assets
    //       LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED = -3, // not authorized for one of the
    //                                                   // assets
    //       LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED = -4,    // not enough balance for one of
    //                                                   // the assets
    //       LIQUIDITY_POOL_DEPOSIT_LINE_FULL = -5,      // pool share trust line doesn't
    //                                                   // have sufficient limit
    //       LIQUIDITY_POOL_DEPOSIT_BAD_PRICE = -6,      // deposit price outside bounds
    //       LIQUIDITY_POOL_DEPOSIT_POOL_FULL = -7       // pool reserves are full
    //   };
    //
    // ===========================================================================
    xdr["enum"]("LiquidityPoolDepositResultCode", {
        liquidityPoolDepositSuccess: 0,
        liquidityPoolDepositMalformed: -1,
        liquidityPoolDepositNoTrust: -2,
        liquidityPoolDepositNotAuthorized: -3,
        liquidityPoolDepositUnderfunded: -4,
        liquidityPoolDepositLineFull: -5,
        liquidityPoolDepositBadPrice: -6,
        liquidityPoolDepositPoolFull: -7
    });
    // === xdr source ============================================================
    //
    //   union LiquidityPoolDepositResult switch (LiquidityPoolDepositResultCode code)
    //   {
    //   case LIQUIDITY_POOL_DEPOSIT_SUCCESS:
    //       void;
    //   case LIQUIDITY_POOL_DEPOSIT_MALFORMED:
    //   case LIQUIDITY_POOL_DEPOSIT_NO_TRUST:
    //   case LIQUIDITY_POOL_DEPOSIT_NOT_AUTHORIZED:
    //   case LIQUIDITY_POOL_DEPOSIT_UNDERFUNDED:
    //   case LIQUIDITY_POOL_DEPOSIT_LINE_FULL:
    //   case LIQUIDITY_POOL_DEPOSIT_BAD_PRICE:
    //   case LIQUIDITY_POOL_DEPOSIT_POOL_FULL:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("LiquidityPoolDepositResult", {
        switchOn: xdr.lookup("LiquidityPoolDepositResultCode"),
        switchName: "code",
        switches: [
            [
                "liquidityPoolDepositSuccess",
                xdr["void"]()
            ],
            [
                "liquidityPoolDepositMalformed",
                xdr["void"]()
            ],
            [
                "liquidityPoolDepositNoTrust",
                xdr["void"]()
            ],
            [
                "liquidityPoolDepositNotAuthorized",
                xdr["void"]()
            ],
            [
                "liquidityPoolDepositUnderfunded",
                xdr["void"]()
            ],
            [
                "liquidityPoolDepositLineFull",
                xdr["void"]()
            ],
            [
                "liquidityPoolDepositBadPrice",
                xdr["void"]()
            ],
            [
                "liquidityPoolDepositPoolFull",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum LiquidityPoolWithdrawResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       LIQUIDITY_POOL_WITHDRAW_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       LIQUIDITY_POOL_WITHDRAW_MALFORMED = -1,    // bad input
    //       LIQUIDITY_POOL_WITHDRAW_NO_TRUST = -2,     // no trust line for one of the
    //                                                  // assets
    //       LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED = -3,  // not enough balance of the
    //                                                  // pool share
    //       LIQUIDITY_POOL_WITHDRAW_LINE_FULL = -4,    // would go above limit for one
    //                                                  // of the assets
    //       LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM = -5 // didn't withdraw enough
    //   };
    //
    // ===========================================================================
    xdr["enum"]("LiquidityPoolWithdrawResultCode", {
        liquidityPoolWithdrawSuccess: 0,
        liquidityPoolWithdrawMalformed: -1,
        liquidityPoolWithdrawNoTrust: -2,
        liquidityPoolWithdrawUnderfunded: -3,
        liquidityPoolWithdrawLineFull: -4,
        liquidityPoolWithdrawUnderMinimum: -5
    });
    // === xdr source ============================================================
    //
    //   union LiquidityPoolWithdrawResult switch (LiquidityPoolWithdrawResultCode code)
    //   {
    //   case LIQUIDITY_POOL_WITHDRAW_SUCCESS:
    //       void;
    //   case LIQUIDITY_POOL_WITHDRAW_MALFORMED:
    //   case LIQUIDITY_POOL_WITHDRAW_NO_TRUST:
    //   case LIQUIDITY_POOL_WITHDRAW_UNDERFUNDED:
    //   case LIQUIDITY_POOL_WITHDRAW_LINE_FULL:
    //   case LIQUIDITY_POOL_WITHDRAW_UNDER_MINIMUM:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("LiquidityPoolWithdrawResult", {
        switchOn: xdr.lookup("LiquidityPoolWithdrawResultCode"),
        switchName: "code",
        switches: [
            [
                "liquidityPoolWithdrawSuccess",
                xdr["void"]()
            ],
            [
                "liquidityPoolWithdrawMalformed",
                xdr["void"]()
            ],
            [
                "liquidityPoolWithdrawNoTrust",
                xdr["void"]()
            ],
            [
                "liquidityPoolWithdrawUnderfunded",
                xdr["void"]()
            ],
            [
                "liquidityPoolWithdrawLineFull",
                xdr["void"]()
            ],
            [
                "liquidityPoolWithdrawUnderMinimum",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum InvokeHostFunctionResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       INVOKE_HOST_FUNCTION_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       INVOKE_HOST_FUNCTION_MALFORMED = -1,
    //       INVOKE_HOST_FUNCTION_TRAPPED = -2,
    //       INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED = -3,
    //       INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED = -4,
    //       INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE = -5
    //   };
    //
    // ===========================================================================
    xdr["enum"]("InvokeHostFunctionResultCode", {
        invokeHostFunctionSuccess: 0,
        invokeHostFunctionMalformed: -1,
        invokeHostFunctionTrapped: -2,
        invokeHostFunctionResourceLimitExceeded: -3,
        invokeHostFunctionEntryArchived: -4,
        invokeHostFunctionInsufficientRefundableFee: -5
    });
    // === xdr source ============================================================
    //
    //   union InvokeHostFunctionResult switch (InvokeHostFunctionResultCode code)
    //   {
    //   case INVOKE_HOST_FUNCTION_SUCCESS:
    //       Hash success; // sha256(InvokeHostFunctionSuccessPreImage)
    //   case INVOKE_HOST_FUNCTION_MALFORMED:
    //   case INVOKE_HOST_FUNCTION_TRAPPED:
    //   case INVOKE_HOST_FUNCTION_RESOURCE_LIMIT_EXCEEDED:
    //   case INVOKE_HOST_FUNCTION_ENTRY_ARCHIVED:
    //   case INVOKE_HOST_FUNCTION_INSUFFICIENT_REFUNDABLE_FEE:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("InvokeHostFunctionResult", {
        switchOn: xdr.lookup("InvokeHostFunctionResultCode"),
        switchName: "code",
        switches: [
            [
                "invokeHostFunctionSuccess",
                "success"
            ],
            [
                "invokeHostFunctionMalformed",
                xdr["void"]()
            ],
            [
                "invokeHostFunctionTrapped",
                xdr["void"]()
            ],
            [
                "invokeHostFunctionResourceLimitExceeded",
                xdr["void"]()
            ],
            [
                "invokeHostFunctionEntryArchived",
                xdr["void"]()
            ],
            [
                "invokeHostFunctionInsufficientRefundableFee",
                xdr["void"]()
            ]
        ],
        arms: {
            success: xdr.lookup("Hash")
        }
    });
    // === xdr source ============================================================
    //
    //   enum ExtendFootprintTTLResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       EXTEND_FOOTPRINT_TTL_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       EXTEND_FOOTPRINT_TTL_MALFORMED = -1,
    //       EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED = -2,
    //       EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE = -3
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ExtendFootprintTtlResultCode", {
        extendFootprintTtlSuccess: 0,
        extendFootprintTtlMalformed: -1,
        extendFootprintTtlResourceLimitExceeded: -2,
        extendFootprintTtlInsufficientRefundableFee: -3
    });
    // === xdr source ============================================================
    //
    //   union ExtendFootprintTTLResult switch (ExtendFootprintTTLResultCode code)
    //   {
    //   case EXTEND_FOOTPRINT_TTL_SUCCESS:
    //       void;
    //   case EXTEND_FOOTPRINT_TTL_MALFORMED:
    //   case EXTEND_FOOTPRINT_TTL_RESOURCE_LIMIT_EXCEEDED:
    //   case EXTEND_FOOTPRINT_TTL_INSUFFICIENT_REFUNDABLE_FEE:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ExtendFootprintTtlResult", {
        switchOn: xdr.lookup("ExtendFootprintTtlResultCode"),
        switchName: "code",
        switches: [
            [
                "extendFootprintTtlSuccess",
                xdr["void"]()
            ],
            [
                "extendFootprintTtlMalformed",
                xdr["void"]()
            ],
            [
                "extendFootprintTtlResourceLimitExceeded",
                xdr["void"]()
            ],
            [
                "extendFootprintTtlInsufficientRefundableFee",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum RestoreFootprintResultCode
    //   {
    //       // codes considered as "success" for the operation
    //       RESTORE_FOOTPRINT_SUCCESS = 0,
    //
    //       // codes considered as "failure" for the operation
    //       RESTORE_FOOTPRINT_MALFORMED = -1,
    //       RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED = -2,
    //       RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE = -3
    //   };
    //
    // ===========================================================================
    xdr["enum"]("RestoreFootprintResultCode", {
        restoreFootprintSuccess: 0,
        restoreFootprintMalformed: -1,
        restoreFootprintResourceLimitExceeded: -2,
        restoreFootprintInsufficientRefundableFee: -3
    });
    // === xdr source ============================================================
    //
    //   union RestoreFootprintResult switch (RestoreFootprintResultCode code)
    //   {
    //   case RESTORE_FOOTPRINT_SUCCESS:
    //       void;
    //   case RESTORE_FOOTPRINT_MALFORMED:
    //   case RESTORE_FOOTPRINT_RESOURCE_LIMIT_EXCEEDED:
    //   case RESTORE_FOOTPRINT_INSUFFICIENT_REFUNDABLE_FEE:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("RestoreFootprintResult", {
        switchOn: xdr.lookup("RestoreFootprintResultCode"),
        switchName: "code",
        switches: [
            [
                "restoreFootprintSuccess",
                xdr["void"]()
            ],
            [
                "restoreFootprintMalformed",
                xdr["void"]()
            ],
            [
                "restoreFootprintResourceLimitExceeded",
                xdr["void"]()
            ],
            [
                "restoreFootprintInsufficientRefundableFee",
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum OperationResultCode
    //   {
    //       opINNER = 0, // inner object result is valid
    //
    //       opBAD_AUTH = -1,            // too few valid signatures / wrong network
    //       opNO_ACCOUNT = -2,          // source account was not found
    //       opNOT_SUPPORTED = -3,       // operation not supported at this time
    //       opTOO_MANY_SUBENTRIES = -4, // max number of subentries already reached
    //       opEXCEEDED_WORK_LIMIT = -5, // operation did too much work
    //       opTOO_MANY_SPONSORING = -6  // account is sponsoring too many entries
    //   };
    //
    // ===========================================================================
    xdr["enum"]("OperationResultCode", {
        opInner: 0,
        opBadAuth: -1,
        opNoAccount: -2,
        opNotSupported: -3,
        opTooManySubentries: -4,
        opExceededWorkLimit: -5,
        opTooManySponsoring: -6
    });
    // === xdr source ============================================================
    //
    //   union switch (OperationType type)
    //       {
    //       case CREATE_ACCOUNT:
    //           CreateAccountResult createAccountResult;
    //       case PAYMENT:
    //           PaymentResult paymentResult;
    //       case PATH_PAYMENT_STRICT_RECEIVE:
    //           PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult;
    //       case MANAGE_SELL_OFFER:
    //           ManageSellOfferResult manageSellOfferResult;
    //       case CREATE_PASSIVE_SELL_OFFER:
    //           ManageSellOfferResult createPassiveSellOfferResult;
    //       case SET_OPTIONS:
    //           SetOptionsResult setOptionsResult;
    //       case CHANGE_TRUST:
    //           ChangeTrustResult changeTrustResult;
    //       case ALLOW_TRUST:
    //           AllowTrustResult allowTrustResult;
    //       case ACCOUNT_MERGE:
    //           AccountMergeResult accountMergeResult;
    //       case INFLATION:
    //           InflationResult inflationResult;
    //       case MANAGE_DATA:
    //           ManageDataResult manageDataResult;
    //       case BUMP_SEQUENCE:
    //           BumpSequenceResult bumpSeqResult;
    //       case MANAGE_BUY_OFFER:
    //           ManageBuyOfferResult manageBuyOfferResult;
    //       case PATH_PAYMENT_STRICT_SEND:
    //           PathPaymentStrictSendResult pathPaymentStrictSendResult;
    //       case CREATE_CLAIMABLE_BALANCE:
    //           CreateClaimableBalanceResult createClaimableBalanceResult;
    //       case CLAIM_CLAIMABLE_BALANCE:
    //           ClaimClaimableBalanceResult claimClaimableBalanceResult;
    //       case BEGIN_SPONSORING_FUTURE_RESERVES:
    //           BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult;
    //       case END_SPONSORING_FUTURE_RESERVES:
    //           EndSponsoringFutureReservesResult endSponsoringFutureReservesResult;
    //       case REVOKE_SPONSORSHIP:
    //           RevokeSponsorshipResult revokeSponsorshipResult;
    //       case CLAWBACK:
    //           ClawbackResult clawbackResult;
    //       case CLAWBACK_CLAIMABLE_BALANCE:
    //           ClawbackClaimableBalanceResult clawbackClaimableBalanceResult;
    //       case SET_TRUST_LINE_FLAGS:
    //           SetTrustLineFlagsResult setTrustLineFlagsResult;
    //       case LIQUIDITY_POOL_DEPOSIT:
    //           LiquidityPoolDepositResult liquidityPoolDepositResult;
    //       case LIQUIDITY_POOL_WITHDRAW:
    //           LiquidityPoolWithdrawResult liquidityPoolWithdrawResult;
    //       case INVOKE_HOST_FUNCTION:
    //           InvokeHostFunctionResult invokeHostFunctionResult;
    //       case EXTEND_FOOTPRINT_TTL:
    //           ExtendFootprintTTLResult extendFootprintTTLResult;
    //       case RESTORE_FOOTPRINT:
    //           RestoreFootprintResult restoreFootprintResult;
    //       }
    //
    // ===========================================================================
    xdr.union("OperationResultTr", {
        switchOn: xdr.lookup("OperationType"),
        switchName: "type",
        switches: [
            [
                "createAccount",
                "createAccountResult"
            ],
            [
                "payment",
                "paymentResult"
            ],
            [
                "pathPaymentStrictReceive",
                "pathPaymentStrictReceiveResult"
            ],
            [
                "manageSellOffer",
                "manageSellOfferResult"
            ],
            [
                "createPassiveSellOffer",
                "createPassiveSellOfferResult"
            ],
            [
                "setOptions",
                "setOptionsResult"
            ],
            [
                "changeTrust",
                "changeTrustResult"
            ],
            [
                "allowTrust",
                "allowTrustResult"
            ],
            [
                "accountMerge",
                "accountMergeResult"
            ],
            [
                "inflation",
                "inflationResult"
            ],
            [
                "manageData",
                "manageDataResult"
            ],
            [
                "bumpSequence",
                "bumpSeqResult"
            ],
            [
                "manageBuyOffer",
                "manageBuyOfferResult"
            ],
            [
                "pathPaymentStrictSend",
                "pathPaymentStrictSendResult"
            ],
            [
                "createClaimableBalance",
                "createClaimableBalanceResult"
            ],
            [
                "claimClaimableBalance",
                "claimClaimableBalanceResult"
            ],
            [
                "beginSponsoringFutureReserves",
                "beginSponsoringFutureReservesResult"
            ],
            [
                "endSponsoringFutureReserves",
                "endSponsoringFutureReservesResult"
            ],
            [
                "revokeSponsorship",
                "revokeSponsorshipResult"
            ],
            [
                "clawback",
                "clawbackResult"
            ],
            [
                "clawbackClaimableBalance",
                "clawbackClaimableBalanceResult"
            ],
            [
                "setTrustLineFlags",
                "setTrustLineFlagsResult"
            ],
            [
                "liquidityPoolDeposit",
                "liquidityPoolDepositResult"
            ],
            [
                "liquidityPoolWithdraw",
                "liquidityPoolWithdrawResult"
            ],
            [
                "invokeHostFunction",
                "invokeHostFunctionResult"
            ],
            [
                "extendFootprintTtl",
                "extendFootprintTtlResult"
            ],
            [
                "restoreFootprint",
                "restoreFootprintResult"
            ]
        ],
        arms: {
            createAccountResult: xdr.lookup("CreateAccountResult"),
            paymentResult: xdr.lookup("PaymentResult"),
            pathPaymentStrictReceiveResult: xdr.lookup("PathPaymentStrictReceiveResult"),
            manageSellOfferResult: xdr.lookup("ManageSellOfferResult"),
            createPassiveSellOfferResult: xdr.lookup("ManageSellOfferResult"),
            setOptionsResult: xdr.lookup("SetOptionsResult"),
            changeTrustResult: xdr.lookup("ChangeTrustResult"),
            allowTrustResult: xdr.lookup("AllowTrustResult"),
            accountMergeResult: xdr.lookup("AccountMergeResult"),
            inflationResult: xdr.lookup("InflationResult"),
            manageDataResult: xdr.lookup("ManageDataResult"),
            bumpSeqResult: xdr.lookup("BumpSequenceResult"),
            manageBuyOfferResult: xdr.lookup("ManageBuyOfferResult"),
            pathPaymentStrictSendResult: xdr.lookup("PathPaymentStrictSendResult"),
            createClaimableBalanceResult: xdr.lookup("CreateClaimableBalanceResult"),
            claimClaimableBalanceResult: xdr.lookup("ClaimClaimableBalanceResult"),
            beginSponsoringFutureReservesResult: xdr.lookup("BeginSponsoringFutureReservesResult"),
            endSponsoringFutureReservesResult: xdr.lookup("EndSponsoringFutureReservesResult"),
            revokeSponsorshipResult: xdr.lookup("RevokeSponsorshipResult"),
            clawbackResult: xdr.lookup("ClawbackResult"),
            clawbackClaimableBalanceResult: xdr.lookup("ClawbackClaimableBalanceResult"),
            setTrustLineFlagsResult: xdr.lookup("SetTrustLineFlagsResult"),
            liquidityPoolDepositResult: xdr.lookup("LiquidityPoolDepositResult"),
            liquidityPoolWithdrawResult: xdr.lookup("LiquidityPoolWithdrawResult"),
            invokeHostFunctionResult: xdr.lookup("InvokeHostFunctionResult"),
            extendFootprintTtlResult: xdr.lookup("ExtendFootprintTtlResult"),
            restoreFootprintResult: xdr.lookup("RestoreFootprintResult")
        }
    });
    // === xdr source ============================================================
    //
    //   union OperationResult switch (OperationResultCode code)
    //   {
    //   case opINNER:
    //       union switch (OperationType type)
    //       {
    //       case CREATE_ACCOUNT:
    //           CreateAccountResult createAccountResult;
    //       case PAYMENT:
    //           PaymentResult paymentResult;
    //       case PATH_PAYMENT_STRICT_RECEIVE:
    //           PathPaymentStrictReceiveResult pathPaymentStrictReceiveResult;
    //       case MANAGE_SELL_OFFER:
    //           ManageSellOfferResult manageSellOfferResult;
    //       case CREATE_PASSIVE_SELL_OFFER:
    //           ManageSellOfferResult createPassiveSellOfferResult;
    //       case SET_OPTIONS:
    //           SetOptionsResult setOptionsResult;
    //       case CHANGE_TRUST:
    //           ChangeTrustResult changeTrustResult;
    //       case ALLOW_TRUST:
    //           AllowTrustResult allowTrustResult;
    //       case ACCOUNT_MERGE:
    //           AccountMergeResult accountMergeResult;
    //       case INFLATION:
    //           InflationResult inflationResult;
    //       case MANAGE_DATA:
    //           ManageDataResult manageDataResult;
    //       case BUMP_SEQUENCE:
    //           BumpSequenceResult bumpSeqResult;
    //       case MANAGE_BUY_OFFER:
    //           ManageBuyOfferResult manageBuyOfferResult;
    //       case PATH_PAYMENT_STRICT_SEND:
    //           PathPaymentStrictSendResult pathPaymentStrictSendResult;
    //       case CREATE_CLAIMABLE_BALANCE:
    //           CreateClaimableBalanceResult createClaimableBalanceResult;
    //       case CLAIM_CLAIMABLE_BALANCE:
    //           ClaimClaimableBalanceResult claimClaimableBalanceResult;
    //       case BEGIN_SPONSORING_FUTURE_RESERVES:
    //           BeginSponsoringFutureReservesResult beginSponsoringFutureReservesResult;
    //       case END_SPONSORING_FUTURE_RESERVES:
    //           EndSponsoringFutureReservesResult endSponsoringFutureReservesResult;
    //       case REVOKE_SPONSORSHIP:
    //           RevokeSponsorshipResult revokeSponsorshipResult;
    //       case CLAWBACK:
    //           ClawbackResult clawbackResult;
    //       case CLAWBACK_CLAIMABLE_BALANCE:
    //           ClawbackClaimableBalanceResult clawbackClaimableBalanceResult;
    //       case SET_TRUST_LINE_FLAGS:
    //           SetTrustLineFlagsResult setTrustLineFlagsResult;
    //       case LIQUIDITY_POOL_DEPOSIT:
    //           LiquidityPoolDepositResult liquidityPoolDepositResult;
    //       case LIQUIDITY_POOL_WITHDRAW:
    //           LiquidityPoolWithdrawResult liquidityPoolWithdrawResult;
    //       case INVOKE_HOST_FUNCTION:
    //           InvokeHostFunctionResult invokeHostFunctionResult;
    //       case EXTEND_FOOTPRINT_TTL:
    //           ExtendFootprintTTLResult extendFootprintTTLResult;
    //       case RESTORE_FOOTPRINT:
    //           RestoreFootprintResult restoreFootprintResult;
    //       }
    //       tr;
    //   case opBAD_AUTH:
    //   case opNO_ACCOUNT:
    //   case opNOT_SUPPORTED:
    //   case opTOO_MANY_SUBENTRIES:
    //   case opEXCEEDED_WORK_LIMIT:
    //   case opTOO_MANY_SPONSORING:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("OperationResult", {
        switchOn: xdr.lookup("OperationResultCode"),
        switchName: "code",
        switches: [
            [
                "opInner",
                "tr"
            ],
            [
                "opBadAuth",
                xdr["void"]()
            ],
            [
                "opNoAccount",
                xdr["void"]()
            ],
            [
                "opNotSupported",
                xdr["void"]()
            ],
            [
                "opTooManySubentries",
                xdr["void"]()
            ],
            [
                "opExceededWorkLimit",
                xdr["void"]()
            ],
            [
                "opTooManySponsoring",
                xdr["void"]()
            ]
        ],
        arms: {
            tr: xdr.lookup("OperationResultTr")
        }
    });
    // === xdr source ============================================================
    //
    //   enum TransactionResultCode
    //   {
    //       txFEE_BUMP_INNER_SUCCESS = 1, // fee bump inner transaction succeeded
    //       txSUCCESS = 0,                // all operations succeeded
    //
    //       txFAILED = -1, // one of the operations failed (none were applied)
    //
    //       txTOO_EARLY = -2,         // ledger closeTime before minTime
    //       txTOO_LATE = -3,          // ledger closeTime after maxTime
    //       txMISSING_OPERATION = -4, // no operation was specified
    //       txBAD_SEQ = -5,           // sequence number does not match source account
    //
    //       txBAD_AUTH = -6,             // too few valid signatures / wrong network
    //       txINSUFFICIENT_BALANCE = -7, // fee would bring account below reserve
    //       txNO_ACCOUNT = -8,           // source account not found
    //       txINSUFFICIENT_FEE = -9,     // fee is too small
    //       txBAD_AUTH_EXTRA = -10,      // unused signatures attached to transaction
    //       txINTERNAL_ERROR = -11,      // an unknown error occurred
    //
    //       txNOT_SUPPORTED = -12,          // transaction type not supported
    //       txFEE_BUMP_INNER_FAILED = -13,  // fee bump inner transaction failed
    //       txBAD_SPONSORSHIP = -14,        // sponsorship not confirmed
    //       txBAD_MIN_SEQ_AGE_OR_GAP = -15, // minSeqAge or minSeqLedgerGap conditions not met
    //       txMALFORMED = -16,              // precondition is invalid
    //       txSOROBAN_INVALID = -17         // soroban-specific preconditions were not met
    //   };
    //
    // ===========================================================================
    xdr["enum"]("TransactionResultCode", {
        txFeeBumpInnerSuccess: 1,
        txSuccess: 0,
        txFailed: -1,
        txTooEarly: -2,
        txTooLate: -3,
        txMissingOperation: -4,
        txBadSeq: -5,
        txBadAuth: -6,
        txInsufficientBalance: -7,
        txNoAccount: -8,
        txInsufficientFee: -9,
        txBadAuthExtra: -10,
        txInternalError: -11,
        txNotSupported: -12,
        txFeeBumpInnerFailed: -13,
        txBadSponsorship: -14,
        txBadMinSeqAgeOrGap: -15,
        txMalformed: -16,
        txSorobanInvalid: -17
    });
    // === xdr source ============================================================
    //
    //   union switch (TransactionResultCode code)
    //       {
    //       // txFEE_BUMP_INNER_SUCCESS is not included
    //       case txSUCCESS:
    //       case txFAILED:
    //           OperationResult results<>;
    //       case txTOO_EARLY:
    //       case txTOO_LATE:
    //       case txMISSING_OPERATION:
    //       case txBAD_SEQ:
    //       case txBAD_AUTH:
    //       case txINSUFFICIENT_BALANCE:
    //       case txNO_ACCOUNT:
    //       case txINSUFFICIENT_FEE:
    //       case txBAD_AUTH_EXTRA:
    //       case txINTERNAL_ERROR:
    //       case txNOT_SUPPORTED:
    //       // txFEE_BUMP_INNER_FAILED is not included
    //       case txBAD_SPONSORSHIP:
    //       case txBAD_MIN_SEQ_AGE_OR_GAP:
    //       case txMALFORMED:
    //       case txSOROBAN_INVALID:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("InnerTransactionResultResult", {
        switchOn: xdr.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [
            [
                "txSuccess",
                "results"
            ],
            [
                "txFailed",
                "results"
            ],
            [
                "txTooEarly",
                xdr["void"]()
            ],
            [
                "txTooLate",
                xdr["void"]()
            ],
            [
                "txMissingOperation",
                xdr["void"]()
            ],
            [
                "txBadSeq",
                xdr["void"]()
            ],
            [
                "txBadAuth",
                xdr["void"]()
            ],
            [
                "txInsufficientBalance",
                xdr["void"]()
            ],
            [
                "txNoAccount",
                xdr["void"]()
            ],
            [
                "txInsufficientFee",
                xdr["void"]()
            ],
            [
                "txBadAuthExtra",
                xdr["void"]()
            ],
            [
                "txInternalError",
                xdr["void"]()
            ],
            [
                "txNotSupported",
                xdr["void"]()
            ],
            [
                "txBadSponsorship",
                xdr["void"]()
            ],
            [
                "txBadMinSeqAgeOrGap",
                xdr["void"]()
            ],
            [
                "txMalformed",
                xdr["void"]()
            ],
            [
                "txSorobanInvalid",
                xdr["void"]()
            ]
        ],
        arms: {
            results: xdr.varArray(xdr.lookup("OperationResult"), 2147483647)
        }
    });
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("InnerTransactionResultExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct InnerTransactionResult
    //   {
    //       // Always 0. Here for binary compatibility.
    //       int64 feeCharged;
    //
    //       union switch (TransactionResultCode code)
    //       {
    //       // txFEE_BUMP_INNER_SUCCESS is not included
    //       case txSUCCESS:
    //       case txFAILED:
    //           OperationResult results<>;
    //       case txTOO_EARLY:
    //       case txTOO_LATE:
    //       case txMISSING_OPERATION:
    //       case txBAD_SEQ:
    //       case txBAD_AUTH:
    //       case txINSUFFICIENT_BALANCE:
    //       case txNO_ACCOUNT:
    //       case txINSUFFICIENT_FEE:
    //       case txBAD_AUTH_EXTRA:
    //       case txINTERNAL_ERROR:
    //       case txNOT_SUPPORTED:
    //       // txFEE_BUMP_INNER_FAILED is not included
    //       case txBAD_SPONSORSHIP:
    //       case txBAD_MIN_SEQ_AGE_OR_GAP:
    //       case txMALFORMED:
    //       case txSOROBAN_INVALID:
    //           void;
    //       }
    //       result;
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("InnerTransactionResult", [
        [
            "feeCharged",
            xdr.lookup("Int64")
        ],
        [
            "result",
            xdr.lookup("InnerTransactionResultResult")
        ],
        [
            "ext",
            xdr.lookup("InnerTransactionResultExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct InnerTransactionResultPair
    //   {
    //       Hash transactionHash;          // hash of the inner transaction
    //       InnerTransactionResult result; // result for the inner transaction
    //   };
    //
    // ===========================================================================
    xdr.struct("InnerTransactionResultPair", [
        [
            "transactionHash",
            xdr.lookup("Hash")
        ],
        [
            "result",
            xdr.lookup("InnerTransactionResult")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union switch (TransactionResultCode code)
    //       {
    //       case txFEE_BUMP_INNER_SUCCESS:
    //       case txFEE_BUMP_INNER_FAILED:
    //           InnerTransactionResultPair innerResultPair;
    //       case txSUCCESS:
    //       case txFAILED:
    //           OperationResult results<>;
    //       case txTOO_EARLY:
    //       case txTOO_LATE:
    //       case txMISSING_OPERATION:
    //       case txBAD_SEQ:
    //       case txBAD_AUTH:
    //       case txINSUFFICIENT_BALANCE:
    //       case txNO_ACCOUNT:
    //       case txINSUFFICIENT_FEE:
    //       case txBAD_AUTH_EXTRA:
    //       case txINTERNAL_ERROR:
    //       case txNOT_SUPPORTED:
    //       // case txFEE_BUMP_INNER_FAILED: handled above
    //       case txBAD_SPONSORSHIP:
    //       case txBAD_MIN_SEQ_AGE_OR_GAP:
    //       case txMALFORMED:
    //       case txSOROBAN_INVALID:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("TransactionResultResult", {
        switchOn: xdr.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [
            [
                "txFeeBumpInnerSuccess",
                "innerResultPair"
            ],
            [
                "txFeeBumpInnerFailed",
                "innerResultPair"
            ],
            [
                "txSuccess",
                "results"
            ],
            [
                "txFailed",
                "results"
            ],
            [
                "txTooEarly",
                xdr["void"]()
            ],
            [
                "txTooLate",
                xdr["void"]()
            ],
            [
                "txMissingOperation",
                xdr["void"]()
            ],
            [
                "txBadSeq",
                xdr["void"]()
            ],
            [
                "txBadAuth",
                xdr["void"]()
            ],
            [
                "txInsufficientBalance",
                xdr["void"]()
            ],
            [
                "txNoAccount",
                xdr["void"]()
            ],
            [
                "txInsufficientFee",
                xdr["void"]()
            ],
            [
                "txBadAuthExtra",
                xdr["void"]()
            ],
            [
                "txInternalError",
                xdr["void"]()
            ],
            [
                "txNotSupported",
                xdr["void"]()
            ],
            [
                "txBadSponsorship",
                xdr["void"]()
            ],
            [
                "txBadMinSeqAgeOrGap",
                xdr["void"]()
            ],
            [
                "txMalformed",
                xdr["void"]()
            ],
            [
                "txSorobanInvalid",
                xdr["void"]()
            ]
        ],
        arms: {
            innerResultPair: xdr.lookup("InnerTransactionResultPair"),
            results: xdr.varArray(xdr.lookup("OperationResult"), 2147483647)
        }
    });
    // === xdr source ============================================================
    //
    //   union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //
    // ===========================================================================
    xdr.union("TransactionResultExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   struct TransactionResult
    //   {
    //       int64 feeCharged; // actual fee charged for the transaction
    //
    //       union switch (TransactionResultCode code)
    //       {
    //       case txFEE_BUMP_INNER_SUCCESS:
    //       case txFEE_BUMP_INNER_FAILED:
    //           InnerTransactionResultPair innerResultPair;
    //       case txSUCCESS:
    //       case txFAILED:
    //           OperationResult results<>;
    //       case txTOO_EARLY:
    //       case txTOO_LATE:
    //       case txMISSING_OPERATION:
    //       case txBAD_SEQ:
    //       case txBAD_AUTH:
    //       case txINSUFFICIENT_BALANCE:
    //       case txNO_ACCOUNT:
    //       case txINSUFFICIENT_FEE:
    //       case txBAD_AUTH_EXTRA:
    //       case txINTERNAL_ERROR:
    //       case txNOT_SUPPORTED:
    //       // case txFEE_BUMP_INNER_FAILED: handled above
    //       case txBAD_SPONSORSHIP:
    //       case txBAD_MIN_SEQ_AGE_OR_GAP:
    //       case txMALFORMED:
    //       case txSOROBAN_INVALID:
    //           void;
    //       }
    //       result;
    //
    //       // reserved for future use
    //       union switch (int v)
    //       {
    //       case 0:
    //           void;
    //       }
    //       ext;
    //   };
    //
    // ===========================================================================
    xdr.struct("TransactionResult", [
        [
            "feeCharged",
            xdr.lookup("Int64")
        ],
        [
            "result",
            xdr.lookup("TransactionResultResult")
        ],
        [
            "ext",
            xdr.lookup("TransactionResultExt")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   typedef opaque Hash[32];
    //
    // ===========================================================================
    xdr.typedef("Hash", xdr.opaque(32));
    // === xdr source ============================================================
    //
    //   typedef opaque uint256[32];
    //
    // ===========================================================================
    xdr.typedef("Uint256", xdr.opaque(32));
    // === xdr source ============================================================
    //
    //   typedef unsigned int uint32;
    //
    // ===========================================================================
    xdr.typedef("Uint32", xdr.uint());
    // === xdr source ============================================================
    //
    //   typedef int int32;
    //
    // ===========================================================================
    xdr.typedef("Int32", xdr["int"]());
    // === xdr source ============================================================
    //
    //   typedef unsigned hyper uint64;
    //
    // ===========================================================================
    xdr.typedef("Uint64", xdr.uhyper());
    // === xdr source ============================================================
    //
    //   typedef hyper int64;
    //
    // ===========================================================================
    xdr.typedef("Int64", xdr.hyper());
    // === xdr source ============================================================
    //
    //   typedef uint64 TimePoint;
    //
    // ===========================================================================
    xdr.typedef("TimePoint", xdr.lookup("Uint64"));
    // === xdr source ============================================================
    //
    //   typedef uint64 Duration;
    //
    // ===========================================================================
    xdr.typedef("Duration", xdr.lookup("Uint64"));
    // === xdr source ============================================================
    //
    //   union ExtensionPoint switch (int v)
    //   {
    //   case 0:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ExtensionPoint", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [
            [
                0,
                xdr["void"]()
            ]
        ],
        arms: {}
    });
    // === xdr source ============================================================
    //
    //   enum CryptoKeyType
    //   {
    //       KEY_TYPE_ED25519 = 0,
    //       KEY_TYPE_PRE_AUTH_TX = 1,
    //       KEY_TYPE_HASH_X = 2,
    //       KEY_TYPE_ED25519_SIGNED_PAYLOAD = 3,
    //       // MUXED enum values for supported type are derived from the enum values
    //       // above by ORing them with 0x100
    //       KEY_TYPE_MUXED_ED25519 = 0x100
    //   };
    //
    // ===========================================================================
    xdr["enum"]("CryptoKeyType", {
        keyTypeEd25519: 0,
        keyTypePreAuthTx: 1,
        keyTypeHashX: 2,
        keyTypeEd25519SignedPayload: 3,
        keyTypeMuxedEd25519: 256
    });
    // === xdr source ============================================================
    //
    //   enum PublicKeyType
    //   {
    //       PUBLIC_KEY_TYPE_ED25519 = KEY_TYPE_ED25519
    //   };
    //
    // ===========================================================================
    xdr["enum"]("PublicKeyType", {
        publicKeyTypeEd25519: 0
    });
    // === xdr source ============================================================
    //
    //   enum SignerKeyType
    //   {
    //       SIGNER_KEY_TYPE_ED25519 = KEY_TYPE_ED25519,
    //       SIGNER_KEY_TYPE_PRE_AUTH_TX = KEY_TYPE_PRE_AUTH_TX,
    //       SIGNER_KEY_TYPE_HASH_X = KEY_TYPE_HASH_X,
    //       SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD = KEY_TYPE_ED25519_SIGNED_PAYLOAD
    //   };
    //
    // ===========================================================================
    xdr["enum"]("SignerKeyType", {
        signerKeyTypeEd25519: 0,
        signerKeyTypePreAuthTx: 1,
        signerKeyTypeHashX: 2,
        signerKeyTypeEd25519SignedPayload: 3
    });
    // === xdr source ============================================================
    //
    //   union PublicKey switch (PublicKeyType type)
    //   {
    //   case PUBLIC_KEY_TYPE_ED25519:
    //       uint256 ed25519;
    //   };
    //
    // ===========================================================================
    xdr.union("PublicKey", {
        switchOn: xdr.lookup("PublicKeyType"),
        switchName: "type",
        switches: [
            [
                "publicKeyTypeEd25519",
                "ed25519"
            ]
        ],
        arms: {
            ed25519: xdr.lookup("Uint256")
        }
    });
    // === xdr source ============================================================
    //
    //   struct
    //       {
    //           /* Public key that must sign the payload. */
    //           uint256 ed25519;
    //           /* Payload to be raw signed by ed25519. */
    //           opaque payload<64>;
    //       }
    //
    // ===========================================================================
    xdr.struct("SignerKeyEd25519SignedPayload", [
        [
            "ed25519",
            xdr.lookup("Uint256")
        ],
        [
            "payload",
            xdr.varOpaque(64)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union SignerKey switch (SignerKeyType type)
    //   {
    //   case SIGNER_KEY_TYPE_ED25519:
    //       uint256 ed25519;
    //   case SIGNER_KEY_TYPE_PRE_AUTH_TX:
    //       /* SHA-256 Hash of TransactionSignaturePayload structure */
    //       uint256 preAuthTx;
    //   case SIGNER_KEY_TYPE_HASH_X:
    //       /* Hash of random 256 bit preimage X */
    //       uint256 hashX;
    //   case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
    //       struct
    //       {
    //           /* Public key that must sign the payload. */
    //           uint256 ed25519;
    //           /* Payload to be raw signed by ed25519. */
    //           opaque payload<64>;
    //       } ed25519SignedPayload;
    //   };
    //
    // ===========================================================================
    xdr.union("SignerKey", {
        switchOn: xdr.lookup("SignerKeyType"),
        switchName: "type",
        switches: [
            [
                "signerKeyTypeEd25519",
                "ed25519"
            ],
            [
                "signerKeyTypePreAuthTx",
                "preAuthTx"
            ],
            [
                "signerKeyTypeHashX",
                "hashX"
            ],
            [
                "signerKeyTypeEd25519SignedPayload",
                "ed25519SignedPayload"
            ]
        ],
        arms: {
            ed25519: xdr.lookup("Uint256"),
            preAuthTx: xdr.lookup("Uint256"),
            hashX: xdr.lookup("Uint256"),
            ed25519SignedPayload: xdr.lookup("SignerKeyEd25519SignedPayload")
        }
    });
    // === xdr source ============================================================
    //
    //   typedef opaque Signature<64>;
    //
    // ===========================================================================
    xdr.typedef("Signature", xdr.varOpaque(64));
    // === xdr source ============================================================
    //
    //   typedef opaque SignatureHint[4];
    //
    // ===========================================================================
    xdr.typedef("SignatureHint", xdr.opaque(4));
    // === xdr source ============================================================
    //
    //   typedef PublicKey NodeID;
    //
    // ===========================================================================
    xdr.typedef("NodeId", xdr.lookup("PublicKey"));
    // === xdr source ============================================================
    //
    //   typedef PublicKey AccountID;
    //
    // ===========================================================================
    xdr.typedef("AccountId", xdr.lookup("PublicKey"));
    // === xdr source ============================================================
    //
    //   struct Curve25519Secret
    //   {
    //       opaque key[32];
    //   };
    //
    // ===========================================================================
    xdr.struct("Curve25519Secret", [
        [
            "key",
            xdr.opaque(32)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct Curve25519Public
    //   {
    //       opaque key[32];
    //   };
    //
    // ===========================================================================
    xdr.struct("Curve25519Public", [
        [
            "key",
            xdr.opaque(32)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct HmacSha256Key
    //   {
    //       opaque key[32];
    //   };
    //
    // ===========================================================================
    xdr.struct("HmacSha256Key", [
        [
            "key",
            xdr.opaque(32)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct HmacSha256Mac
    //   {
    //       opaque mac[32];
    //   };
    //
    // ===========================================================================
    xdr.struct("HmacSha256Mac", [
        [
            "mac",
            xdr.opaque(32)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ShortHashSeed
    //   {
    //       opaque seed[16];
    //   };
    //
    // ===========================================================================
    xdr.struct("ShortHashSeed", [
        [
            "seed",
            xdr.opaque(16)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum BinaryFuseFilterType
    //   {
    //       BINARY_FUSE_FILTER_8_BIT = 0,
    //       BINARY_FUSE_FILTER_16_BIT = 1,
    //       BINARY_FUSE_FILTER_32_BIT = 2
    //   };
    //
    // ===========================================================================
    xdr["enum"]("BinaryFuseFilterType", {
        binaryFuseFilter8Bit: 0,
        binaryFuseFilter16Bit: 1,
        binaryFuseFilter32Bit: 2
    });
    // === xdr source ============================================================
    //
    //   struct SerializedBinaryFuseFilter
    //   {
    //       BinaryFuseFilterType type;
    //
    //       // Seed used to hash input to filter
    //       ShortHashSeed inputHashSeed;
    //
    //       // Seed used for internal filter hash operations
    //       ShortHashSeed filterSeed;
    //       uint32 segmentLength;
    //       uint32 segementLengthMask;
    //       uint32 segmentCount;
    //       uint32 segmentCountLength;
    //       uint32 fingerprintLength; // Length in terms of element count, not bytes
    //
    //       // Array of uint8_t, uint16_t, or uint32_t depending on filter type
    //       opaque fingerprints<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("SerializedBinaryFuseFilter", [
        [
            "type",
            xdr.lookup("BinaryFuseFilterType")
        ],
        [
            "inputHashSeed",
            xdr.lookup("ShortHashSeed")
        ],
        [
            "filterSeed",
            xdr.lookup("ShortHashSeed")
        ],
        [
            "segmentLength",
            xdr.lookup("Uint32")
        ],
        [
            "segementLengthMask",
            xdr.lookup("Uint32")
        ],
        [
            "segmentCount",
            xdr.lookup("Uint32")
        ],
        [
            "segmentCountLength",
            xdr.lookup("Uint32")
        ],
        [
            "fingerprintLength",
            xdr.lookup("Uint32")
        ],
        [
            "fingerprints",
            xdr.varOpaque()
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum SCValType
    //   {
    //       SCV_BOOL = 0,
    //       SCV_VOID = 1,
    //       SCV_ERROR = 2,
    //
    //       // 32 bits is the smallest type in WASM or XDR; no need for u8/u16.
    //       SCV_U32 = 3,
    //       SCV_I32 = 4,
    //
    //       // 64 bits is naturally supported by both WASM and XDR also.
    //       SCV_U64 = 5,
    //       SCV_I64 = 6,
    //
    //       // Time-related u64 subtypes with their own functions and formatting.
    //       SCV_TIMEPOINT = 7,
    //       SCV_DURATION = 8,
    //
    //       // 128 bits is naturally supported by Rust and we use it for Soroban
    //       // fixed-point arithmetic prices / balances / similar "quantities". These
    //       // are represented in XDR as a pair of 2 u64s.
    //       SCV_U128 = 9,
    //       SCV_I128 = 10,
    //
    //       // 256 bits is the size of sha256 output, ed25519 keys, and the EVM machine
    //       // word, so for interop use we include this even though it requires a small
    //       // amount of Rust guest and/or host library code.
    //       SCV_U256 = 11,
    //       SCV_I256 = 12,
    //
    //       // Bytes come in 3 flavors, 2 of which have meaningfully different
    //       // formatting and validity-checking / domain-restriction.
    //       SCV_BYTES = 13,
    //       SCV_STRING = 14,
    //       SCV_SYMBOL = 15,
    //
    //       // Vecs and maps are just polymorphic containers of other ScVals.
    //       SCV_VEC = 16,
    //       SCV_MAP = 17,
    //
    //       // Address is the universal identifier for contracts and classic
    //       // accounts.
    //       SCV_ADDRESS = 18,
    //
    //       // The following are the internal SCVal variants that are not
    //       // exposed to the contracts.
    //       SCV_CONTRACT_INSTANCE = 19,
    //
    //       // SCV_LEDGER_KEY_CONTRACT_INSTANCE and SCV_LEDGER_KEY_NONCE are unique
    //       // symbolic SCVals used as the key for ledger entries for a contract's
    //       // instance and an address' nonce, respectively.
    //       SCV_LEDGER_KEY_CONTRACT_INSTANCE = 20,
    //       SCV_LEDGER_KEY_NONCE = 21
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScValType", {
        scvBool: 0,
        scvVoid: 1,
        scvError: 2,
        scvU32: 3,
        scvI32: 4,
        scvU64: 5,
        scvI64: 6,
        scvTimepoint: 7,
        scvDuration: 8,
        scvU128: 9,
        scvI128: 10,
        scvU256: 11,
        scvI256: 12,
        scvBytes: 13,
        scvString: 14,
        scvSymbol: 15,
        scvVec: 16,
        scvMap: 17,
        scvAddress: 18,
        scvContractInstance: 19,
        scvLedgerKeyContractInstance: 20,
        scvLedgerKeyNonce: 21
    });
    // === xdr source ============================================================
    //
    //   enum SCErrorType
    //   {
    //       SCE_CONTRACT = 0,          // Contract-specific, user-defined codes.
    //       SCE_WASM_VM = 1,           // Errors while interpreting WASM bytecode.
    //       SCE_CONTEXT = 2,           // Errors in the contract's host context.
    //       SCE_STORAGE = 3,           // Errors accessing host storage.
    //       SCE_OBJECT = 4,            // Errors working with host objects.
    //       SCE_CRYPTO = 5,            // Errors in cryptographic operations.
    //       SCE_EVENTS = 6,            // Errors while emitting events.
    //       SCE_BUDGET = 7,            // Errors relating to budget limits.
    //       SCE_VALUE = 8,             // Errors working with host values or SCVals.
    //       SCE_AUTH = 9               // Errors from the authentication subsystem.
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScErrorType", {
        sceContract: 0,
        sceWasmVm: 1,
        sceContext: 2,
        sceStorage: 3,
        sceObject: 4,
        sceCrypto: 5,
        sceEvents: 6,
        sceBudget: 7,
        sceValue: 8,
        sceAuth: 9
    });
    // === xdr source ============================================================
    //
    //   enum SCErrorCode
    //   {
    //       SCEC_ARITH_DOMAIN = 0,      // Some arithmetic was undefined (overflow, divide-by-zero).
    //       SCEC_INDEX_BOUNDS = 1,      // Something was indexed beyond its bounds.
    //       SCEC_INVALID_INPUT = 2,     // User provided some otherwise-bad data.
    //       SCEC_MISSING_VALUE = 3,     // Some value was required but not provided.
    //       SCEC_EXISTING_VALUE = 4,    // Some value was provided where not allowed.
    //       SCEC_EXCEEDED_LIMIT = 5,    // Some arbitrary limit -- gas or otherwise -- was hit.
    //       SCEC_INVALID_ACTION = 6,    // Data was valid but action requested was not.
    //       SCEC_INTERNAL_ERROR = 7,    // The host detected an error in its own logic.
    //       SCEC_UNEXPECTED_TYPE = 8,   // Some type wasn't as expected.
    //       SCEC_UNEXPECTED_SIZE = 9    // Something's size wasn't as expected.
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScErrorCode", {
        scecArithDomain: 0,
        scecIndexBounds: 1,
        scecInvalidInput: 2,
        scecMissingValue: 3,
        scecExistingValue: 4,
        scecExceededLimit: 5,
        scecInvalidAction: 6,
        scecInternalError: 7,
        scecUnexpectedType: 8,
        scecUnexpectedSize: 9
    });
    // === xdr source ============================================================
    //
    //   union SCError switch (SCErrorType type)
    //   {
    //   case SCE_CONTRACT:
    //       uint32 contractCode;
    //   case SCE_WASM_VM:
    //   case SCE_CONTEXT:
    //   case SCE_STORAGE:
    //   case SCE_OBJECT:
    //   case SCE_CRYPTO:
    //   case SCE_EVENTS:
    //   case SCE_BUDGET:
    //   case SCE_VALUE:
    //   case SCE_AUTH:
    //       SCErrorCode code;
    //   };
    //
    // ===========================================================================
    xdr.union("ScError", {
        switchOn: xdr.lookup("ScErrorType"),
        switchName: "type",
        switches: [
            [
                "sceContract",
                "contractCode"
            ],
            [
                "sceWasmVm",
                "code"
            ],
            [
                "sceContext",
                "code"
            ],
            [
                "sceStorage",
                "code"
            ],
            [
                "sceObject",
                "code"
            ],
            [
                "sceCrypto",
                "code"
            ],
            [
                "sceEvents",
                "code"
            ],
            [
                "sceBudget",
                "code"
            ],
            [
                "sceValue",
                "code"
            ],
            [
                "sceAuth",
                "code"
            ]
        ],
        arms: {
            contractCode: xdr.lookup("Uint32"),
            code: xdr.lookup("ScErrorCode")
        }
    });
    // === xdr source ============================================================
    //
    //   struct UInt128Parts {
    //       uint64 hi;
    //       uint64 lo;
    //   };
    //
    // ===========================================================================
    xdr.struct("UInt128Parts", [
        [
            "hi",
            xdr.lookup("Uint64")
        ],
        [
            "lo",
            xdr.lookup("Uint64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct Int128Parts {
    //       int64 hi;
    //       uint64 lo;
    //   };
    //
    // ===========================================================================
    xdr.struct("Int128Parts", [
        [
            "hi",
            xdr.lookup("Int64")
        ],
        [
            "lo",
            xdr.lookup("Uint64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct UInt256Parts {
    //       uint64 hi_hi;
    //       uint64 hi_lo;
    //       uint64 lo_hi;
    //       uint64 lo_lo;
    //   };
    //
    // ===========================================================================
    xdr.struct("UInt256Parts", [
        [
            "hiHi",
            xdr.lookup("Uint64")
        ],
        [
            "hiLo",
            xdr.lookup("Uint64")
        ],
        [
            "loHi",
            xdr.lookup("Uint64")
        ],
        [
            "loLo",
            xdr.lookup("Uint64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct Int256Parts {
    //       int64 hi_hi;
    //       uint64 hi_lo;
    //       uint64 lo_hi;
    //       uint64 lo_lo;
    //   };
    //
    // ===========================================================================
    xdr.struct("Int256Parts", [
        [
            "hiHi",
            xdr.lookup("Int64")
        ],
        [
            "hiLo",
            xdr.lookup("Uint64")
        ],
        [
            "loHi",
            xdr.lookup("Uint64")
        ],
        [
            "loLo",
            xdr.lookup("Uint64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum ContractExecutableType
    //   {
    //       CONTRACT_EXECUTABLE_WASM = 0,
    //       CONTRACT_EXECUTABLE_STELLAR_ASSET = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ContractExecutableType", {
        contractExecutableWasm: 0,
        contractExecutableStellarAsset: 1
    });
    // === xdr source ============================================================
    //
    //   union ContractExecutable switch (ContractExecutableType type)
    //   {
    //   case CONTRACT_EXECUTABLE_WASM:
    //       Hash wasm_hash;
    //   case CONTRACT_EXECUTABLE_STELLAR_ASSET:
    //       void;
    //   };
    //
    // ===========================================================================
    xdr.union("ContractExecutable", {
        switchOn: xdr.lookup("ContractExecutableType"),
        switchName: "type",
        switches: [
            [
                "contractExecutableWasm",
                "wasmHash"
            ],
            [
                "contractExecutableStellarAsset",
                xdr["void"]()
            ]
        ],
        arms: {
            wasmHash: xdr.lookup("Hash")
        }
    });
    // === xdr source ============================================================
    //
    //   enum SCAddressType
    //   {
    //       SC_ADDRESS_TYPE_ACCOUNT = 0,
    //       SC_ADDRESS_TYPE_CONTRACT = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScAddressType", {
        scAddressTypeAccount: 0,
        scAddressTypeContract: 1
    });
    // === xdr source ============================================================
    //
    //   union SCAddress switch (SCAddressType type)
    //   {
    //   case SC_ADDRESS_TYPE_ACCOUNT:
    //       AccountID accountId;
    //   case SC_ADDRESS_TYPE_CONTRACT:
    //       Hash contractId;
    //   };
    //
    // ===========================================================================
    xdr.union("ScAddress", {
        switchOn: xdr.lookup("ScAddressType"),
        switchName: "type",
        switches: [
            [
                "scAddressTypeAccount",
                "accountId"
            ],
            [
                "scAddressTypeContract",
                "contractId"
            ]
        ],
        arms: {
            accountId: xdr.lookup("AccountId"),
            contractId: xdr.lookup("Hash")
        }
    });
    // === xdr source ============================================================
    //
    //   const SCSYMBOL_LIMIT = 32;
    //
    // ===========================================================================
    xdr["const"]("SCSYMBOL_LIMIT", 32);
    // === xdr source ============================================================
    //
    //   typedef SCVal SCVec<>;
    //
    // ===========================================================================
    xdr.typedef("ScVec", xdr.varArray(xdr.lookup("ScVal"), 2147483647));
    // === xdr source ============================================================
    //
    //   typedef SCMapEntry SCMap<>;
    //
    // ===========================================================================
    xdr.typedef("ScMap", xdr.varArray(xdr.lookup("ScMapEntry"), 2147483647));
    // === xdr source ============================================================
    //
    //   typedef opaque SCBytes<>;
    //
    // ===========================================================================
    xdr.typedef("ScBytes", xdr.varOpaque());
    // === xdr source ============================================================
    //
    //   typedef string SCString<>;
    //
    // ===========================================================================
    xdr.typedef("ScString", xdr.string());
    // === xdr source ============================================================
    //
    //   typedef string SCSymbol<SCSYMBOL_LIMIT>;
    //
    // ===========================================================================
    xdr.typedef("ScSymbol", xdr.string(SCSYMBOL_LIMIT));
    // === xdr source ============================================================
    //
    //   struct SCNonceKey {
    //       int64 nonce;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScNonceKey", [
        [
            "nonce",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCContractInstance {
    //       ContractExecutable executable;
    //       SCMap* storage;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScContractInstance", [
        [
            "executable",
            xdr.lookup("ContractExecutable")
        ],
        [
            "storage",
            xdr.option(xdr.lookup("ScMap"))
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union SCVal switch (SCValType type)
    //   {
    //
    //   case SCV_BOOL:
    //       bool b;
    //   case SCV_VOID:
    //       void;
    //   case SCV_ERROR:
    //       SCError error;
    //
    //   case SCV_U32:
    //       uint32 u32;
    //   case SCV_I32:
    //       int32 i32;
    //
    //   case SCV_U64:
    //       uint64 u64;
    //   case SCV_I64:
    //       int64 i64;
    //   case SCV_TIMEPOINT:
    //       TimePoint timepoint;
    //   case SCV_DURATION:
    //       Duration duration;
    //
    //   case SCV_U128:
    //       UInt128Parts u128;
    //   case SCV_I128:
    //       Int128Parts i128;
    //
    //   case SCV_U256:
    //       UInt256Parts u256;
    //   case SCV_I256:
    //       Int256Parts i256;
    //
    //   case SCV_BYTES:
    //       SCBytes bytes;
    //   case SCV_STRING:
    //       SCString str;
    //   case SCV_SYMBOL:
    //       SCSymbol sym;
    //
    //   // Vec and Map are recursive so need to live
    //   // behind an option, due to xdrpp limitations.
    //   case SCV_VEC:
    //       SCVec *vec;
    //   case SCV_MAP:
    //       SCMap *map;
    //
    //   case SCV_ADDRESS:
    //       SCAddress address;
    //
    //   // Special SCVals reserved for system-constructed contract-data
    //   // ledger keys, not generally usable elsewhere.
    //   case SCV_LEDGER_KEY_CONTRACT_INSTANCE:
    //       void;
    //   case SCV_LEDGER_KEY_NONCE:
    //       SCNonceKey nonce_key;
    //
    //   case SCV_CONTRACT_INSTANCE:
    //       SCContractInstance instance;
    //   };
    //
    // ===========================================================================
    xdr.union("ScVal", {
        switchOn: xdr.lookup("ScValType"),
        switchName: "type",
        switches: [
            [
                "scvBool",
                "b"
            ],
            [
                "scvVoid",
                xdr["void"]()
            ],
            [
                "scvError",
                "error"
            ],
            [
                "scvU32",
                "u32"
            ],
            [
                "scvI32",
                "i32"
            ],
            [
                "scvU64",
                "u64"
            ],
            [
                "scvI64",
                "i64"
            ],
            [
                "scvTimepoint",
                "timepoint"
            ],
            [
                "scvDuration",
                "duration"
            ],
            [
                "scvU128",
                "u128"
            ],
            [
                "scvI128",
                "i128"
            ],
            [
                "scvU256",
                "u256"
            ],
            [
                "scvI256",
                "i256"
            ],
            [
                "scvBytes",
                "bytes"
            ],
            [
                "scvString",
                "str"
            ],
            [
                "scvSymbol",
                "sym"
            ],
            [
                "scvVec",
                "vec"
            ],
            [
                "scvMap",
                "map"
            ],
            [
                "scvAddress",
                "address"
            ],
            [
                "scvLedgerKeyContractInstance",
                xdr["void"]()
            ],
            [
                "scvLedgerKeyNonce",
                "nonceKey"
            ],
            [
                "scvContractInstance",
                "instance"
            ]
        ],
        arms: {
            b: xdr.bool(),
            error: xdr.lookup("ScError"),
            u32: xdr.lookup("Uint32"),
            i32: xdr.lookup("Int32"),
            u64: xdr.lookup("Uint64"),
            i64: xdr.lookup("Int64"),
            timepoint: xdr.lookup("TimePoint"),
            duration: xdr.lookup("Duration"),
            u128: xdr.lookup("UInt128Parts"),
            i128: xdr.lookup("Int128Parts"),
            u256: xdr.lookup("UInt256Parts"),
            i256: xdr.lookup("Int256Parts"),
            bytes: xdr.lookup("ScBytes"),
            str: xdr.lookup("ScString"),
            sym: xdr.lookup("ScSymbol"),
            vec: xdr.option(xdr.lookup("ScVec")),
            map: xdr.option(xdr.lookup("ScMap")),
            address: xdr.lookup("ScAddress"),
            nonceKey: xdr.lookup("ScNonceKey"),
            instance: xdr.lookup("ScContractInstance")
        }
    });
    // === xdr source ============================================================
    //
    //   struct SCMapEntry
    //   {
    //       SCVal key;
    //       SCVal val;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScMapEntry", [
        [
            "key",
            xdr.lookup("ScVal")
        ],
        [
            "val",
            xdr.lookup("ScVal")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum SCEnvMetaKind
    //   {
    //       SC_ENV_META_KIND_INTERFACE_VERSION = 0
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScEnvMetaKind", {
        scEnvMetaKindInterfaceVersion: 0
    });
    // === xdr source ============================================================
    //
    //   struct {
    //           uint32 protocol;
    //           uint32 preRelease;
    //       }
    //
    // ===========================================================================
    xdr.struct("ScEnvMetaEntryInterfaceVersion", [
        [
            "protocol",
            xdr.lookup("Uint32")
        ],
        [
            "preRelease",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union SCEnvMetaEntry switch (SCEnvMetaKind kind)
    //   {
    //   case SC_ENV_META_KIND_INTERFACE_VERSION:
    //       struct {
    //           uint32 protocol;
    //           uint32 preRelease;
    //       } interfaceVersion;
    //   };
    //
    // ===========================================================================
    xdr.union("ScEnvMetaEntry", {
        switchOn: xdr.lookup("ScEnvMetaKind"),
        switchName: "kind",
        switches: [
            [
                "scEnvMetaKindInterfaceVersion",
                "interfaceVersion"
            ]
        ],
        arms: {
            interfaceVersion: xdr.lookup("ScEnvMetaEntryInterfaceVersion")
        }
    });
    // === xdr source ============================================================
    //
    //   struct SCMetaV0
    //   {
    //       string key<>;
    //       string val<>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScMetaV0", [
        [
            "key",
            xdr.string()
        ],
        [
            "val",
            xdr.string()
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum SCMetaKind
    //   {
    //       SC_META_V0 = 0
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScMetaKind", {
        scMetaV0: 0
    });
    // === xdr source ============================================================
    //
    //   union SCMetaEntry switch (SCMetaKind kind)
    //   {
    //   case SC_META_V0:
    //       SCMetaV0 v0;
    //   };
    //
    // ===========================================================================
    xdr.union("ScMetaEntry", {
        switchOn: xdr.lookup("ScMetaKind"),
        switchName: "kind",
        switches: [
            [
                "scMetaV0",
                "v0"
            ]
        ],
        arms: {
            v0: xdr.lookup("ScMetaV0")
        }
    });
    // === xdr source ============================================================
    //
    //   const SC_SPEC_DOC_LIMIT = 1024;
    //
    // ===========================================================================
    xdr["const"]("SC_SPEC_DOC_LIMIT", 1024);
    // === xdr source ============================================================
    //
    //   enum SCSpecType
    //   {
    //       SC_SPEC_TYPE_VAL = 0,
    //
    //       // Types with no parameters.
    //       SC_SPEC_TYPE_BOOL = 1,
    //       SC_SPEC_TYPE_VOID = 2,
    //       SC_SPEC_TYPE_ERROR = 3,
    //       SC_SPEC_TYPE_U32 = 4,
    //       SC_SPEC_TYPE_I32 = 5,
    //       SC_SPEC_TYPE_U64 = 6,
    //       SC_SPEC_TYPE_I64 = 7,
    //       SC_SPEC_TYPE_TIMEPOINT = 8,
    //       SC_SPEC_TYPE_DURATION = 9,
    //       SC_SPEC_TYPE_U128 = 10,
    //       SC_SPEC_TYPE_I128 = 11,
    //       SC_SPEC_TYPE_U256 = 12,
    //       SC_SPEC_TYPE_I256 = 13,
    //       SC_SPEC_TYPE_BYTES = 14,
    //       SC_SPEC_TYPE_STRING = 16,
    //       SC_SPEC_TYPE_SYMBOL = 17,
    //       SC_SPEC_TYPE_ADDRESS = 19,
    //
    //       // Types with parameters.
    //       SC_SPEC_TYPE_OPTION = 1000,
    //       SC_SPEC_TYPE_RESULT = 1001,
    //       SC_SPEC_TYPE_VEC = 1002,
    //       SC_SPEC_TYPE_MAP = 1004,
    //       SC_SPEC_TYPE_TUPLE = 1005,
    //       SC_SPEC_TYPE_BYTES_N = 1006,
    //
    //       // User defined types.
    //       SC_SPEC_TYPE_UDT = 2000
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScSpecType", {
        scSpecTypeVal: 0,
        scSpecTypeBool: 1,
        scSpecTypeVoid: 2,
        scSpecTypeError: 3,
        scSpecTypeU32: 4,
        scSpecTypeI32: 5,
        scSpecTypeU64: 6,
        scSpecTypeI64: 7,
        scSpecTypeTimepoint: 8,
        scSpecTypeDuration: 9,
        scSpecTypeU128: 10,
        scSpecTypeI128: 11,
        scSpecTypeU256: 12,
        scSpecTypeI256: 13,
        scSpecTypeBytes: 14,
        scSpecTypeString: 16,
        scSpecTypeSymbol: 17,
        scSpecTypeAddress: 19,
        scSpecTypeOption: 1000,
        scSpecTypeResult: 1001,
        scSpecTypeVec: 1002,
        scSpecTypeMap: 1004,
        scSpecTypeTuple: 1005,
        scSpecTypeBytesN: 1006,
        scSpecTypeUdt: 2000
    });
    // === xdr source ============================================================
    //
    //   struct SCSpecTypeOption
    //   {
    //       SCSpecTypeDef valueType;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecTypeOption", [
        [
            "valueType",
            xdr.lookup("ScSpecTypeDef")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecTypeResult
    //   {
    //       SCSpecTypeDef okType;
    //       SCSpecTypeDef errorType;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecTypeResult", [
        [
            "okType",
            xdr.lookup("ScSpecTypeDef")
        ],
        [
            "errorType",
            xdr.lookup("ScSpecTypeDef")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecTypeVec
    //   {
    //       SCSpecTypeDef elementType;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecTypeVec", [
        [
            "elementType",
            xdr.lookup("ScSpecTypeDef")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecTypeMap
    //   {
    //       SCSpecTypeDef keyType;
    //       SCSpecTypeDef valueType;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecTypeMap", [
        [
            "keyType",
            xdr.lookup("ScSpecTypeDef")
        ],
        [
            "valueType",
            xdr.lookup("ScSpecTypeDef")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecTypeTuple
    //   {
    //       SCSpecTypeDef valueTypes<12>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecTypeTuple", [
        [
            "valueTypes",
            xdr.varArray(xdr.lookup("ScSpecTypeDef"), 12)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecTypeBytesN
    //   {
    //       uint32 n;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecTypeBytesN", [
        [
            "n",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecTypeUDT
    //   {
    //       string name<60>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecTypeUdt", [
        [
            "name",
            xdr.string(60)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   union SCSpecTypeDef switch (SCSpecType type)
    //   {
    //   case SC_SPEC_TYPE_VAL:
    //   case SC_SPEC_TYPE_BOOL:
    //   case SC_SPEC_TYPE_VOID:
    //   case SC_SPEC_TYPE_ERROR:
    //   case SC_SPEC_TYPE_U32:
    //   case SC_SPEC_TYPE_I32:
    //   case SC_SPEC_TYPE_U64:
    //   case SC_SPEC_TYPE_I64:
    //   case SC_SPEC_TYPE_TIMEPOINT:
    //   case SC_SPEC_TYPE_DURATION:
    //   case SC_SPEC_TYPE_U128:
    //   case SC_SPEC_TYPE_I128:
    //   case SC_SPEC_TYPE_U256:
    //   case SC_SPEC_TYPE_I256:
    //   case SC_SPEC_TYPE_BYTES:
    //   case SC_SPEC_TYPE_STRING:
    //   case SC_SPEC_TYPE_SYMBOL:
    //   case SC_SPEC_TYPE_ADDRESS:
    //       void;
    //   case SC_SPEC_TYPE_OPTION:
    //       SCSpecTypeOption option;
    //   case SC_SPEC_TYPE_RESULT:
    //       SCSpecTypeResult result;
    //   case SC_SPEC_TYPE_VEC:
    //       SCSpecTypeVec vec;
    //   case SC_SPEC_TYPE_MAP:
    //       SCSpecTypeMap map;
    //   case SC_SPEC_TYPE_TUPLE:
    //       SCSpecTypeTuple tuple;
    //   case SC_SPEC_TYPE_BYTES_N:
    //       SCSpecTypeBytesN bytesN;
    //   case SC_SPEC_TYPE_UDT:
    //       SCSpecTypeUDT udt;
    //   };
    //
    // ===========================================================================
    xdr.union("ScSpecTypeDef", {
        switchOn: xdr.lookup("ScSpecType"),
        switchName: "type",
        switches: [
            [
                "scSpecTypeVal",
                xdr["void"]()
            ],
            [
                "scSpecTypeBool",
                xdr["void"]()
            ],
            [
                "scSpecTypeVoid",
                xdr["void"]()
            ],
            [
                "scSpecTypeError",
                xdr["void"]()
            ],
            [
                "scSpecTypeU32",
                xdr["void"]()
            ],
            [
                "scSpecTypeI32",
                xdr["void"]()
            ],
            [
                "scSpecTypeU64",
                xdr["void"]()
            ],
            [
                "scSpecTypeI64",
                xdr["void"]()
            ],
            [
                "scSpecTypeTimepoint",
                xdr["void"]()
            ],
            [
                "scSpecTypeDuration",
                xdr["void"]()
            ],
            [
                "scSpecTypeU128",
                xdr["void"]()
            ],
            [
                "scSpecTypeI128",
                xdr["void"]()
            ],
            [
                "scSpecTypeU256",
                xdr["void"]()
            ],
            [
                "scSpecTypeI256",
                xdr["void"]()
            ],
            [
                "scSpecTypeBytes",
                xdr["void"]()
            ],
            [
                "scSpecTypeString",
                xdr["void"]()
            ],
            [
                "scSpecTypeSymbol",
                xdr["void"]()
            ],
            [
                "scSpecTypeAddress",
                xdr["void"]()
            ],
            [
                "scSpecTypeOption",
                "option"
            ],
            [
                "scSpecTypeResult",
                "result"
            ],
            [
                "scSpecTypeVec",
                "vec"
            ],
            [
                "scSpecTypeMap",
                "map"
            ],
            [
                "scSpecTypeTuple",
                "tuple"
            ],
            [
                "scSpecTypeBytesN",
                "bytesN"
            ],
            [
                "scSpecTypeUdt",
                "udt"
            ]
        ],
        arms: {
            option: xdr.lookup("ScSpecTypeOption"),
            result: xdr.lookup("ScSpecTypeResult"),
            vec: xdr.lookup("ScSpecTypeVec"),
            map: xdr.lookup("ScSpecTypeMap"),
            tuple: xdr.lookup("ScSpecTypeTuple"),
            bytesN: xdr.lookup("ScSpecTypeBytesN"),
            udt: xdr.lookup("ScSpecTypeUdt")
        }
    });
    // === xdr source ============================================================
    //
    //   struct SCSpecUDTStructFieldV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string name<30>;
    //       SCSpecTypeDef type;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecUdtStructFieldV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "name",
            xdr.string(30)
        ],
        [
            "type",
            xdr.lookup("ScSpecTypeDef")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecUDTStructV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string lib<80>;
    //       string name<60>;
    //       SCSpecUDTStructFieldV0 fields<40>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecUdtStructV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "lib",
            xdr.string(80)
        ],
        [
            "name",
            xdr.string(60)
        ],
        [
            "fields",
            xdr.varArray(xdr.lookup("ScSpecUdtStructFieldV0"), 40)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecUDTUnionCaseVoidV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string name<60>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecUdtUnionCaseVoidV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "name",
            xdr.string(60)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecUDTUnionCaseTupleV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string name<60>;
    //       SCSpecTypeDef type<12>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecUdtUnionCaseTupleV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "name",
            xdr.string(60)
        ],
        [
            "type",
            xdr.varArray(xdr.lookup("ScSpecTypeDef"), 12)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum SCSpecUDTUnionCaseV0Kind
    //   {
    //       SC_SPEC_UDT_UNION_CASE_VOID_V0 = 0,
    //       SC_SPEC_UDT_UNION_CASE_TUPLE_V0 = 1
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScSpecUdtUnionCaseV0Kind", {
        scSpecUdtUnionCaseVoidV0: 0,
        scSpecUdtUnionCaseTupleV0: 1
    });
    // === xdr source ============================================================
    //
    //   union SCSpecUDTUnionCaseV0 switch (SCSpecUDTUnionCaseV0Kind kind)
    //   {
    //   case SC_SPEC_UDT_UNION_CASE_VOID_V0:
    //       SCSpecUDTUnionCaseVoidV0 voidCase;
    //   case SC_SPEC_UDT_UNION_CASE_TUPLE_V0:
    //       SCSpecUDTUnionCaseTupleV0 tupleCase;
    //   };
    //
    // ===========================================================================
    xdr.union("ScSpecUdtUnionCaseV0", {
        switchOn: xdr.lookup("ScSpecUdtUnionCaseV0Kind"),
        switchName: "kind",
        switches: [
            [
                "scSpecUdtUnionCaseVoidV0",
                "voidCase"
            ],
            [
                "scSpecUdtUnionCaseTupleV0",
                "tupleCase"
            ]
        ],
        arms: {
            voidCase: xdr.lookup("ScSpecUdtUnionCaseVoidV0"),
            tupleCase: xdr.lookup("ScSpecUdtUnionCaseTupleV0")
        }
    });
    // === xdr source ============================================================
    //
    //   struct SCSpecUDTUnionV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string lib<80>;
    //       string name<60>;
    //       SCSpecUDTUnionCaseV0 cases<50>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecUdtUnionV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "lib",
            xdr.string(80)
        ],
        [
            "name",
            xdr.string(60)
        ],
        [
            "cases",
            xdr.varArray(xdr.lookup("ScSpecUdtUnionCaseV0"), 50)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecUDTEnumCaseV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string name<60>;
    //       uint32 value;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecUdtEnumCaseV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "name",
            xdr.string(60)
        ],
        [
            "value",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecUDTEnumV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string lib<80>;
    //       string name<60>;
    //       SCSpecUDTEnumCaseV0 cases<50>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecUdtEnumV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "lib",
            xdr.string(80)
        ],
        [
            "name",
            xdr.string(60)
        ],
        [
            "cases",
            xdr.varArray(xdr.lookup("ScSpecUdtEnumCaseV0"), 50)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecUDTErrorEnumCaseV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string name<60>;
    //       uint32 value;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecUdtErrorEnumCaseV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "name",
            xdr.string(60)
        ],
        [
            "value",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecUDTErrorEnumV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string lib<80>;
    //       string name<60>;
    //       SCSpecUDTErrorEnumCaseV0 cases<50>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecUdtErrorEnumV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "lib",
            xdr.string(80)
        ],
        [
            "name",
            xdr.string(60)
        ],
        [
            "cases",
            xdr.varArray(xdr.lookup("ScSpecUdtErrorEnumCaseV0"), 50)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecFunctionInputV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       string name<30>;
    //       SCSpecTypeDef type;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecFunctionInputV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "name",
            xdr.string(30)
        ],
        [
            "type",
            xdr.lookup("ScSpecTypeDef")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct SCSpecFunctionV0
    //   {
    //       string doc<SC_SPEC_DOC_LIMIT>;
    //       SCSymbol name;
    //       SCSpecFunctionInputV0 inputs<10>;
    //       SCSpecTypeDef outputs<1>;
    //   };
    //
    // ===========================================================================
    xdr.struct("ScSpecFunctionV0", [
        [
            "doc",
            xdr.string(SC_SPEC_DOC_LIMIT)
        ],
        [
            "name",
            xdr.lookup("ScSymbol")
        ],
        [
            "inputs",
            xdr.varArray(xdr.lookup("ScSpecFunctionInputV0"), 10)
        ],
        [
            "outputs",
            xdr.varArray(xdr.lookup("ScSpecTypeDef"), 1)
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum SCSpecEntryKind
    //   {
    //       SC_SPEC_ENTRY_FUNCTION_V0 = 0,
    //       SC_SPEC_ENTRY_UDT_STRUCT_V0 = 1,
    //       SC_SPEC_ENTRY_UDT_UNION_V0 = 2,
    //       SC_SPEC_ENTRY_UDT_ENUM_V0 = 3,
    //       SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0 = 4
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ScSpecEntryKind", {
        scSpecEntryFunctionV0: 0,
        scSpecEntryUdtStructV0: 1,
        scSpecEntryUdtUnionV0: 2,
        scSpecEntryUdtEnumV0: 3,
        scSpecEntryUdtErrorEnumV0: 4
    });
    // === xdr source ============================================================
    //
    //   union SCSpecEntry switch (SCSpecEntryKind kind)
    //   {
    //   case SC_SPEC_ENTRY_FUNCTION_V0:
    //       SCSpecFunctionV0 functionV0;
    //   case SC_SPEC_ENTRY_UDT_STRUCT_V0:
    //       SCSpecUDTStructV0 udtStructV0;
    //   case SC_SPEC_ENTRY_UDT_UNION_V0:
    //       SCSpecUDTUnionV0 udtUnionV0;
    //   case SC_SPEC_ENTRY_UDT_ENUM_V0:
    //       SCSpecUDTEnumV0 udtEnumV0;
    //   case SC_SPEC_ENTRY_UDT_ERROR_ENUM_V0:
    //       SCSpecUDTErrorEnumV0 udtErrorEnumV0;
    //   };
    //
    // ===========================================================================
    xdr.union("ScSpecEntry", {
        switchOn: xdr.lookup("ScSpecEntryKind"),
        switchName: "kind",
        switches: [
            [
                "scSpecEntryFunctionV0",
                "functionV0"
            ],
            [
                "scSpecEntryUdtStructV0",
                "udtStructV0"
            ],
            [
                "scSpecEntryUdtUnionV0",
                "udtUnionV0"
            ],
            [
                "scSpecEntryUdtEnumV0",
                "udtEnumV0"
            ],
            [
                "scSpecEntryUdtErrorEnumV0",
                "udtErrorEnumV0"
            ]
        ],
        arms: {
            functionV0: xdr.lookup("ScSpecFunctionV0"),
            udtStructV0: xdr.lookup("ScSpecUdtStructV0"),
            udtUnionV0: xdr.lookup("ScSpecUdtUnionV0"),
            udtEnumV0: xdr.lookup("ScSpecUdtEnumV0"),
            udtErrorEnumV0: xdr.lookup("ScSpecUdtErrorEnumV0")
        }
    });
    // === xdr source ============================================================
    //
    //   struct ConfigSettingContractExecutionLanesV0
    //   {
    //       // maximum number of Soroban transactions per ledger
    //       uint32 ledgerMaxTxCount;
    //   };
    //
    // ===========================================================================
    xdr.struct("ConfigSettingContractExecutionLanesV0", [
        [
            "ledgerMaxTxCount",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ConfigSettingContractComputeV0
    //   {
    //       // Maximum instructions per ledger
    //       int64 ledgerMaxInstructions;
    //       // Maximum instructions per transaction
    //       int64 txMaxInstructions;
    //       // Cost of 10000 instructions
    //       int64 feeRatePerInstructionsIncrement;
    //
    //       // Memory limit per transaction. Unlike instructions, there is no fee
    //       // for memory, just the limit.
    //       uint32 txMemoryLimit;
    //   };
    //
    // ===========================================================================
    xdr.struct("ConfigSettingContractComputeV0", [
        [
            "ledgerMaxInstructions",
            xdr.lookup("Int64")
        ],
        [
            "txMaxInstructions",
            xdr.lookup("Int64")
        ],
        [
            "feeRatePerInstructionsIncrement",
            xdr.lookup("Int64")
        ],
        [
            "txMemoryLimit",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ConfigSettingContractLedgerCostV0
    //   {
    //       // Maximum number of ledger entry read operations per ledger
    //       uint32 ledgerMaxReadLedgerEntries;
    //       // Maximum number of bytes that can be read per ledger
    //       uint32 ledgerMaxReadBytes;
    //       // Maximum number of ledger entry write operations per ledger
    //       uint32 ledgerMaxWriteLedgerEntries;
    //       // Maximum number of bytes that can be written per ledger
    //       uint32 ledgerMaxWriteBytes;
    //
    //       // Maximum number of ledger entry read operations per transaction
    //       uint32 txMaxReadLedgerEntries;
    //       // Maximum number of bytes that can be read per transaction
    //       uint32 txMaxReadBytes;
    //       // Maximum number of ledger entry write operations per transaction
    //       uint32 txMaxWriteLedgerEntries;
    //       // Maximum number of bytes that can be written per transaction
    //       uint32 txMaxWriteBytes;
    //
    //       int64 feeReadLedgerEntry;  // Fee per ledger entry read
    //       int64 feeWriteLedgerEntry; // Fee per ledger entry write
    //
    //       int64 feeRead1KB;  // Fee for reading 1KB
    //
    //       // The following parameters determine the write fee per 1KB.
    //       // Write fee grows linearly until bucket list reaches this size
    //       int64 bucketListTargetSizeBytes;
    //       // Fee per 1KB write when the bucket list is empty
    //       int64 writeFee1KBBucketListLow;
    //       // Fee per 1KB write when the bucket list has reached `bucketListTargetSizeBytes`
    //       int64 writeFee1KBBucketListHigh;
    //       // Write fee multiplier for any additional data past the first `bucketListTargetSizeBytes`
    //       uint32 bucketListWriteFeeGrowthFactor;
    //   };
    //
    // ===========================================================================
    xdr.struct("ConfigSettingContractLedgerCostV0", [
        [
            "ledgerMaxReadLedgerEntries",
            xdr.lookup("Uint32")
        ],
        [
            "ledgerMaxReadBytes",
            xdr.lookup("Uint32")
        ],
        [
            "ledgerMaxWriteLedgerEntries",
            xdr.lookup("Uint32")
        ],
        [
            "ledgerMaxWriteBytes",
            xdr.lookup("Uint32")
        ],
        [
            "txMaxReadLedgerEntries",
            xdr.lookup("Uint32")
        ],
        [
            "txMaxReadBytes",
            xdr.lookup("Uint32")
        ],
        [
            "txMaxWriteLedgerEntries",
            xdr.lookup("Uint32")
        ],
        [
            "txMaxWriteBytes",
            xdr.lookup("Uint32")
        ],
        [
            "feeReadLedgerEntry",
            xdr.lookup("Int64")
        ],
        [
            "feeWriteLedgerEntry",
            xdr.lookup("Int64")
        ],
        [
            "feeRead1Kb",
            xdr.lookup("Int64")
        ],
        [
            "bucketListTargetSizeBytes",
            xdr.lookup("Int64")
        ],
        [
            "writeFee1KbBucketListLow",
            xdr.lookup("Int64")
        ],
        [
            "writeFee1KbBucketListHigh",
            xdr.lookup("Int64")
        ],
        [
            "bucketListWriteFeeGrowthFactor",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ConfigSettingContractHistoricalDataV0
    //   {
    //       int64 feeHistorical1KB; // Fee for storing 1KB in archives
    //   };
    //
    // ===========================================================================
    xdr.struct("ConfigSettingContractHistoricalDataV0", [
        [
            "feeHistorical1Kb",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ConfigSettingContractEventsV0
    //   {
    //       // Maximum size of events that a contract call can emit.
    //       uint32 txMaxContractEventsSizeBytes;
    //       // Fee for generating 1KB of contract events.
    //       int64 feeContractEvents1KB;
    //   };
    //
    // ===========================================================================
    xdr.struct("ConfigSettingContractEventsV0", [
        [
            "txMaxContractEventsSizeBytes",
            xdr.lookup("Uint32")
        ],
        [
            "feeContractEvents1Kb",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct ConfigSettingContractBandwidthV0
    //   {
    //       // Maximum sum of all transaction sizes in the ledger in bytes
    //       uint32 ledgerMaxTxsSizeBytes;
    //       // Maximum size in bytes for a transaction
    //       uint32 txMaxSizeBytes;
    //
    //       // Fee for 1 KB of transaction size
    //       int64 feeTxSize1KB;
    //   };
    //
    // ===========================================================================
    xdr.struct("ConfigSettingContractBandwidthV0", [
        [
            "ledgerMaxTxsSizeBytes",
            xdr.lookup("Uint32")
        ],
        [
            "txMaxSizeBytes",
            xdr.lookup("Uint32")
        ],
        [
            "feeTxSize1Kb",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   enum ContractCostType {
    //       // Cost of running 1 wasm instruction
    //       WasmInsnExec = 0,
    //       // Cost of allocating a slice of memory (in bytes)
    //       MemAlloc = 1,
    //       // Cost of copying a slice of bytes into a pre-allocated memory
    //       MemCpy = 2,
    //       // Cost of comparing two slices of memory
    //       MemCmp = 3,
    //       // Cost of a host function dispatch, not including the actual work done by
    //       // the function nor the cost of VM invocation machinary
    //       DispatchHostFunction = 4,
    //       // Cost of visiting a host object from the host object storage. Exists to
    //       // make sure some baseline cost coverage, i.e. repeatly visiting objects
    //       // by the guest will always incur some charges.
    //       VisitObject = 5,
    //       // Cost of serializing an xdr object to bytes
    //       ValSer = 6,
    //       // Cost of deserializing an xdr object from bytes
    //       ValDeser = 7,
    //       // Cost of computing the sha256 hash from bytes
    //       ComputeSha256Hash = 8,
    //       // Cost of computing the ed25519 pubkey from bytes
    //       ComputeEd25519PubKey = 9,
    //       // Cost of verifying ed25519 signature of a payload.
    //       VerifyEd25519Sig = 10,
    //       // Cost of instantiation a VM from wasm bytes code.
    //       VmInstantiation = 11,
    //       // Cost of instantiation a VM from a cached state.
    //       VmCachedInstantiation = 12,
    //       // Cost of invoking a function on the VM. If the function is a host function,
    //       // additional cost will be covered by `DispatchHostFunction`.
    //       InvokeVmFunction = 13,
    //       // Cost of computing a keccak256 hash from bytes.
    //       ComputeKeccak256Hash = 14,
    //       // Cost of decoding an ECDSA signature computed from a 256-bit prime modulus
    //       // curve (e.g. secp256k1 and secp256r1)
    //       DecodeEcdsaCurve256Sig = 15,
    //       // Cost of recovering an ECDSA secp256k1 key from a signature.
    //       RecoverEcdsaSecp256k1Key = 16,
    //       // Cost of int256 addition (`+`) and subtraction (`-`) operations
    //       Int256AddSub = 17,
    //       // Cost of int256 multiplication (`*`) operation
    //       Int256Mul = 18,
    //       // Cost of int256 division (`/`) operation
    //       Int256Div = 19,
    //       // Cost of int256 power (`exp`) operation
    //       Int256Pow = 20,
    //       // Cost of int256 shift (`shl`, `shr`) operation
    //       Int256Shift = 21,
    //       // Cost of drawing random bytes using a ChaCha20 PRNG
    //       ChaCha20DrawBytes = 22,
    //
    //       // Cost of parsing wasm bytes that only encode instructions.
    //       ParseWasmInstructions = 23,
    //       // Cost of parsing a known number of wasm functions.
    //       ParseWasmFunctions = 24,
    //       // Cost of parsing a known number of wasm globals.
    //       ParseWasmGlobals = 25,
    //       // Cost of parsing a known number of wasm table entries.
    //       ParseWasmTableEntries = 26,
    //       // Cost of parsing a known number of wasm types.
    //       ParseWasmTypes = 27,
    //       // Cost of parsing a known number of wasm data segments.
    //       ParseWasmDataSegments = 28,
    //       // Cost of parsing a known number of wasm element segments.
    //       ParseWasmElemSegments = 29,
    //       // Cost of parsing a known number of wasm imports.
    //       ParseWasmImports = 30,
    //       // Cost of parsing a known number of wasm exports.
    //       ParseWasmExports = 31,
    //       // Cost of parsing a known number of data segment bytes.
    //       ParseWasmDataSegmentBytes = 32,
    //
    //       // Cost of instantiating wasm bytes that only encode instructions.
    //       InstantiateWasmInstructions = 33,
    //       // Cost of instantiating a known number of wasm functions.
    //       InstantiateWasmFunctions = 34,
    //       // Cost of instantiating a known number of wasm globals.
    //       InstantiateWasmGlobals = 35,
    //       // Cost of instantiating a known number of wasm table entries.
    //       InstantiateWasmTableEntries = 36,
    //       // Cost of instantiating a known number of wasm types.
    //       InstantiateWasmTypes = 37,
    //       // Cost of instantiating a known number of wasm data segments.
    //       InstantiateWasmDataSegments = 38,
    //       // Cost of instantiating a known number of wasm element segments.
    //       InstantiateWasmElemSegments = 39,
    //       // Cost of instantiating a known number of wasm imports.
    //       InstantiateWasmImports = 40,
    //       // Cost of instantiating a known number of wasm exports.
    //       InstantiateWasmExports = 41,
    //       // Cost of instantiating a known number of data segment bytes.
    //       InstantiateWasmDataSegmentBytes = 42,
    //
    //       // Cost of decoding a bytes array representing an uncompressed SEC-1 encoded
    //       // point on a 256-bit elliptic curve
    //       Sec1DecodePointUncompressed = 43,
    //       // Cost of verifying an ECDSA Secp256r1 signature
    //       VerifyEcdsaSecp256r1Sig = 44,
    //
    //       // Cost of encoding a BLS12-381 Fp (base field element)
    //       Bls12381EncodeFp = 45,
    //       // Cost of decoding a BLS12-381 Fp (base field element)
    //       Bls12381DecodeFp = 46,
    //       // Cost of checking a G1 point lies on the curve
    //       Bls12381G1CheckPointOnCurve = 47,
    //       // Cost of checking a G1 point belongs to the correct subgroup
    //       Bls12381G1CheckPointInSubgroup = 48,
    //       // Cost of checking a G2 point lies on the curve
    //       Bls12381G2CheckPointOnCurve = 49,
    //       // Cost of checking a G2 point belongs to the correct subgroup
    //       Bls12381G2CheckPointInSubgroup = 50,
    //       // Cost of converting a BLS12-381 G1 point from projective to affine coordinates
    //       Bls12381G1ProjectiveToAffine = 51,
    //       // Cost of converting a BLS12-381 G2 point from projective to affine coordinates
    //       Bls12381G2ProjectiveToAffine = 52,
    //       // Cost of performing BLS12-381 G1 point addition
    //       Bls12381G1Add = 53,
    //       // Cost of performing BLS12-381 G1 scalar multiplication
    //       Bls12381G1Mul = 54,
    //       // Cost of performing BLS12-381 G1 multi-scalar multiplication (MSM)
    //       Bls12381G1Msm = 55,
    //       // Cost of mapping a BLS12-381 Fp field element to a G1 point
    //       Bls12381MapFpToG1 = 56,
    //       // Cost of hashing to a BLS12-381 G1 point
    //       Bls12381HashToG1 = 57,
    //       // Cost of performing BLS12-381 G2 point addition
    //       Bls12381G2Add = 58,
    //       // Cost of performing BLS12-381 G2 scalar multiplication
    //       Bls12381G2Mul = 59,
    //       // Cost of performing BLS12-381 G2 multi-scalar multiplication (MSM)
    //       Bls12381G2Msm = 60,
    //       // Cost of mapping a BLS12-381 Fp2 field element to a G2 point
    //       Bls12381MapFp2ToG2 = 61,
    //       // Cost of hashing to a BLS12-381 G2 point
    //       Bls12381HashToG2 = 62,
    //       // Cost of performing BLS12-381 pairing operation
    //       Bls12381Pairing = 63,
    //       // Cost of converting a BLS12-381 scalar element from U256
    //       Bls12381FrFromU256 = 64,
    //       // Cost of converting a BLS12-381 scalar element to U256
    //       Bls12381FrToU256 = 65,
    //       // Cost of performing BLS12-381 scalar element addition/subtraction
    //       Bls12381FrAddSub = 66,
    //       // Cost of performing BLS12-381 scalar element multiplication
    //       Bls12381FrMul = 67,
    //       // Cost of performing BLS12-381 scalar element exponentiation
    //       Bls12381FrPow = 68,
    //       // Cost of performing BLS12-381 scalar element inversion
    //       Bls12381FrInv = 69
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ContractCostType", {
        wasmInsnExec: 0,
        memAlloc: 1,
        memCpy: 2,
        memCmp: 3,
        dispatchHostFunction: 4,
        visitObject: 5,
        valSer: 6,
        valDeser: 7,
        computeSha256Hash: 8,
        computeEd25519PubKey: 9,
        verifyEd25519Sig: 10,
        vmInstantiation: 11,
        vmCachedInstantiation: 12,
        invokeVmFunction: 13,
        computeKeccak256Hash: 14,
        decodeEcdsaCurve256Sig: 15,
        recoverEcdsaSecp256k1Key: 16,
        int256AddSub: 17,
        int256Mul: 18,
        int256Div: 19,
        int256Pow: 20,
        int256Shift: 21,
        chaCha20DrawBytes: 22,
        parseWasmInstructions: 23,
        parseWasmFunctions: 24,
        parseWasmGlobals: 25,
        parseWasmTableEntries: 26,
        parseWasmTypes: 27,
        parseWasmDataSegments: 28,
        parseWasmElemSegments: 29,
        parseWasmImports: 30,
        parseWasmExports: 31,
        parseWasmDataSegmentBytes: 32,
        instantiateWasmInstructions: 33,
        instantiateWasmFunctions: 34,
        instantiateWasmGlobals: 35,
        instantiateWasmTableEntries: 36,
        instantiateWasmTypes: 37,
        instantiateWasmDataSegments: 38,
        instantiateWasmElemSegments: 39,
        instantiateWasmImports: 40,
        instantiateWasmExports: 41,
        instantiateWasmDataSegmentBytes: 42,
        sec1DecodePointUncompressed: 43,
        verifyEcdsaSecp256r1Sig: 44,
        bls12381EncodeFp: 45,
        bls12381DecodeFp: 46,
        bls12381G1CheckPointOnCurve: 47,
        bls12381G1CheckPointInSubgroup: 48,
        bls12381G2CheckPointOnCurve: 49,
        bls12381G2CheckPointInSubgroup: 50,
        bls12381G1ProjectiveToAffine: 51,
        bls12381G2ProjectiveToAffine: 52,
        bls12381G1Add: 53,
        bls12381G1Mul: 54,
        bls12381G1Msm: 55,
        bls12381MapFpToG1: 56,
        bls12381HashToG1: 57,
        bls12381G2Add: 58,
        bls12381G2Mul: 59,
        bls12381G2Msm: 60,
        bls12381MapFp2ToG2: 61,
        bls12381HashToG2: 62,
        bls12381Pairing: 63,
        bls12381FrFromU256: 64,
        bls12381FrToU256: 65,
        bls12381FrAddSub: 66,
        bls12381FrMul: 67,
        bls12381FrPow: 68,
        bls12381FrInv: 69
    });
    // === xdr source ============================================================
    //
    //   struct ContractCostParamEntry {
    //       // use `ext` to add more terms (e.g. higher order polynomials) in the future
    //       ExtensionPoint ext;
    //
    //       int64 constTerm;
    //       int64 linearTerm;
    //   };
    //
    // ===========================================================================
    xdr.struct("ContractCostParamEntry", [
        [
            "ext",
            xdr.lookup("ExtensionPoint")
        ],
        [
            "constTerm",
            xdr.lookup("Int64")
        ],
        [
            "linearTerm",
            xdr.lookup("Int64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct StateArchivalSettings {
    //       uint32 maxEntryTTL;
    //       uint32 minTemporaryTTL;
    //       uint32 minPersistentTTL;
    //
    //       // rent_fee = wfee_rate_average / rent_rate_denominator_for_type
    //       int64 persistentRentRateDenominator;
    //       int64 tempRentRateDenominator;
    //
    //       // max number of entries that emit archival meta in a single ledger
    //       uint32 maxEntriesToArchive;
    //
    //       // Number of snapshots to use when calculating average BucketList size
    //       uint32 bucketListSizeWindowSampleSize;
    //
    //       // How often to sample the BucketList size for the average, in ledgers
    //       uint32 bucketListWindowSamplePeriod;
    //
    //       // Maximum number of bytes that we scan for eviction per ledger
    //       uint32 evictionScanSize;
    //
    //       // Lowest BucketList level to be scanned to evict entries
    //       uint32 startingEvictionScanLevel;
    //   };
    //
    // ===========================================================================
    xdr.struct("StateArchivalSettings", [
        [
            "maxEntryTtl",
            xdr.lookup("Uint32")
        ],
        [
            "minTemporaryTtl",
            xdr.lookup("Uint32")
        ],
        [
            "minPersistentTtl",
            xdr.lookup("Uint32")
        ],
        [
            "persistentRentRateDenominator",
            xdr.lookup("Int64")
        ],
        [
            "tempRentRateDenominator",
            xdr.lookup("Int64")
        ],
        [
            "maxEntriesToArchive",
            xdr.lookup("Uint32")
        ],
        [
            "bucketListSizeWindowSampleSize",
            xdr.lookup("Uint32")
        ],
        [
            "bucketListWindowSamplePeriod",
            xdr.lookup("Uint32")
        ],
        [
            "evictionScanSize",
            xdr.lookup("Uint32")
        ],
        [
            "startingEvictionScanLevel",
            xdr.lookup("Uint32")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   struct EvictionIterator {
    //       uint32 bucketListLevel;
    //       bool isCurrBucket;
    //       uint64 bucketFileOffset;
    //   };
    //
    // ===========================================================================
    xdr.struct("EvictionIterator", [
        [
            "bucketListLevel",
            xdr.lookup("Uint32")
        ],
        [
            "isCurrBucket",
            xdr.bool()
        ],
        [
            "bucketFileOffset",
            xdr.lookup("Uint64")
        ]
    ]);
    // === xdr source ============================================================
    //
    //   const CONTRACT_COST_COUNT_LIMIT = 1024;
    //
    // ===========================================================================
    xdr["const"]("CONTRACT_COST_COUNT_LIMIT", 1024);
    // === xdr source ============================================================
    //
    //   typedef ContractCostParamEntry ContractCostParams<CONTRACT_COST_COUNT_LIMIT>;
    //
    // ===========================================================================
    xdr.typedef("ContractCostParams", xdr.varArray(xdr.lookup("ContractCostParamEntry"), xdr.lookup("CONTRACT_COST_COUNT_LIMIT")));
    // === xdr source ============================================================
    //
    //   enum ConfigSettingID
    //   {
    //       CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES = 0,
    //       CONFIG_SETTING_CONTRACT_COMPUTE_V0 = 1,
    //       CONFIG_SETTING_CONTRACT_LEDGER_COST_V0 = 2,
    //       CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0 = 3,
    //       CONFIG_SETTING_CONTRACT_EVENTS_V0 = 4,
    //       CONFIG_SETTING_CONTRACT_BANDWIDTH_V0 = 5,
    //       CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS = 6,
    //       CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES = 7,
    //       CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES = 8,
    //       CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES = 9,
    //       CONFIG_SETTING_STATE_ARCHIVAL = 10,
    //       CONFIG_SETTING_CONTRACT_EXECUTION_LANES = 11,
    //       CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW = 12,
    //       CONFIG_SETTING_EVICTION_ITERATOR = 13
    //   };
    //
    // ===========================================================================
    xdr["enum"]("ConfigSettingId", {
        configSettingContractMaxSizeBytes: 0,
        configSettingContractComputeV0: 1,
        configSettingContractLedgerCostV0: 2,
        configSettingContractHistoricalDataV0: 3,
        configSettingContractEventsV0: 4,
        configSettingContractBandwidthV0: 5,
        configSettingContractCostParamsCpuInstructions: 6,
        configSettingContractCostParamsMemoryBytes: 7,
        configSettingContractDataKeySizeBytes: 8,
        configSettingContractDataEntrySizeBytes: 9,
        configSettingStateArchival: 10,
        configSettingContractExecutionLanes: 11,
        configSettingBucketlistSizeWindow: 12,
        configSettingEvictionIterator: 13
    });
    // === xdr source ============================================================
    //
    //   union ConfigSettingEntry switch (ConfigSettingID configSettingID)
    //   {
    //   case CONFIG_SETTING_CONTRACT_MAX_SIZE_BYTES:
    //       uint32 contractMaxSizeBytes;
    //   case CONFIG_SETTING_CONTRACT_COMPUTE_V0:
    //       ConfigSettingContractComputeV0 contractCompute;
    //   case CONFIG_SETTING_CONTRACT_LEDGER_COST_V0:
    //       ConfigSettingContractLedgerCostV0 contractLedgerCost;
    //   case CONFIG_SETTING_CONTRACT_HISTORICAL_DATA_V0:
    //       ConfigSettingContractHistoricalDataV0 contractHistoricalData;
    //   case CONFIG_SETTING_CONTRACT_EVENTS_V0:
    //       ConfigSettingContractEventsV0 contractEvents;
    //   case CONFIG_SETTING_CONTRACT_BANDWIDTH_V0:
    //       ConfigSettingContractBandwidthV0 contractBandwidth;
    //   case CONFIG_SETTING_CONTRACT_COST_PARAMS_CPU_INSTRUCTIONS:
    //       ContractCostParams contractCostParamsCpuInsns;
    //   case CONFIG_SETTING_CONTRACT_COST_PARAMS_MEMORY_BYTES:
    //       ContractCostParams contractCostParamsMemBytes;
    //   case CONFIG_SETTING_CONTRACT_DATA_KEY_SIZE_BYTES:
    //       uint32 contractDataKeySizeBytes;
    //   case CONFIG_SETTING_CONTRACT_DATA_ENTRY_SIZE_BYTES:
    //       uint32 contractDataEntrySizeBytes;
    //   case CONFIG_SETTING_STATE_ARCHIVAL:
    //       StateArchivalSettings stateArchivalSettings;
    //   case CONFIG_SETTING_CONTRACT_EXECUTION_LANES:
    //       ConfigSettingContractExecutionLanesV0 contractExecutionLanes;
    //   case CONFIG_SETTING_BUCKETLIST_SIZE_WINDOW:
    //       uint64 bucketListSizeWindow<>;
    //   case CONFIG_SETTING_EVICTION_ITERATOR:
    //       EvictionIterator evictionIterator;
    //   };
    //
    // ===========================================================================
    xdr.union("ConfigSettingEntry", {
        switchOn: xdr.lookup("ConfigSettingId"),
        switchName: "configSettingId",
        switches: [
            [
                "configSettingContractMaxSizeBytes",
                "contractMaxSizeBytes"
            ],
            [
                "configSettingContractComputeV0",
                "contractCompute"
            ],
            [
                "configSettingContractLedgerCostV0",
                "contractLedgerCost"
            ],
            [
                "configSettingContractHistoricalDataV0",
                "contractHistoricalData"
            ],
            [
                "configSettingContractEventsV0",
                "contractEvents"
            ],
            [
                "configSettingContractBandwidthV0",
                "contractBandwidth"
            ],
            [
                "configSettingContractCostParamsCpuInstructions",
                "contractCostParamsCpuInsns"
            ],
            [
                "configSettingContractCostParamsMemoryBytes",
                "contractCostParamsMemBytes"
            ],
            [
                "configSettingContractDataKeySizeBytes",
                "contractDataKeySizeBytes"
            ],
            [
                "configSettingContractDataEntrySizeBytes",
                "contractDataEntrySizeBytes"
            ],
            [
                "configSettingStateArchival",
                "stateArchivalSettings"
            ],
            [
                "configSettingContractExecutionLanes",
                "contractExecutionLanes"
            ],
            [
                "configSettingBucketlistSizeWindow",
                "bucketListSizeWindow"
            ],
            [
                "configSettingEvictionIterator",
                "evictionIterator"
            ]
        ],
        arms: {
            contractMaxSizeBytes: xdr.lookup("Uint32"),
            contractCompute: xdr.lookup("ConfigSettingContractComputeV0"),
            contractLedgerCost: xdr.lookup("ConfigSettingContractLedgerCostV0"),
            contractHistoricalData: xdr.lookup("ConfigSettingContractHistoricalDataV0"),
            contractEvents: xdr.lookup("ConfigSettingContractEventsV0"),
            contractBandwidth: xdr.lookup("ConfigSettingContractBandwidthV0"),
            contractCostParamsCpuInsns: xdr.lookup("ContractCostParams"),
            contractCostParamsMemBytes: xdr.lookup("ContractCostParams"),
            contractDataKeySizeBytes: xdr.lookup("Uint32"),
            contractDataEntrySizeBytes: xdr.lookup("Uint32"),
            stateArchivalSettings: xdr.lookup("StateArchivalSettings"),
            contractExecutionLanes: xdr.lookup("ConfigSettingContractExecutionLanesV0"),
            bucketListSizeWindow: xdr.varArray(xdr.lookup("Uint64"), 2147483647),
            evictionIterator: xdr.lookup("EvictionIterator")
        }
    });
});
var _default = exports["default"] = types;
}}),
"[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _curr_generated = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
var _default = exports["default"] = _curr_generated["default"];
}}),
"[project]/node_modules/@stellar/stellar-base/lib/jsxdr.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var cereal = {
    XdrWriter: _jsXdr.XdrWriter,
    XdrReader: _jsXdr.XdrReader
};
var _default = exports["default"] = cereal;
}}),
"[project]/node_modules/@stellar/stellar-base/lib/hashing.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hash = hash;
var _sha = __turbopack_context__.r("[project]/node_modules/sha.js/index.js [app-ssr] (ecmascript)");
function hash(data) {
    var hasher = new _sha.sha256();
    hasher.update(data, 'utf8');
    return hasher.digest();
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/signing.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FastSigning = void 0;
exports.generate = generate;
exports.sign = sign;
exports.verify = verify;
//  This module provides the signing functionality used by the stellar network
//  The code below may look a little strange... this is because we try to provide
//  the most efficient signing method possible.  First, we try to load the
//  native `sodium-native` package for node.js environments, and if that fails we
//  fallback to `tweetnacl`
var actualMethods = {};
/**
 * Use this flag to check if fast signing (provided by `sodium-native` package) is available.
 * If your app is signing a large number of transaction or verifying a large number
 * of signatures make sure `sodium-native` package is installed.
 */ var FastSigning = exports.FastSigning = checkFastSigning();
function sign(data, secretKey) {
    return actualMethods.sign(data, secretKey);
}
function verify(data, signature, publicKey) {
    return actualMethods.verify(data, signature, publicKey);
}
function generate(secretKey) {
    return actualMethods.generate(secretKey);
}
function checkFastSigning() {
    return typeof window === 'undefined' ? checkFastSigningNode() : checkFastSigningBrowser();
}
function checkFastSigningNode() {
    // NOTE: we use commonjs style require here because es6 imports
    // can only occur at the top level.  thanks, obama.
    var sodium;
    try {
        // eslint-disable-next-line
        sodium = __turbopack_context__.r("[project]/node_modules/sodium-native/index.js [app-ssr] (ecmascript)");
    } catch (err) {
        return checkFastSigningBrowser();
    }
    if (!Object.keys(sodium).length) {
        return checkFastSigningBrowser();
    }
    actualMethods.generate = function(secretKey) {
        var pk = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);
        var sk = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);
        sodium.crypto_sign_seed_keypair(pk, sk, secretKey);
        return pk;
    };
    actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        var signature = Buffer.alloc(sodium.crypto_sign_BYTES);
        sodium.crypto_sign_detached(signature, data, secretKey);
        return signature;
    };
    actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        try {
            return sodium.crypto_sign_verify_detached(signature, data, publicKey);
        } catch (e) {
            return false;
        }
    };
    return true;
}
function checkFastSigningBrowser() {
    // fallback to `tweetnacl` if we're in the browser or
    // if there was a failure installing `sodium-native`
    // eslint-disable-next-line
    var nacl = __turbopack_context__.r("[project]/node_modules/tweetnacl/nacl-fast.js [app-ssr] (ecmascript)");
    actualMethods.generate = function(secretKey) {
        var secretKeyUint8 = new Uint8Array(secretKey);
        var naclKeys = nacl.sign.keyPair.fromSeed(secretKeyUint8);
        return Buffer.from(naclKeys.publicKey);
    };
    actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        secretKey = new Uint8Array(secretKey.toJSON().data);
        var signature = nacl.sign.detached(data, secretKey);
        return Buffer.from(signature);
    };
    actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        signature = new Uint8Array(signature.toJSON().data);
        publicKey = new Uint8Array(publicKey.toJSON().data);
        return nacl.sign.detached.verify(data, signature, publicKey);
    };
    return false;
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/util/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.trimEnd = void 0;
var trimEnd = exports.trimEnd = function trimEnd(input, _char) {
    var isNumber = typeof input === 'number';
    var str = String(input);
    while(str.endsWith(_char)){
        str = str.slice(0, -1);
    }
    return isNumber ? Number(str) : str;
};
}}),
"[project]/node_modules/@stellar/stellar-base/lib/util/checksum.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifyChecksum = verifyChecksum;
function verifyChecksum(expected, actual) {
    if (expected.length !== actual.length) {
        return false;
    }
    if (expected.length === 0) {
        return true;
    }
    for(var i = 0; i < expected.length; i += 1){
        if (expected[i] !== actual[i]) {
            return false;
        }
    }
    return true;
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StrKey = void 0;
exports.decodeCheck = decodeCheck;
exports.encodeCheck = encodeCheck;
var _base = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/base32.js/index.js [app-ssr] (ecmascript)"));
var _checksum = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/checksum.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
} /* eslint no-bitwise: ["error", {"allow": ["<<", ">>", "^", "&", "&="]}] */ 
var versionBytes = {
    ed25519PublicKey: 6 << 3,
    // G (when encoded in base32)
    ed25519SecretSeed: 18 << 3,
    // S
    med25519PublicKey: 12 << 3,
    // M
    preAuthTx: 19 << 3,
    // T
    sha256Hash: 23 << 3,
    // X
    signedPayload: 15 << 3,
    // P
    contract: 2 << 3 // C
};
var strkeyTypes = {
    G: 'ed25519PublicKey',
    S: 'ed25519SecretSeed',
    M: 'med25519PublicKey',
    T: 'preAuthTx',
    X: 'sha256Hash',
    P: 'signedPayload',
    C: 'contract'
};
/**
 * StrKey is a helper class that allows encoding and decoding Stellar keys
 * to/from strings, i.e. between their binary (Buffer, xdr.PublicKey, etc.) and
 * string (i.e. "GABCD...", etc.) representations.
 */ var StrKey = exports.StrKey = /*#__PURE__*/ function() {
    function StrKey() {
        _classCallCheck(this, StrKey);
    }
    return _createClass(StrKey, null, [
        {
            key: "encodeEd25519PublicKey",
            value: /**
     * Encodes `data` to strkey ed25519 public key.
     *
     * @param   {Buffer} data   raw data to encode
     * @returns {string}        "G..." representation of the key
     */ function encodeEd25519PublicKey(data) {
                return encodeCheck('ed25519PublicKey', data);
            }
        },
        {
            key: "decodeEd25519PublicKey",
            value: function decodeEd25519PublicKey(data) {
                return decodeCheck('ed25519PublicKey', data);
            }
        },
        {
            key: "isValidEd25519PublicKey",
            value: function isValidEd25519PublicKey(publicKey) {
                return isValid('ed25519PublicKey', publicKey);
            }
        },
        {
            key: "encodeEd25519SecretSeed",
            value: function encodeEd25519SecretSeed(data) {
                return encodeCheck('ed25519SecretSeed', data);
            }
        },
        {
            key: "decodeEd25519SecretSeed",
            value: function decodeEd25519SecretSeed(address) {
                return decodeCheck('ed25519SecretSeed', address);
            }
        },
        {
            key: "isValidEd25519SecretSeed",
            value: function isValidEd25519SecretSeed(seed) {
                return isValid('ed25519SecretSeed', seed);
            }
        },
        {
            key: "encodeMed25519PublicKey",
            value: function encodeMed25519PublicKey(data) {
                return encodeCheck('med25519PublicKey', data);
            }
        },
        {
            key: "decodeMed25519PublicKey",
            value: function decodeMed25519PublicKey(address) {
                return decodeCheck('med25519PublicKey', address);
            }
        },
        {
            key: "isValidMed25519PublicKey",
            value: function isValidMed25519PublicKey(publicKey) {
                return isValid('med25519PublicKey', publicKey);
            }
        },
        {
            key: "encodePreAuthTx",
            value: function encodePreAuthTx(data) {
                return encodeCheck('preAuthTx', data);
            }
        },
        {
            key: "decodePreAuthTx",
            value: function decodePreAuthTx(address) {
                return decodeCheck('preAuthTx', address);
            }
        },
        {
            key: "encodeSha256Hash",
            value: function encodeSha256Hash(data) {
                return encodeCheck('sha256Hash', data);
            }
        },
        {
            key: "decodeSha256Hash",
            value: function decodeSha256Hash(address) {
                return decodeCheck('sha256Hash', address);
            }
        },
        {
            key: "encodeSignedPayload",
            value: function encodeSignedPayload(data) {
                return encodeCheck('signedPayload', data);
            }
        },
        {
            key: "decodeSignedPayload",
            value: function decodeSignedPayload(address) {
                return decodeCheck('signedPayload', address);
            }
        },
        {
            key: "isValidSignedPayload",
            value: function isValidSignedPayload(address) {
                return isValid('signedPayload', address);
            }
        },
        {
            key: "encodeContract",
            value: function encodeContract(data) {
                return encodeCheck('contract', data);
            }
        },
        {
            key: "decodeContract",
            value: function decodeContract(address) {
                return decodeCheck('contract', address);
            }
        },
        {
            key: "isValidContract",
            value: function isValidContract(address) {
                return isValid('contract', address);
            }
        },
        {
            key: "getVersionByteForPrefix",
            value: function getVersionByteForPrefix(address) {
                return strkeyTypes[address[0]];
            }
        }
    ]);
}();
/**
 * Sanity-checks whether or not a strkey *appears* valid.
 *
 * @param  {string}  versionByteName the type of strkey to expect in `encoded`
 * @param  {string}  encoded         the strkey to validate
 *
 * @return {Boolean} whether or not the `encoded` strkey appears valid for the
 *     `versionByteName` strkey type (see `versionBytes`, above).
 *
 * @note This isn't a *definitive* check of validity, but rather a best-effort
 *     check based on (a) input length, (b) whether or not it can be decoded,
 *     and (c) output length.
 */ function isValid(versionByteName, encoded) {
    if (typeof encoded !== 'string') {
        return false;
    }
    // basic length checks on the strkey lengths
    switch(versionByteName){
        case 'ed25519PublicKey':
        case 'ed25519SecretSeed':
        case 'preAuthTx':
        case 'sha256Hash':
        case 'contract':
            if (encoded.length !== 56) {
                return false;
            }
            break;
        case 'med25519PublicKey':
            if (encoded.length !== 69) {
                return false;
            }
            break;
        case 'signedPayload':
            if (encoded.length < 56 || encoded.length > 165) {
                return false;
            }
            break;
        default:
            return false;
    }
    var decoded = '';
    try {
        decoded = decodeCheck(versionByteName, encoded);
    } catch (err) {
        return false;
    }
    // basic length checks on the resulting buffer sizes
    switch(versionByteName){
        case 'ed25519PublicKey':
        case 'ed25519SecretSeed':
        case 'preAuthTx':
        case 'sha256Hash':
        case 'contract':
            return decoded.length === 32;
        case 'med25519PublicKey':
            return decoded.length === 40;
        // +8 bytes for the ID
        case 'signedPayload':
            return(// 32 for the signer, +4 for the payload size, then either +4 for the
            // min or +64 for the max payload
            decoded.length >= 32 + 4 + 4 && decoded.length <= 32 + 4 + 64);
        default:
            return false;
    }
}
function decodeCheck(versionByteName, encoded) {
    if (typeof encoded !== 'string') {
        throw new TypeError('encoded argument must be of type String');
    }
    var decoded = _base["default"].decode(encoded);
    var versionByte = decoded[0];
    var payload = decoded.slice(0, -2);
    var data = payload.slice(1);
    var checksum = decoded.slice(-2);
    if (encoded !== _base["default"].encode(decoded)) {
        throw new Error('invalid encoded string');
    }
    var expectedVersion = versionBytes[versionByteName];
    if (expectedVersion === undefined) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(', ')));
    }
    if (versionByte !== expectedVersion) {
        throw new Error("invalid version byte. expected ".concat(expectedVersion, ", got ").concat(versionByte));
    }
    var expectedChecksum = calculateChecksum(payload);
    if (!(0, _checksum.verifyChecksum)(expectedChecksum, checksum)) {
        throw new Error("invalid checksum");
    }
    return Buffer.from(data);
}
function encodeCheck(versionByteName, data) {
    if (data === null || data === undefined) {
        throw new Error('cannot encode null data');
    }
    var versionByte = versionBytes[versionByteName];
    if (versionByte === undefined) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(', ')));
    }
    data = Buffer.from(data);
    var versionBuffer = Buffer.from([
        versionByte
    ]);
    var payload = Buffer.concat([
        versionBuffer,
        data
    ]);
    var checksum = Buffer.from(calculateChecksum(payload));
    var unencoded = Buffer.concat([
        payload,
        checksum
    ]);
    return _base["default"].encode(unencoded);
}
// Computes the CRC16-XModem checksum of `payload` in little-endian order
function calculateChecksum(payload) {
    var crcTable = [
        0x0000,
        0x1021,
        0x2042,
        0x3063,
        0x4084,
        0x50a5,
        0x60c6,
        0x70e7,
        0x8108,
        0x9129,
        0xa14a,
        0xb16b,
        0xc18c,
        0xd1ad,
        0xe1ce,
        0xf1ef,
        0x1231,
        0x0210,
        0x3273,
        0x2252,
        0x52b5,
        0x4294,
        0x72f7,
        0x62d6,
        0x9339,
        0x8318,
        0xb37b,
        0xa35a,
        0xd3bd,
        0xc39c,
        0xf3ff,
        0xe3de,
        0x2462,
        0x3443,
        0x0420,
        0x1401,
        0x64e6,
        0x74c7,
        0x44a4,
        0x5485,
        0xa56a,
        0xb54b,
        0x8528,
        0x9509,
        0xe5ee,
        0xf5cf,
        0xc5ac,
        0xd58d,
        0x3653,
        0x2672,
        0x1611,
        0x0630,
        0x76d7,
        0x66f6,
        0x5695,
        0x46b4,
        0xb75b,
        0xa77a,
        0x9719,
        0x8738,
        0xf7df,
        0xe7fe,
        0xd79d,
        0xc7bc,
        0x48c4,
        0x58e5,
        0x6886,
        0x78a7,
        0x0840,
        0x1861,
        0x2802,
        0x3823,
        0xc9cc,
        0xd9ed,
        0xe98e,
        0xf9af,
        0x8948,
        0x9969,
        0xa90a,
        0xb92b,
        0x5af5,
        0x4ad4,
        0x7ab7,
        0x6a96,
        0x1a71,
        0x0a50,
        0x3a33,
        0x2a12,
        0xdbfd,
        0xcbdc,
        0xfbbf,
        0xeb9e,
        0x9b79,
        0x8b58,
        0xbb3b,
        0xab1a,
        0x6ca6,
        0x7c87,
        0x4ce4,
        0x5cc5,
        0x2c22,
        0x3c03,
        0x0c60,
        0x1c41,
        0xedae,
        0xfd8f,
        0xcdec,
        0xddcd,
        0xad2a,
        0xbd0b,
        0x8d68,
        0x9d49,
        0x7e97,
        0x6eb6,
        0x5ed5,
        0x4ef4,
        0x3e13,
        0x2e32,
        0x1e51,
        0x0e70,
        0xff9f,
        0xefbe,
        0xdfdd,
        0xcffc,
        0xbf1b,
        0xaf3a,
        0x9f59,
        0x8f78,
        0x9188,
        0x81a9,
        0xb1ca,
        0xa1eb,
        0xd10c,
        0xc12d,
        0xf14e,
        0xe16f,
        0x1080,
        0x00a1,
        0x30c2,
        0x20e3,
        0x5004,
        0x4025,
        0x7046,
        0x6067,
        0x83b9,
        0x9398,
        0xa3fb,
        0xb3da,
        0xc33d,
        0xd31c,
        0xe37f,
        0xf35e,
        0x02b1,
        0x1290,
        0x22f3,
        0x32d2,
        0x4235,
        0x5214,
        0x6277,
        0x7256,
        0xb5ea,
        0xa5cb,
        0x95a8,
        0x8589,
        0xf56e,
        0xe54f,
        0xd52c,
        0xc50d,
        0x34e2,
        0x24c3,
        0x14a0,
        0x0481,
        0x7466,
        0x6447,
        0x5424,
        0x4405,
        0xa7db,
        0xb7fa,
        0x8799,
        0x97b8,
        0xe75f,
        0xf77e,
        0xc71d,
        0xd73c,
        0x26d3,
        0x36f2,
        0x0691,
        0x16b0,
        0x6657,
        0x7676,
        0x4615,
        0x5634,
        0xd94c,
        0xc96d,
        0xf90e,
        0xe92f,
        0x99c8,
        0x89e9,
        0xb98a,
        0xa9ab,
        0x5844,
        0x4865,
        0x7806,
        0x6827,
        0x18c0,
        0x08e1,
        0x3882,
        0x28a3,
        0xcb7d,
        0xdb5c,
        0xeb3f,
        0xfb1e,
        0x8bf9,
        0x9bd8,
        0xabbb,
        0xbb9a,
        0x4a75,
        0x5a54,
        0x6a37,
        0x7a16,
        0x0af1,
        0x1ad0,
        0x2ab3,
        0x3a92,
        0xfd2e,
        0xed0f,
        0xdd6c,
        0xcd4d,
        0xbdaa,
        0xad8b,
        0x9de8,
        0x8dc9,
        0x7c26,
        0x6c07,
        0x5c64,
        0x4c45,
        0x3ca2,
        0x2c83,
        0x1ce0,
        0x0cc1,
        0xef1f,
        0xff3e,
        0xcf5d,
        0xdf7c,
        0xaf9b,
        0xbfba,
        0x8fd9,
        0x9ff8,
        0x6e17,
        0x7e36,
        0x4e55,
        0x5e74,
        0x2e93,
        0x3eb2,
        0x0ed1,
        0x1ef0
    ];
    var crc16 = 0x0;
    for(var i = 0; i < payload.length; i += 1){
        var _byte = payload[i];
        var lookupIndex = crc16 >> 8 ^ _byte;
        crc16 = crc16 << 8 ^ crcTable[lookupIndex];
        crc16 &= 0xffff;
    }
    var checksum = new Uint8Array(2);
    checksum[0] = crc16 & 0xff;
    checksum[1] = crc16 >> 8 & 0xff;
    return checksum;
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Keypair = void 0;
var _tweetnacl = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/tweetnacl/nacl-fast.js [app-ssr] (ecmascript)"));
var _signing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/signing.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _hashing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/hashing.js [app-ssr] (ecmascript)");
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
} /* eslint no-bitwise: ["error", {"allow": ["^"]}] */ 
/**
 * `Keypair` represents public (and secret) keys of the account.
 *
 * Currently `Keypair` only supports ed25519 but in a future this class can be abstraction layer for other
 * public-key signature systems.
 *
 * Use more convenient methods to create `Keypair` object:
 * * `{@link Keypair.fromPublicKey}`
 * * `{@link Keypair.fromSecret}`
 * * `{@link Keypair.random}`
 *
 * @constructor
 * @param {object} keys At least one of keys must be provided.
 * @param {string} keys.type Public-key signature system name. (currently only `ed25519` keys are supported)
 * @param {Buffer} [keys.publicKey] Raw public key
 * @param {Buffer} [keys.secretKey] Raw secret key (32-byte secret seed in ed25519`)
 */ var Keypair = exports.Keypair = /*#__PURE__*/ function() {
    function Keypair(keys) {
        _classCallCheck(this, Keypair);
        if (keys.type !== 'ed25519') {
            throw new Error('Invalid keys type');
        }
        this.type = keys.type;
        if (keys.secretKey) {
            keys.secretKey = Buffer.from(keys.secretKey);
            if (keys.secretKey.length !== 32) {
                throw new Error('secretKey length is invalid');
            }
            this._secretSeed = keys.secretKey;
            this._publicKey = (0, _signing.generate)(keys.secretKey);
            this._secretKey = Buffer.concat([
                keys.secretKey,
                this._publicKey
            ]);
            if (keys.publicKey && !this._publicKey.equals(Buffer.from(keys.publicKey))) {
                throw new Error('secretKey does not match publicKey');
            }
        } else {
            this._publicKey = Buffer.from(keys.publicKey);
            if (this._publicKey.length !== 32) {
                throw new Error('publicKey length is invalid');
            }
        }
    }
    /**
   * Creates a new `Keypair` instance from secret. This can either be secret key or secret seed depending
   * on underlying public-key signature system. Currently `Keypair` only supports ed25519.
   * @param {string} secret secret key (ex. `SDAKFNYEIAORZKKCYRILFQKLLOCNPL5SWJ3YY5NM3ZH6GJSZGXHZEPQS`)
   * @returns {Keypair}
   */ return _createClass(Keypair, [
        {
            key: "xdrAccountId",
            value: function xdrAccountId() {
                return new _xdr["default"].AccountId.publicKeyTypeEd25519(this._publicKey);
            }
        },
        {
            key: "xdrPublicKey",
            value: function xdrPublicKey() {
                return new _xdr["default"].PublicKey.publicKeyTypeEd25519(this._publicKey);
            }
        },
        {
            key: "xdrMuxedAccount",
            value: function xdrMuxedAccount(id) {
                if (typeof id !== 'undefined') {
                    if (typeof id !== 'string') {
                        throw new TypeError("expected string for ID, got ".concat(_typeof(id)));
                    }
                    return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
                        id: _xdr["default"].Uint64.fromString(id),
                        ed25519: this._publicKey
                    }));
                }
                return new _xdr["default"].MuxedAccount.keyTypeEd25519(this._publicKey);
            }
        },
        {
            key: "rawPublicKey",
            value: function rawPublicKey() {
                return this._publicKey;
            }
        },
        {
            key: "signatureHint",
            value: function signatureHint() {
                var a = this.xdrAccountId().toXDR();
                return a.slice(a.length - 4);
            }
        },
        {
            key: "publicKey",
            value: function publicKey() {
                return _strkey.StrKey.encodeEd25519PublicKey(this._publicKey);
            }
        },
        {
            key: "secret",
            value: function secret() {
                if (!this._secretSeed) {
                    throw new Error('no secret key available');
                }
                if (this.type === 'ed25519') {
                    return _strkey.StrKey.encodeEd25519SecretSeed(this._secretSeed);
                }
                throw new Error('Invalid Keypair type');
            }
        },
        {
            key: "rawSecretKey",
            value: function rawSecretKey() {
                return this._secretSeed;
            }
        },
        {
            key: "canSign",
            value: function canSign() {
                return !!this._secretKey;
            }
        },
        {
            key: "sign",
            value: function sign(data) {
                if (!this.canSign()) {
                    throw new Error('cannot sign: no secret key available');
                }
                return (0, _signing.sign)(data, this._secretKey);
            }
        },
        {
            key: "verify",
            value: function verify(data, signature) {
                return (0, _signing.verify)(data, signature, this._publicKey);
            }
        },
        {
            key: "signDecorated",
            value: function signDecorated(data) {
                var signature = this.sign(data);
                var hint = this.signatureHint();
                return new _xdr["default"].DecoratedSignature({
                    hint: hint,
                    signature: signature
                });
            }
        },
        {
            key: "signPayloadDecorated",
            value: function signPayloadDecorated(data) {
                var signature = this.sign(data);
                var keyHint = this.signatureHint();
                var hint = Buffer.from(data.slice(-4));
                if (hint.length < 4) {
                    // append zeroes as needed
                    hint = Buffer.concat([
                        hint,
                        Buffer.alloc(4 - data.length, 0)
                    ]);
                }
                return new _xdr["default"].DecoratedSignature({
                    hint: hint.map(function(_byte, i) {
                        return _byte ^ keyHint[i];
                    }),
                    signature: signature
                });
            }
        }
    ], [
        {
            key: "fromSecret",
            value: function fromSecret(secret) {
                var rawSecret = _strkey.StrKey.decodeEd25519SecretSeed(secret);
                return this.fromRawEd25519Seed(rawSecret);
            }
        },
        {
            key: "fromRawEd25519Seed",
            value: function fromRawEd25519Seed(rawSeed) {
                return new this({
                    type: 'ed25519',
                    secretKey: rawSeed
                });
            }
        },
        {
            key: "master",
            value: function master(networkPassphrase) {
                if (!networkPassphrase) {
                    throw new Error('No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.');
                }
                return this.fromRawEd25519Seed((0, _hashing.hash)(networkPassphrase));
            }
        },
        {
            key: "fromPublicKey",
            value: function fromPublicKey(publicKey) {
                publicKey = _strkey.StrKey.decodeEd25519PublicKey(publicKey);
                if (publicKey.length !== 32) {
                    throw new Error('Invalid Stellar public key');
                }
                return new this({
                    type: 'ed25519',
                    publicKey: publicKey
                });
            }
        },
        {
            key: "random",
            value: function random() {
                var secret = _tweetnacl["default"].randomBytes(32);
                return this.fromRawEd25519Seed(secret);
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Asset = void 0;
var _util = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/util.js [app-ssr] (ecmascript)");
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _hashing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/hashing.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Asset class represents an asset, either the native asset (`XLM`)
 * or an asset code / issuer account ID pair.
 *
 * An asset code describes an asset code and issuer pair. In the case of the native
 * asset XLM, the issuer will be null.
 *
 * @constructor
 * @param {string} code - The asset code.
 * @param {string} issuer - The account ID of the issuer.
 */ var Asset = exports.Asset = /*#__PURE__*/ function() {
    function Asset(code, issuer) {
        _classCallCheck(this, Asset);
        if (!/^[a-zA-Z0-9]{1,12}$/.test(code)) {
            throw new Error('Asset code is invalid (maximum alphanumeric, 12 characters at max)');
        }
        if (String(code).toLowerCase() !== 'xlm' && !issuer) {
            throw new Error('Issuer cannot be null');
        }
        if (issuer && !_strkey.StrKey.isValidEd25519PublicKey(issuer)) {
            throw new Error('Issuer is invalid');
        }
        if (String(code).toLowerCase() === 'xlm') {
            // transform all xLM, Xlm, etc. variants -> XLM
            this.code = 'XLM';
        } else {
            this.code = code;
        }
        this.issuer = issuer;
    }
    /**
   * Returns an asset object for the native asset.
   * @Return {Asset}
   */ return _createClass(Asset, [
        {
            key: "toXDRObject",
            value: /**
     * Returns the xdr.Asset object for this asset.
     * @returns {xdr.Asset} XDR asset object
     */ function toXDRObject() {
                return this._toXDRObject(_xdr["default"].Asset);
            }
        },
        {
            key: "toChangeTrustXDRObject",
            value: function toChangeTrustXDRObject() {
                return this._toXDRObject(_xdr["default"].ChangeTrustAsset);
            }
        },
        {
            key: "toTrustLineXDRObject",
            value: function toTrustLineXDRObject() {
                return this._toXDRObject(_xdr["default"].TrustLineAsset);
            }
        },
        {
            key: "contractId",
            value: function contractId(networkPassphrase) {
                var networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
                var preimage = _xdr["default"].HashIdPreimage.envelopeTypeContractId(new _xdr["default"].HashIdPreimageContractId({
                    networkId: networkId,
                    contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject())
                }));
                return _strkey.StrKey.encodeContract((0, _hashing.hash)(preimage.toXDR()));
            }
        },
        {
            key: "_toXDRObject",
            value: function _toXDRObject() {
                var xdrAsset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _xdr["default"].Asset;
                if (this.isNative()) {
                    return xdrAsset.assetTypeNative();
                }
                var xdrType;
                var xdrTypeString;
                if (this.code.length <= 4) {
                    xdrType = _xdr["default"].AlphaNum4;
                    xdrTypeString = 'assetTypeCreditAlphanum4';
                } else {
                    xdrType = _xdr["default"].AlphaNum12;
                    xdrTypeString = 'assetTypeCreditAlphanum12';
                }
                // pad code with null bytes if necessary
                var padLength = this.code.length <= 4 ? 4 : 12;
                var paddedCode = this.code.padEnd(padLength, '\0');
                // eslint-disable-next-line new-cap
                var assetType = new xdrType({
                    assetCode: paddedCode,
                    issuer: _keypair.Keypair.fromPublicKey(this.issuer).xdrAccountId()
                });
                return new xdrAsset(xdrTypeString, assetType);
            }
        },
        {
            key: "getCode",
            value: function getCode() {
                if (this.code === undefined) {
                    return undefined;
                }
                return String(this.code);
            }
        },
        {
            key: "getIssuer",
            value: function getIssuer() {
                if (this.issuer === undefined) {
                    return undefined;
                }
                return String(this.issuer);
            }
        },
        {
            key: "getAssetType",
            value: function getAssetType() {
                switch(this.getRawAssetType().value){
                    case _xdr["default"].AssetType.assetTypeNative().value:
                        return 'native';
                    case _xdr["default"].AssetType.assetTypeCreditAlphanum4().value:
                        return 'credit_alphanum4';
                    case _xdr["default"].AssetType.assetTypeCreditAlphanum12().value:
                        return 'credit_alphanum12';
                    default:
                        return 'unknown';
                }
            }
        },
        {
            key: "getRawAssetType",
            value: function getRawAssetType() {
                if (this.isNative()) {
                    return _xdr["default"].AssetType.assetTypeNative();
                }
                if (this.code.length <= 4) {
                    return _xdr["default"].AssetType.assetTypeCreditAlphanum4();
                }
                return _xdr["default"].AssetType.assetTypeCreditAlphanum12();
            }
        },
        {
            key: "isNative",
            value: function isNative() {
                return !this.issuer;
            }
        },
        {
            key: "equals",
            value: function equals(asset) {
                return this.code === asset.getCode() && this.issuer === asset.getIssuer();
            }
        },
        {
            key: "toString",
            value: function toString() {
                if (this.isNative()) {
                    return 'native';
                }
                return "".concat(this.getCode(), ":").concat(this.getIssuer());
            }
        }
    ], [
        {
            key: "native",
            value: function _native() {
                return new Asset('XLM');
            }
        },
        {
            key: "fromOperation",
            value: function fromOperation(assetXdr) {
                var anum;
                var code;
                var issuer;
                switch(assetXdr["switch"]()){
                    case _xdr["default"].AssetType.assetTypeNative():
                        return this["native"]();
                    case _xdr["default"].AssetType.assetTypeCreditAlphanum4():
                        anum = assetXdr.alphaNum4();
                    /* falls through */ case _xdr["default"].AssetType.assetTypeCreditAlphanum12():
                        anum = anum || assetXdr.alphaNum12();
                        issuer = _strkey.StrKey.encodeEd25519PublicKey(anum.issuer().ed25519());
                        code = (0, _util.trimEnd)(anum.assetCode(), '\0');
                        return new this(code, issuer);
                    default:
                        throw new Error("Invalid asset type: ".concat(assetXdr["switch"]().name));
                }
            }
        },
        {
            key: "compare",
            value: function compare(assetA, assetB) {
                if (!assetA || !(assetA instanceof Asset)) {
                    throw new Error('assetA is invalid');
                }
                if (!assetB || !(assetB instanceof Asset)) {
                    throw new Error('assetB is invalid');
                }
                if (assetA.equals(assetB)) {
                    return 0;
                }
                // Compare asset types.
                var xdrAtype = assetA.getRawAssetType().value;
                var xdrBtype = assetB.getRawAssetType().value;
                if (xdrAtype !== xdrBtype) {
                    return xdrAtype < xdrBtype ? -1 : 1;
                }
                // Compare asset codes.
                var result = asciiCompare(assetA.getCode(), assetB.getCode());
                if (result !== 0) {
                    return result;
                }
                // Compare asset issuers.
                return asciiCompare(assetA.getIssuer(), assetB.getIssuer());
            }
        }
    ]);
}();
/**
 * Compares two ASCII strings in lexographic order with uppercase precedence.
 *
 * @param   {string} a - the first string to compare
 * @param   {string} b - the second
 * @returns {number} like all `compare()`s:
 *     -1 if `a < b`, 0 if `a == b`, and 1 if `a > b`
 *
 * @warning No type-checks are done on the parameters
 */ function asciiCompare(a, b) {
    return Buffer.compare(Buffer.from(a, 'ascii'), Buffer.from(b, 'ascii'));
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LiquidityPoolFeeV18 = void 0;
exports.getLiquidityPoolId = getLiquidityPoolId;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)");
var _hashing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/hashing.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
// LiquidityPoolFeeV18 is the default liquidity pool fee in protocol v18. It defaults to 30 base points (0.3%).
var LiquidityPoolFeeV18 = exports.LiquidityPoolFeeV18 = 30;
/**
 * getLiquidityPoolId computes the Pool ID for the given assets, fee and pool type.
 *
 * @see [stellar-core getPoolID](https://github.com/stellar/stellar-core/blob/9f3a48c6a8f1aa77b6043a055d0638661f718080/src/ledger/test/LedgerTxnTests.cpp#L3746-L3751)
 *
 * @export
 * @param {string} liquidityPoolType – A string representing the liquidity pool type.
 * @param {object} liquidityPoolParameters        – The liquidity pool parameters.
 * @param {Asset}  liquidityPoolParameters.assetA – The first asset in the Pool, it must respect the rule assetA < assetB.
 * @param {Asset}  liquidityPoolParameters.assetB – The second asset in the Pool, it must respect the rule assetA < assetB.
 * @param {number} liquidityPoolParameters.fee    – The liquidity pool fee. For now the only fee supported is `30`.
 *
 * @return {Buffer} the raw Pool ID buffer, which can be stringfied with `toString('hex')`
 */ function getLiquidityPoolId(liquidityPoolType) {
    var liquidityPoolParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (liquidityPoolType !== 'constant_product') {
        throw new Error('liquidityPoolType is invalid');
    }
    var assetA = liquidityPoolParameters.assetA, assetB = liquidityPoolParameters.assetB, fee = liquidityPoolParameters.fee;
    if (!assetA || !(assetA instanceof _asset.Asset)) {
        throw new Error('assetA is invalid');
    }
    if (!assetB || !(assetB instanceof _asset.Asset)) {
        throw new Error('assetB is invalid');
    }
    if (!fee || fee !== LiquidityPoolFeeV18) {
        throw new Error('fee is invalid');
    }
    if (_asset.Asset.compare(assetA, assetB) !== -1) {
        throw new Error('Assets are not in lexicographic order');
    }
    var lpTypeData = _xdr["default"].LiquidityPoolType.liquidityPoolConstantProduct().toXDR();
    var lpParamsData = new _xdr["default"].LiquidityPoolConstantProductParameters({
        assetA: assetA.toXDRObject(),
        assetB: assetB.toXDRObject(),
        fee: fee
    }).toXDR();
    var payload = Buffer.concat([
        lpTypeData,
        lpParamsData
    ]);
    return (0, _hashing.hash)(payload);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/transaction_base.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransactionBase = void 0;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _hashing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/hashing.js [app-ssr] (ecmascript)");
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * @ignore
 */ var TransactionBase = exports.TransactionBase = /*#__PURE__*/ function() {
    function TransactionBase(tx, signatures, fee, networkPassphrase) {
        _classCallCheck(this, TransactionBase);
        if (typeof networkPassphrase !== 'string') {
            throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(_typeof(networkPassphrase)));
        }
        this._networkPassphrase = networkPassphrase;
        this._tx = tx;
        this._signatures = signatures;
        this._fee = fee;
    }
    /**
   * @type {Array.<xdr.DecoratedSignature>}
   * @readonly
   */ return _createClass(TransactionBase, [
        {
            key: "signatures",
            get: function get() {
                return this._signatures;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "tx",
            get: function get() {
                return this._tx;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "fee",
            get: function get() {
                return this._fee;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "networkPassphrase",
            get: function get() {
                return this._networkPassphrase;
            },
            set: function set(networkPassphrase) {
                this._networkPassphrase = networkPassphrase;
            }
        },
        {
            key: "sign",
            value: function sign() {
                var _this = this;
                var txHash = this.hash();
                for(var _len = arguments.length, keypairs = new Array(_len), _key = 0; _key < _len; _key++){
                    keypairs[_key] = arguments[_key];
                }
                keypairs.forEach(function(kp) {
                    var sig = kp.signDecorated(txHash);
                    _this.signatures.push(sig);
                });
            }
        },
        {
            key: "getKeypairSignature",
            value: function getKeypairSignature(keypair) {
                return keypair.sign(this.hash()).toString('base64');
            }
        },
        {
            key: "addSignature",
            value: function addSignature() {
                var publicKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
                var signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
                if (!signature || typeof signature !== 'string') {
                    throw new Error('Invalid signature');
                }
                if (!publicKey || typeof publicKey !== 'string') {
                    throw new Error('Invalid publicKey');
                }
                var keypair;
                var hint;
                var signatureBuffer = Buffer.from(signature, 'base64');
                try {
                    keypair = _keypair.Keypair.fromPublicKey(publicKey);
                    hint = keypair.signatureHint();
                } catch (e) {
                    throw new Error('Invalid publicKey');
                }
                if (!keypair.verify(this.hash(), signatureBuffer)) {
                    throw new Error('Invalid signature');
                }
                this.signatures.push(new _xdr["default"].DecoratedSignature({
                    hint: hint,
                    signature: signatureBuffer
                }));
            }
        },
        {
            key: "addDecoratedSignature",
            value: function addDecoratedSignature(signature) {
                this.signatures.push(signature);
            }
        },
        {
            key: "signHashX",
            value: function signHashX(preimage) {
                if (typeof preimage === 'string') {
                    preimage = Buffer.from(preimage, 'hex');
                }
                if (preimage.length > 64) {
                    throw new Error('preimage cannnot be longer than 64 bytes');
                }
                var signature = preimage;
                var hashX = (0, _hashing.hash)(preimage);
                var hint = hashX.slice(hashX.length - 4);
                this.signatures.push(new _xdr["default"].DecoratedSignature({
                    hint: hint,
                    signature: signature
                }));
            }
        },
        {
            key: "hash",
            value: function hash() {
                return (0, _hashing.hash)(this.signatureBase());
            }
        },
        {
            key: "signatureBase",
            value: function signatureBase() {
                throw new Error('Implement in subclass');
            }
        },
        {
            key: "toEnvelope",
            value: function toEnvelope() {
                throw new Error('Implement in subclass');
            }
        },
        {
            key: "toXDR",
            value: function toXDR() {
                return this.toEnvelope().toXDR().toString('base64');
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/util/bignumber.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _bignumber = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/bignumber.js/bignumber.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
var BigNumber = _bignumber["default"].clone();
BigNumber.DEBUG = true; // gives us exceptions on bad constructor values
var _default = exports["default"] = BigNumber;
}}),
"[project]/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.best_r = best_r;
var _bignumber = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/bignumber.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
        var e, n, i, u, a = [], f = !0, o = !1;
        try {
            if (i = (t = t.call(r)).next, 0 === l) {
                if (Object(t) !== t) return;
                f = !1;
            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
            o = !0, n = r;
        } finally{
            try {
                if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally{
                if (o) throw n;
            }
        }
        return a;
    }
}
function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
}
// eslint-disable-next-line no-bitwise
var MAX_INT = (1 << 31 >>> 0) - 1;
/**
 * Calculates and returns the best rational approximation of the given real number.
 * @private
 * @param {string|number|BigNumber} rawNumber Real number
 * @throws Error Throws `Error` when the best rational approximation cannot be found.
 * @returns {array} first element is n (numerator), second element is d (denominator)
 */ function best_r(rawNumber) {
    var number = new _bignumber["default"](rawNumber);
    var a;
    var f;
    var fractions = [
        [
            new _bignumber["default"](0),
            new _bignumber["default"](1)
        ],
        [
            new _bignumber["default"](1),
            new _bignumber["default"](0)
        ]
    ];
    var i = 2;
    // eslint-disable-next-line no-constant-condition
    while(true){
        if (number.gt(MAX_INT)) {
            break;
        }
        a = number.integerValue(_bignumber["default"].ROUND_FLOOR);
        f = number.minus(a);
        var h = a.times(fractions[i - 1][0]).plus(fractions[i - 2][0]);
        var k = a.times(fractions[i - 1][1]).plus(fractions[i - 2][1]);
        if (h.gt(MAX_INT) || k.gt(MAX_INT)) {
            break;
        }
        fractions.push([
            h,
            k
        ]);
        if (f.eq(0)) {
            break;
        }
        number = new _bignumber["default"](1).div(f);
        i += 1;
    }
    var _fractions = _slicedToArray(fractions[fractions.length - 1], 2), n = _fractions[0], d = _fractions[1];
    if (n.isZero() || d.isZero()) {
        throw new Error("Couldn't find approximation");
    }
    return [
        n.toNumber(),
        d.toNumber()
    ];
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LiquidityPoolAsset = void 0;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)");
var _get_liquidity_pool_id = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * LiquidityPoolAsset class represents a liquidity pool trustline change.
 *
 * @constructor
 * @param {Asset} assetA – The first asset in the Pool, it must respect the rule assetA < assetB. See {@link Asset.compare} for more details on how assets are sorted.
 * @param {Asset} assetB – The second asset in the Pool, it must respect the rule assetA < assetB. See {@link Asset.compare} for more details on how assets are sorted.
 * @param {number} fee – The liquidity pool fee. For now the only fee supported is `30`.
 */ var LiquidityPoolAsset = exports.LiquidityPoolAsset = /*#__PURE__*/ function() {
    function LiquidityPoolAsset(assetA, assetB, fee) {
        _classCallCheck(this, LiquidityPoolAsset);
        if (!assetA || !(assetA instanceof _asset.Asset)) {
            throw new Error('assetA is invalid');
        }
        if (!assetB || !(assetB instanceof _asset.Asset)) {
            throw new Error('assetB is invalid');
        }
        if (_asset.Asset.compare(assetA, assetB) !== -1) {
            throw new Error('Assets are not in lexicographic order');
        }
        if (!fee || fee !== _get_liquidity_pool_id.LiquidityPoolFeeV18) {
            throw new Error('fee is invalid');
        }
        this.assetA = assetA;
        this.assetB = assetB;
        this.fee = fee;
    }
    /**
   * Returns a liquidity pool asset object from its XDR ChangeTrustAsset object
   * representation.
   * @param {xdr.ChangeTrustAsset} ctAssetXdr - The asset XDR object.
   * @returns {LiquidityPoolAsset}
   */ return _createClass(LiquidityPoolAsset, [
        {
            key: "toXDRObject",
            value: /**
     * Returns the `xdr.ChangeTrustAsset` object for this liquidity pool asset.
     *
     * Note: To convert from an {@link Asset `Asset`} to `xdr.ChangeTrustAsset`
     * please refer to the
     * {@link Asset.toChangeTrustXDRObject `Asset.toChangeTrustXDRObject`} method.
     *
     * @returns {xdr.ChangeTrustAsset} XDR ChangeTrustAsset object.
     */ function toXDRObject() {
                var lpConstantProductParamsXdr = new _xdr["default"].LiquidityPoolConstantProductParameters({
                    assetA: this.assetA.toXDRObject(),
                    assetB: this.assetB.toXDRObject(),
                    fee: this.fee
                });
                var lpParamsXdr = new _xdr["default"].LiquidityPoolParameters('liquidityPoolConstantProduct', lpConstantProductParamsXdr);
                return new _xdr["default"].ChangeTrustAsset('assetTypePoolShare', lpParamsXdr);
            }
        },
        {
            key: "getLiquidityPoolParameters",
            value: function getLiquidityPoolParameters() {
                return _objectSpread(_objectSpread({}, this), {}, {
                    assetA: this.assetA,
                    assetB: this.assetB,
                    fee: this.fee
                });
            }
        },
        {
            key: "getAssetType",
            value: function getAssetType() {
                return 'liquidity_pool_shares';
            }
        },
        {
            key: "equals",
            value: function equals(other) {
                return this.assetA.equals(other.assetA) && this.assetB.equals(other.assetB) && this.fee === other.fee;
            }
        },
        {
            key: "toString",
            value: function toString() {
                var poolId = (0, _get_liquidity_pool_id.getLiquidityPoolId)('constant_product', this.getLiquidityPoolParameters()).toString('hex');
                return "liquidity_pool:".concat(poolId);
            }
        }
    ], [
        {
            key: "fromOperation",
            value: function fromOperation(ctAssetXdr) {
                var assetType = ctAssetXdr["switch"]();
                if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
                    var liquidityPoolParameters = ctAssetXdr.liquidityPool().constantProduct();
                    return new this(_asset.Asset.fromOperation(liquidityPoolParameters.assetA()), _asset.Asset.fromOperation(liquidityPoolParameters.assetB()), liquidityPoolParameters.fee());
                }
                throw new Error("Invalid asset type: ".concat(assetType.name));
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/claimant.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Claimant = void 0;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Claimant class represents an xdr.Claimant
 *
 * The claim predicate is optional, it defaults to unconditional if none is specified.
 *
 * @constructor
 * @param {string} destination - The destination account ID.
 * @param {xdr.ClaimPredicate} [predicate] - The claim predicate.
 */ var Claimant = exports.Claimant = /*#__PURE__*/ function() {
    function Claimant(destination, predicate) {
        _classCallCheck(this, Claimant);
        if (destination && !_strkey.StrKey.isValidEd25519PublicKey(destination)) {
            throw new Error('Destination is invalid');
        }
        this._destination = destination;
        if (!predicate) {
            this._predicate = _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
        } else if (predicate instanceof _xdr["default"].ClaimPredicate) {
            this._predicate = predicate;
        } else {
            throw new Error('Predicate should be an xdr.ClaimPredicate');
        }
    }
    /**
   * Returns an unconditional claim predicate
   * @Return {xdr.ClaimPredicate}
   */ return _createClass(Claimant, [
        {
            key: "toXDRObject",
            value: /**
     * Returns the xdr object for this claimant.
     * @returns {xdr.Claimant} XDR Claimant object
     */ function toXDRObject() {
                var claimant = new _xdr["default"].ClaimantV0({
                    destination: _keypair.Keypair.fromPublicKey(this._destination).xdrAccountId(),
                    predicate: this._predicate
                });
                return _xdr["default"].Claimant.claimantTypeV0(claimant);
            }
        },
        {
            key: "destination",
            get: function get() {
                return this._destination;
            },
            set: function set(value) {
                throw new Error('Claimant is immutable');
            }
        },
        {
            key: "predicate",
            get: function get() {
                return this._predicate;
            },
            set: function set(value) {
                throw new Error('Claimant is immutable');
            }
        }
    ], [
        {
            key: "predicateUnconditional",
            value: function predicateUnconditional() {
                return _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
            }
        },
        {
            key: "predicateAnd",
            value: function predicateAnd(left, right) {
                if (!(left instanceof _xdr["default"].ClaimPredicate)) {
                    throw new Error('left Predicate should be an xdr.ClaimPredicate');
                }
                if (!(right instanceof _xdr["default"].ClaimPredicate)) {
                    throw new Error('right Predicate should be an xdr.ClaimPredicate');
                }
                return _xdr["default"].ClaimPredicate.claimPredicateAnd([
                    left,
                    right
                ]);
            }
        },
        {
            key: "predicateOr",
            value: function predicateOr(left, right) {
                if (!(left instanceof _xdr["default"].ClaimPredicate)) {
                    throw new Error('left Predicate should be an xdr.ClaimPredicate');
                }
                if (!(right instanceof _xdr["default"].ClaimPredicate)) {
                    throw new Error('right Predicate should be an xdr.ClaimPredicate');
                }
                return _xdr["default"].ClaimPredicate.claimPredicateOr([
                    left,
                    right
                ]);
            }
        },
        {
            key: "predicateNot",
            value: function predicateNot(predicate) {
                if (!(predicate instanceof _xdr["default"].ClaimPredicate)) {
                    throw new Error('right Predicate should be an xdr.ClaimPredicate');
                }
                return _xdr["default"].ClaimPredicate.claimPredicateNot(predicate);
            }
        },
        {
            key: "predicateBeforeAbsoluteTime",
            value: function predicateBeforeAbsoluteTime(absBefore) {
                return _xdr["default"].ClaimPredicate.claimPredicateBeforeAbsoluteTime(_xdr["default"].Int64.fromString(absBefore));
            }
        },
        {
            key: "predicateBeforeRelativeTime",
            value: function predicateBeforeRelativeTime(seconds) {
                return _xdr["default"].ClaimPredicate.claimPredicateBeforeRelativeTime(_xdr["default"].Int64.fromString(seconds));
            }
        },
        {
            key: "fromXDR",
            value: function fromXDR(claimantXdr) {
                var value;
                switch(claimantXdr["switch"]()){
                    case _xdr["default"].ClaimantType.claimantTypeV0():
                        value = claimantXdr.v0();
                        return new this(_strkey.StrKey.encodeEd25519PublicKey(value.destination().ed25519()), value.predicate());
                    default:
                        throw new Error("Invalid claimant type: ".concat(claimantXdr["switch"]().name));
                }
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LiquidityPoolId = void 0;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * LiquidityPoolId class represents the asset referenced by a trustline to a
 * liquidity pool.
 *
 * @constructor
 * @param {string} liquidityPoolId - The ID of the liquidity pool in string 'hex'.
 */ var LiquidityPoolId = exports.LiquidityPoolId = /*#__PURE__*/ function() {
    function LiquidityPoolId(liquidityPoolId) {
        _classCallCheck(this, LiquidityPoolId);
        if (!liquidityPoolId) {
            throw new Error('liquidityPoolId cannot be empty');
        }
        if (!/^[a-f0-9]{64}$/.test(liquidityPoolId)) {
            throw new Error('Liquidity pool ID is not a valid hash');
        }
        this.liquidityPoolId = liquidityPoolId;
    }
    /**
   * Returns a liquidity pool ID object from its xdr.TrustLineAsset representation.
   * @param {xdr.TrustLineAsset} tlAssetXdr - The asset XDR object.
   * @returns {LiquidityPoolId}
   */ return _createClass(LiquidityPoolId, [
        {
            key: "toXDRObject",
            value: /**
     * Returns the `xdr.TrustLineAsset` object for this liquidity pool ID.
     *
     * Note: To convert from {@link Asset `Asset`} to `xdr.TrustLineAsset` please
     * refer to the
     * {@link Asset.toTrustLineXDRObject `Asset.toTrustLineXDRObject`} method.
     *
     * @returns {xdr.TrustLineAsset} XDR LiquidityPoolId object
     */ function toXDRObject() {
                var xdrPoolId = _xdr["default"].PoolId.fromXDR(this.liquidityPoolId, 'hex');
                return new _xdr["default"].TrustLineAsset('assetTypePoolShare', xdrPoolId);
            }
        },
        {
            key: "getLiquidityPoolId",
            value: function getLiquidityPoolId() {
                return String(this.liquidityPoolId);
            }
        },
        {
            key: "getAssetType",
            value: function getAssetType() {
                return 'liquidity_pool_shares';
            }
        },
        {
            key: "equals",
            value: function equals(asset) {
                return this.liquidityPoolId === asset.getLiquidityPoolId();
            }
        },
        {
            key: "toString",
            value: function toString() {
                return "liquidity_pool:".concat(this.liquidityPoolId);
            }
        }
    ], [
        {
            key: "fromOperation",
            value: function fromOperation(tlAssetXdr) {
                var assetType = tlAssetXdr["switch"]();
                if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
                    var liquidityPoolId = tlAssetXdr.liquidityPoolId().toString('hex');
                    return new this(liquidityPoolId);
                }
                throw new Error("Invalid asset type: ".concat(assetType.name));
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.manageSellOffer = manageSellOffer;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Returns a XDR ManageSellOfferOp. A "manage sell offer" operation creates, updates, or
 * deletes an offer.
 * @function
 * @alias Operation.manageSellOffer
 * @param {object} opts Options object
 * @param {Asset} opts.selling - What you're selling.
 * @param {Asset} opts.buying - What you're buying.
 * @param {string} opts.amount - The total amount you're selling. If 0, deletes the offer.
 * @param {number|string|BigNumber|Object} opts.price - Price of 1 unit of `selling` in terms of `buying`.
 * @param {number} opts.price.n - If `opts.price` is an object: the price numerator
 * @param {number} opts.price.d - If `opts.price` is an object: the price denominator
 * @param {number|string} [opts.offerId ] - If `0`, will create a new offer (default). Otherwise, edits an exisiting offer.
 * @param {string} [opts.source] - The source account (defaults to transaction source).
 * @throws {Error} Throws `Error` when the best rational approximation of `price` cannot be found.
 * @returns {xdr.ManageSellOfferOp} Manage Sell Offer operation
 */ function manageSellOffer(opts) {
    var attributes = {};
    attributes.selling = opts.selling.toXDRObject();
    attributes.buying = opts.buying.toXDRObject();
    if (!this.isValidAmount(opts.amount, true)) {
        throw new TypeError(this.constructAmountRequirementsError('amount'));
    }
    attributes.amount = this._toXDRAmount(opts.amount);
    if (opts.price === undefined) {
        throw new TypeError('price argument is required');
    }
    attributes.price = this._toXDRPrice(opts.price);
    if (opts.offerId !== undefined) {
        opts.offerId = opts.offerId.toString();
    } else {
        opts.offerId = '0';
    }
    attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
    var manageSellOfferOp = new _xdr["default"].ManageSellOfferOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.manageSellOffer(manageSellOfferOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createPassiveSellOffer = createPassiveSellOffer;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Returns a XDR CreatePasiveSellOfferOp. A "create passive offer" operation creates an
 * offer that won't consume a counter offer that exactly matches this offer. This is
 * useful for offers just used as 1:1 exchanges for path payments. Use manage offer
 * to manage this offer after using this operation to create it.
 * @function
 * @alias Operation.createPassiveSellOffer
 * @param {object} opts Options object
 * @param {Asset} opts.selling - What you're selling.
 * @param {Asset} opts.buying - What you're buying.
 * @param {string} opts.amount - The total amount you're selling. If 0, deletes the offer.
 * @param {number|string|BigNumber|Object} opts.price - Price of 1 unit of `selling` in terms of `buying`.
 * @param {number} opts.price.n - If `opts.price` is an object: the price numerator
 * @param {number} opts.price.d - If `opts.price` is an object: the price denominator
 * @param {string} [opts.source] - The source account (defaults to transaction source).
 * @throws {Error} Throws `Error` when the best rational approximation of `price` cannot be found.
 * @returns {xdr.CreatePassiveSellOfferOp} Create Passive Sell Offer operation
 */ function createPassiveSellOffer(opts) {
    var attributes = {};
    attributes.selling = opts.selling.toXDRObject();
    attributes.buying = opts.buying.toXDRObject();
    if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError('amount'));
    }
    attributes.amount = this._toXDRAmount(opts.amount);
    if (opts.price === undefined) {
        throw new TypeError('price argument is required');
    }
    attributes.price = this._toXDRPrice(opts.price);
    var createPassiveSellOfferOp = new _xdr["default"].CreatePassiveSellOfferOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.createPassiveSellOffer(createPassiveSellOfferOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;
exports.encodeMuxedAccount = encodeMuxedAccount;
exports.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;
exports.extractBaseAddress = extractBaseAddress;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Converts a Stellar address (in G... or M... form) to an `xdr.MuxedAccount`
 * structure, using the ed25519 representation when possible.
 *
 * This supports full muxed accounts, where an `M...` address will resolve to
 * both its underlying `G...` address and an integer ID.
 *
 * @param   {string}  address   G... or M... address to encode into XDR
 * @returns {xdr.MuxedAccount}  a muxed account object for this address string
 */ function decodeAddressToMuxedAccount(address) {
    if (_strkey.StrKey.isValidMed25519PublicKey(address)) {
        return _decodeAddressFullyToMuxedAccount(address);
    }
    return _xdr["default"].MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));
}
/**
 * Converts an xdr.MuxedAccount to its StrKey representation.
 *
 * This returns its "M..." string representation if there is a muxing ID within
 * the object and returns the "G..." representation otherwise.
 *
 * @param   {xdr.MuxedAccount} muxedAccount   Raw account to stringify
 * @returns {string} Stringified G... (corresponding to the underlying pubkey)
 *     or M... address (corresponding to both the key and the muxed ID)
 *
 * @see https://stellar.org/protocol/sep-23
 */ function encodeMuxedAccountToAddress(muxedAccount) {
    if (muxedAccount["switch"]().value === _xdr["default"].CryptoKeyType.keyTypeMuxedEd25519().value) {
        return _encodeMuxedAccountFullyToAddress(muxedAccount);
    }
    return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());
}
/**
 * Transform a Stellar address (G...) and an ID into its XDR representation.
 *
 * @param  {string} address   - a Stellar G... address
 * @param  {string} id        - a Uint64 ID represented as a string
 *
 * @return {xdr.MuxedAccount} - XDR representation of the above muxed account
 */ function encodeMuxedAccount(address, id) {
    if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {
        throw new Error('address should be a Stellar account ID (G...)');
    }
    if (typeof id !== 'string') {
        throw new Error('id should be a string representing a number (uint64)');
    }
    return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromString(id),
        ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)
    }));
}
/**
 * Extracts the underlying base (G...) address from an M-address.
 * @param  {string} address   an account address (either M... or G...)
 * @return {string} a Stellar public key address (G...)
 */ function extractBaseAddress(address) {
    if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
        return address;
    }
    if (!_strkey.StrKey.isValidMed25519PublicKey(address)) {
        throw new TypeError("expected muxed account (M...), got ".concat(address));
    }
    var muxedAccount = decodeAddressToMuxedAccount(address);
    return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.med25519().ed25519());
}
// Decodes an "M..." account ID into its MuxedAccount object representation.
function _decodeAddressFullyToMuxedAccount(address) {
    var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address);
    // Decoding M... addresses cannot be done through a simple
    // MuxedAccountMed25519.fromXDR() call, because the definition is:
    //
    //    constructor(attributes: { id: Uint64; ed25519: Buffer });
    //
    // Note the ID is the first attribute. However, the ID comes *last* in the
    // stringified (base32-encoded) address itself (it's the last 8-byte suffix).
    // The `fromXDR()` method interprets bytes in order, so we need to parse out
    // the raw binary into its requisite parts, i.e. use the MuxedAccountMed25519
    // constructor directly.
    //
    // Refer to https://github.com/stellar/go/blob/master/xdr/muxed_account.go#L26
    // for the Golang implementation of the M... parsing.
    return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromXDR(rawBytes.subarray(-8)),
        ed25519: rawBytes.subarray(0, -8)
    }));
}
// Converts an xdr.MuxedAccount into its *true* "M..." string representation.
function _encodeMuxedAccountFullyToAddress(muxedAccount) {
    if (muxedAccount["switch"]() === _xdr["default"].CryptoKeyType.keyTypeEd25519()) {
        return encodeMuxedAccountToAddress(muxedAccount);
    }
    var muxed = muxedAccount.med25519();
    return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([
        muxed.ed25519(),
        muxed.id().toXDR('raw')
    ]));
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/account_merge.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.accountMerge = accountMerge;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Transfers native balance to destination account.
 *
 * @function
 * @alias Operation.accountMerge
 *
 * @param {object} opts - options object
 * @param {string} opts.destination - destination to merge the source account into
 * @param {string} [opts.source]    - operation source account (defaults to
 *     transaction source)
 *
 * @returns {xdr.Operation} an Account Merge operation (xdr.AccountMergeOp)
 */ function accountMerge(opts) {
    var opAttributes = {};
    try {
        opAttributes.body = _xdr["default"].OperationBody.accountMerge((0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination));
    } catch (e) {
        throw new Error('destination is invalid');
    }
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.allowTrust = allowTrust;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * @deprecated since v5.0
 *
 * Returns an XDR AllowTrustOp. An "allow trust" operation authorizes another
 * account to hold your account's credit for a given asset.
 *
 * @function
 * @alias Operation.allowTrust
 *
 * @param {object} opts Options object
 * @param {string} opts.trustor - The trusting account (the one being authorized)
 * @param {string} opts.assetCode - The asset code being authorized.
 * @param {(0|1|2)} opts.authorize - `1` to authorize, `2` to authorize to maintain liabilities, and `0` to deauthorize.
 * @param {string} [opts.source] - The source account (defaults to transaction source).
 *
 * @returns {xdr.AllowTrustOp} Allow Trust operation
 */ function allowTrust(opts) {
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.trustor)) {
        throw new Error('trustor is invalid');
    }
    var attributes = {};
    attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
    if (opts.assetCode.length <= 4) {
        var code = opts.assetCode.padEnd(4, '\0');
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum4(code);
    } else if (opts.assetCode.length <= 12) {
        var _code = opts.assetCode.padEnd(12, '\0');
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum12(_code);
    } else {
        throw new Error('Asset code must be 12 characters at max.');
    }
    if (typeof opts.authorize === 'boolean') {
        if (opts.authorize) {
            attributes.authorize = _xdr["default"].TrustLineFlags.authorizedFlag().value;
        } else {
            attributes.authorize = 0;
        }
    } else {
        attributes.authorize = opts.authorize;
    }
    var allowTrustOp = new _xdr["default"].AllowTrustOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.allowTrust(allowTrustOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bumpSequence = bumpSequence;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var _bignumber = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/bignumber.js [app-ssr] (ecmascript)"));
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * This operation bumps sequence number.
 * @function
 * @alias Operation.bumpSequence
 * @param {object} opts Options object
 * @param {string} opts.bumpTo - Sequence number to bump to.
 * @param {string} [opts.source] - The optional source account.
 * @returns {xdr.BumpSequenceOp} Operation
 */ function bumpSequence(opts) {
    var attributes = {};
    if (typeof opts.bumpTo !== 'string') {
        throw new Error('bumpTo must be a string');
    }
    try {
        // eslint-disable-next-line no-new
        new _bignumber["default"](opts.bumpTo);
    } catch (e) {
        throw new Error('bumpTo must be a stringified number');
    }
    attributes.bumpTo = _jsXdr.Hyper.fromString(opts.bumpTo);
    var bumpSequenceOp = new _xdr["default"].BumpSequenceOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.bumpSequence(bumpSequenceOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/change_trust.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeTrust = changeTrust;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var _bignumber = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/bignumber.js [app-ssr] (ecmascript)"));
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)");
var _liquidity_pool_asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
var MAX_INT64 = '9223372036854775807';
/**
 * Returns an XDR ChangeTrustOp. A "change trust" operation adds, removes, or updates a
 * trust line for a given asset from the source account to another.
 * @function
 * @alias Operation.changeTrust
 * @param {object} opts Options object
 * @param {Asset | LiquidityPoolAsset} opts.asset - The asset for the trust line.
 * @param {string} [opts.limit] - The limit for the asset, defaults to max int64.
 *                                If the limit is set to "0" it deletes the trustline.
 * @param {string} [opts.source] - The source account (defaults to transaction source).
 * @returns {xdr.ChangeTrustOp} Change Trust operation
 */ function changeTrust(opts) {
    var attributes = {};
    if (opts.asset instanceof _asset.Asset) {
        attributes.line = opts.asset.toChangeTrustXDRObject();
    } else if (opts.asset instanceof _liquidity_pool_asset.LiquidityPoolAsset) {
        attributes.line = opts.asset.toXDRObject();
    } else {
        throw new TypeError('asset must be Asset or LiquidityPoolAsset');
    }
    if (opts.limit !== undefined && !this.isValidAmount(opts.limit, true)) {
        throw new TypeError(this.constructAmountRequirementsError('limit'));
    }
    if (opts.limit) {
        attributes.limit = this._toXDRAmount(opts.limit);
    } else {
        attributes.limit = _jsXdr.Hyper.fromString(new _bignumber["default"](MAX_INT64).toString());
    }
    if (opts.source) {
        attributes.source = opts.source.masterKeypair;
    }
    var changeTrustOP = new _xdr["default"].ChangeTrustOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.changeTrust(changeTrustOP);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/create_account.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createAccount = createAccount;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Create and fund a non existent account.
 * @function
 * @alias Operation.createAccount
 * @param {object} opts Options object
 * @param {string} opts.destination - Destination account ID to create an account for.
 * @param {string} opts.startingBalance - Amount in XLM the account should be funded for. Must be greater
 *                                   than the [reserve balance amount](https://developers.stellar.org/docs/glossary/fees/).
 * @param {string} [opts.source] - The source account for the payment. Defaults to the transaction's source account.
 * @returns {xdr.CreateAccountOp} Create account operation
 */ function createAccount(opts) {
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.destination)) {
        throw new Error('destination is invalid');
    }
    if (!this.isValidAmount(opts.startingBalance, true)) {
        throw new TypeError(this.constructAmountRequirementsError('startingBalance'));
    }
    var attributes = {};
    attributes.destination = _keypair.Keypair.fromPublicKey(opts.destination).xdrAccountId();
    attributes.startingBalance = this._toXDRAmount(opts.startingBalance);
    var createAccountOp = new _xdr["default"].CreateAccountOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.createAccount(createAccountOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createClaimableBalance = createClaimableBalance;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Create a new claimable balance operation.
 *
 * @function
 * @alias Operation.createClaimableBalance
 *
 * @param {object} opts Options object
 * @param {Asset} opts.asset - The asset for the claimable balance.
 * @param {string} opts.amount - Amount.
 * @param {Claimant[]} opts.claimants - An array of Claimants
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 *
 * @returns {xdr.Operation} Create claimable balance operation
 *
 * @example
 * const asset = new Asset(
 *   'USD',
 *   'GDGU5OAPHNPU5UCLE5RDJHG7PXZFQYWKCFOEXSXNMR6KRQRI5T6XXCD7'
 * );
 * const amount = '100.0000000';
 * const claimants = [
 *   new Claimant(
 *     'GCEZWKCA5VLDNRLN3RPRJMRZOX3Z6G5CHCGSNFHEYVXM3XOJMDS674JZ',
 *      Claimant.predicateBeforeAbsoluteTime("4102444800000")
 *   )
 * ];
 *
 * const op = Operation.createClaimableBalance({
 *   asset,
 *   amount,
 *   claimants
 * });
 *
 */ function createClaimableBalance(opts) {
    if (!(opts.asset instanceof _asset.Asset)) {
        throw new Error('must provide an asset for create claimable balance operation');
    }
    if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError('amount'));
    }
    if (!Array.isArray(opts.claimants) || opts.claimants.length === 0) {
        throw new Error('must provide at least one claimant');
    }
    var attributes = {};
    attributes.asset = opts.asset.toXDRObject();
    attributes.amount = this._toXDRAmount(opts.amount);
    attributes.claimants = Object.values(opts.claimants).map(function(c) {
        return c.toXDRObject();
    });
    var createClaimableBalanceOp = new _xdr["default"].CreateClaimableBalanceOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.createClaimableBalance(createClaimableBalanceOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.claimClaimableBalance = claimClaimableBalance;
exports.validateClaimableBalanceId = validateClaimableBalanceId;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Create a new claim claimable balance operation.
 * @function
 * @alias Operation.claimClaimableBalance
 * @param {object} opts Options object
 * @param {string} opts.balanceId - The claimable balance id to be claimed.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} Claim claimable balance operation
 *
 * @example
 * const op = Operation.claimClaimableBalance({
 *   balanceId: '00000000da0d57da7d4850e7fc10d2a9d0ebc731f7afb40574c03395b17d49149b91f5be',
 * });
 *
 */ function claimClaimableBalance() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    validateClaimableBalanceId(opts.balanceId);
    var attributes = {};
    attributes.balanceId = _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, 'hex');
    var claimClaimableBalanceOp = new _xdr["default"].ClaimClaimableBalanceOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.claimClaimableBalance(claimClaimableBalanceOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
function validateClaimableBalanceId(balanceId) {
    if (typeof balanceId !== 'string' || balanceId.length !== 8 + 64 /* 8b discriminant + 64b string */ ) {
        throw new Error('must provide a valid claimable balance id');
    }
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.clawbackClaimableBalance = clawbackClaimableBalance;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _claim_claimable_balance = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Creates a clawback operation for a claimable balance.
 *
 * @function
 * @alias Operation.clawbackClaimableBalance
 * @param {object} opts - Options object
 * @param {string} opts.balanceId - The claimable balance ID to be clawed back.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 *
 * @return {xdr.ClawbackClaimableBalanceOp}
 *
 * @example
 * const op = Operation.clawbackClaimableBalance({
 *   balanceId: '00000000da0d57da7d4850e7fc10d2a9d0ebc731f7afb40574c03395b17d49149b91f5be',
 * });
 *
 * @link https://github.com/stellar/stellar-protocol/blob/master/core/cap-0035.md#clawback-claimable-balance-operation
 */ function clawbackClaimableBalance() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _claim_claimable_balance.validateClaimableBalanceId)(opts.balanceId);
    var attributes = {
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, 'hex')
    };
    var opAttributes = {
        body: _xdr["default"].OperationBody.clawbackClaimableBalance(new _xdr["default"].ClawbackClaimableBalanceOp(attributes))
    };
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/inflation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.inflation = inflation;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * This operation generates the inflation.
 * @function
 * @alias Operation.inflation
 * @param {object} [opts] Options object
 * @param {string} [opts.source] - The optional source account.
 * @returns {xdr.InflationOp} Inflation operation
 */ function inflation() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.inflation();
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/manage_data.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.manageData = manageData;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * This operation adds data entry to the ledger.
 * @function
 * @alias Operation.manageData
 * @param {object} opts Options object
 * @param {string} opts.name - The name of the data entry.
 * @param {string|Buffer} opts.value - The value of the data entry.
 * @param {string} [opts.source] - The optional source account.
 * @returns {xdr.ManageDataOp} Manage Data operation
 */ function manageData(opts) {
    var attributes = {};
    if (!(typeof opts.name === 'string' && opts.name.length <= 64)) {
        throw new Error('name must be a string, up to 64 characters');
    }
    attributes.dataName = opts.name;
    if (typeof opts.value !== 'string' && !Buffer.isBuffer(opts.value) && opts.value !== null) {
        throw new Error('value must be a string, Buffer or null');
    }
    if (typeof opts.value === 'string') {
        attributes.dataValue = Buffer.from(opts.value);
    } else {
        attributes.dataValue = opts.value;
    }
    if (attributes.dataValue !== null && attributes.dataValue.length > 64) {
        throw new Error('value cannot be longer that 64 bytes');
    }
    var manageDataOp = new _xdr["default"].ManageDataOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.manageData(manageDataOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.manageBuyOffer = manageBuyOffer;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Returns a XDR ManageBuyOfferOp. A "manage buy offer" operation creates, updates, or
 * deletes a buy offer.
 * @function
 * @alias Operation.manageBuyOffer
 * @param {object} opts Options object
 * @param {Asset} opts.selling - What you're selling.
 * @param {Asset} opts.buying - What you're buying.
 * @param {string} opts.buyAmount - The total amount you're buying. If 0, deletes the offer.
 * @param {number|string|BigNumber|Object} opts.price - Price of 1 unit of `buying` in terms of `selling`.
 * @param {number} opts.price.n - If `opts.price` is an object: the price numerator
 * @param {number} opts.price.d - If `opts.price` is an object: the price denominator
 * @param {number|string} [opts.offerId ] - If `0`, will create a new offer (default). Otherwise, edits an exisiting offer.
 * @param {string} [opts.source] - The source account (defaults to transaction source).
 * @throws {Error} Throws `Error` when the best rational approximation of `price` cannot be found.
 * @returns {xdr.ManageBuyOfferOp} Manage Buy Offer operation
 */ function manageBuyOffer(opts) {
    var attributes = {};
    attributes.selling = opts.selling.toXDRObject();
    attributes.buying = opts.buying.toXDRObject();
    if (!this.isValidAmount(opts.buyAmount, true)) {
        throw new TypeError(this.constructAmountRequirementsError('buyAmount'));
    }
    attributes.buyAmount = this._toXDRAmount(opts.buyAmount);
    if (opts.price === undefined) {
        throw new TypeError('price argument is required');
    }
    attributes.price = this._toXDRPrice(opts.price);
    if (opts.offerId !== undefined) {
        opts.offerId = opts.offerId.toString();
    } else {
        opts.offerId = '0';
    }
    attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
    var manageBuyOfferOp = new _xdr["default"].ManageBuyOfferOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.manageBuyOffer(manageBuyOfferOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pathPaymentStrictReceive = pathPaymentStrictReceive;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Creates a PathPaymentStrictReceive operation.
 *
 * A `PathPaymentStrictReceive` operation sends the specified amount to the
 * destination account. It credits the destination with `destAmount` of
 * `destAsset`, while debiting at most `sendMax` of `sendAsset` from the source.
 * The transfer optionally occurs through a path. XLM payments create the
 * destination account if it does not exist.
 *
 * @function
 * @alias Operation.pathPaymentStrictReceive
 * @see https://developers.stellar.org/docs/start/list-of-operations/#path-payment-strict-receive
 *
 * @param {object}  opts - Options object
 * @param {Asset}   opts.sendAsset    - asset to pay with
 * @param {string}  opts.sendMax      - maximum amount of sendAsset to send
 * @param {string}  opts.destination  - destination account to send to
 * @param {Asset}   opts.destAsset    - asset the destination will receive
 * @param {string}  opts.destAmount   - amount the destination receives
 * @param {Asset[]} opts.path         - array of Asset objects to use as the path
 *
 * @param {string}  [opts.source]     - The source account for the payment.
 *     Defaults to the transaction's source account.
 *
 * @returns {xdr.PathPaymentStrictReceiveOp} the resulting path payment op
 */ function pathPaymentStrictReceive(opts) {
    switch(true){
        case !opts.sendAsset:
            throw new Error('Must specify a send asset');
        case !this.isValidAmount(opts.sendMax):
            throw new TypeError(this.constructAmountRequirementsError('sendMax'));
        case !opts.destAsset:
            throw new Error('Must provide a destAsset for a payment operation');
        case !this.isValidAmount(opts.destAmount):
            throw new TypeError(this.constructAmountRequirementsError('destAmount'));
        default:
            break;
    }
    var attributes = {};
    attributes.sendAsset = opts.sendAsset.toXDRObject();
    attributes.sendMax = this._toXDRAmount(opts.sendMax);
    try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
    } catch (e) {
        throw new Error('destination is invalid');
    }
    attributes.destAsset = opts.destAsset.toXDRObject();
    attributes.destAmount = this._toXDRAmount(opts.destAmount);
    var path = opts.path ? opts.path : [];
    attributes.path = path.map(function(x) {
        return x.toXDRObject();
    });
    var payment = new _xdr["default"].PathPaymentStrictReceiveOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictReceive(payment);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pathPaymentStrictSend = pathPaymentStrictSend;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Creates a PathPaymentStrictSend operation.
 *
 * A `PathPaymentStrictSend` operation sends the specified amount to the
 * destination account crediting at least `destMin` of `destAsset`, optionally
 * through a path. XLM payments create the destination account if it does not
 * exist.
 *
 * @function
 * @alias Operation.pathPaymentStrictSend
 * @see https://developers.stellar.org/docs/start/list-of-operations/#path-payment-strict-send
 *
 * @param {object}  opts - Options object
 * @param {Asset}   opts.sendAsset    - asset to pay with
 * @param {string}  opts.sendAmount   - amount of sendAsset to send (excluding fees)
 * @param {string}  opts.destination  - destination account to send to
 * @param {Asset}   opts.destAsset    - asset the destination will receive
 * @param {string}  opts.destMin      - minimum amount of destAsset to be receive
 * @param {Asset[]} opts.path         - array of Asset objects to use as the path
 *
 * @param {string}  [opts.source]     - The source account for the payment.
 *     Defaults to the transaction's source account.
 *
 * @returns {xdr.Operation}   the resulting path payment operation
 *     (xdr.PathPaymentStrictSendOp)
 */ function pathPaymentStrictSend(opts) {
    switch(true){
        case !opts.sendAsset:
            throw new Error('Must specify a send asset');
        case !this.isValidAmount(opts.sendAmount):
            throw new TypeError(this.constructAmountRequirementsError('sendAmount'));
        case !opts.destAsset:
            throw new Error('Must provide a destAsset for a payment operation');
        case !this.isValidAmount(opts.destMin):
            throw new TypeError(this.constructAmountRequirementsError('destMin'));
        default:
            break;
    }
    var attributes = {};
    attributes.sendAsset = opts.sendAsset.toXDRObject();
    attributes.sendAmount = this._toXDRAmount(opts.sendAmount);
    try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
    } catch (e) {
        throw new Error('destination is invalid');
    }
    attributes.destAsset = opts.destAsset.toXDRObject();
    attributes.destMin = this._toXDRAmount(opts.destMin);
    var path = opts.path ? opts.path : [];
    attributes.path = path.map(function(x) {
        return x.toXDRObject();
    });
    var payment = new _xdr["default"].PathPaymentStrictSendOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictSend(payment);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/payment.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.payment = payment;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Create a payment operation.
 *
 * @function
 * @alias Operation.payment
 * @see https://developers.stellar.org/docs/start/list-of-operations/#payment
 *
 * @param {object}  opts - Options object
 * @param {string}  opts.destination  - destination account ID
 * @param {Asset}   opts.asset        - asset to send
 * @param {string}  opts.amount       - amount to send
 *
 * @param {string}  [opts.source]     - The source account for the payment.
 *     Defaults to the transaction's source account.
 *
 * @returns {xdr.Operation}   The resulting payment operation (xdr.PaymentOp)
 */ function payment(opts) {
    if (!opts.asset) {
        throw new Error('Must provide an asset for a payment operation');
    }
    if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError('amount'));
    }
    var attributes = {};
    try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
    } catch (e) {
        throw new Error('destination is invalid');
    }
    attributes.asset = opts.asset.toXDRObject();
    attributes.amount = this._toXDRAmount(opts.amount);
    var paymentOp = new _xdr["default"].PaymentOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.payment(paymentOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/set_options.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setOptions = setOptions;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/* eslint-disable no-param-reassign */ function weightCheckFunction(value, name) {
    if (value >= 0 && value <= 255) {
        return true;
    }
    throw new Error("".concat(name, " value must be between 0 and 255"));
}
/**
 * Returns an XDR SetOptionsOp. A "set options" operations set or clear account flags,
 * set the account's inflation destination, and/or add new signers to the account.
 * The flags used in `opts.clearFlags` and `opts.setFlags` can be the following:
 *   - `{@link AuthRequiredFlag}`
 *   - `{@link AuthRevocableFlag}`
 *   - `{@link AuthImmutableFlag}`
 *   - `{@link AuthClawbackEnabledFlag}`
 *
 * It's possible to set/clear multiple flags at once using logical or.
 *
 * @function
 * @alias Operation.setOptions
 *
 * @param {object} opts Options object
 * @param {string} [opts.inflationDest] - Set this account ID as the account's inflation destination.
 * @param {(number|string)} [opts.clearFlags] - Bitmap integer for which account flags to clear.
 * @param {(number|string)} [opts.setFlags] - Bitmap integer for which account flags to set.
 * @param {number|string} [opts.masterWeight] - The master key weight.
 * @param {number|string} [opts.lowThreshold] - The sum weight for the low threshold.
 * @param {number|string} [opts.medThreshold] - The sum weight for the medium threshold.
 * @param {number|string} [opts.highThreshold] - The sum weight for the high threshold.
 * @param {object} [opts.signer] - Add or remove a signer from the account. The signer is
 *                                 deleted if the weight is 0. Only one of `ed25519PublicKey`, `sha256Hash`, `preAuthTx` should be defined.
 * @param {string} [opts.signer.ed25519PublicKey] - The ed25519 public key of the signer.
 * @param {Buffer|string} [opts.signer.sha256Hash] - sha256 hash (Buffer or hex string) of preimage that will unlock funds. Preimage should be used as signature of future transaction.
 * @param {Buffer|string} [opts.signer.preAuthTx] - Hash (Buffer or hex string) of transaction that will unlock funds.
 * @param {string} [opts.signer.ed25519SignedPayload] - Signed payload signer (ed25519 public key + raw payload) for atomic transaction signature disclosure.
 * @param {number|string} [opts.signer.weight] - The weight of the new signer (0 to delete or 1-255)
 * @param {string} [opts.homeDomain] - sets the home domain used for reverse federation lookup.
 * @param {string} [opts.source] - The source account (defaults to transaction source).
 *
 * @returns {xdr.SetOptionsOp}  XDR operation
 * @see [Account flags](https://developers.stellar.org/docs/glossary/accounts/#flags)
 */ function setOptions(opts) {
    var attributes = {};
    if (opts.inflationDest) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.inflationDest)) {
            throw new Error('inflationDest is invalid');
        }
        attributes.inflationDest = _keypair.Keypair.fromPublicKey(opts.inflationDest).xdrAccountId();
    }
    attributes.clearFlags = this._checkUnsignedIntValue('clearFlags', opts.clearFlags);
    attributes.setFlags = this._checkUnsignedIntValue('setFlags', opts.setFlags);
    attributes.masterWeight = this._checkUnsignedIntValue('masterWeight', opts.masterWeight, weightCheckFunction);
    attributes.lowThreshold = this._checkUnsignedIntValue('lowThreshold', opts.lowThreshold, weightCheckFunction);
    attributes.medThreshold = this._checkUnsignedIntValue('medThreshold', opts.medThreshold, weightCheckFunction);
    attributes.highThreshold = this._checkUnsignedIntValue('highThreshold', opts.highThreshold, weightCheckFunction);
    if (opts.homeDomain !== undefined && typeof opts.homeDomain !== 'string') {
        throw new TypeError('homeDomain argument must be of type String');
    }
    attributes.homeDomain = opts.homeDomain;
    if (opts.signer) {
        var weight = this._checkUnsignedIntValue('signer.weight', opts.signer.weight, weightCheckFunction);
        var key;
        var setValues = 0;
        if (opts.signer.ed25519PublicKey) {
            if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
                throw new Error('signer.ed25519PublicKey is invalid.');
            }
            var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
            // eslint-disable-next-line new-cap
            key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
            setValues += 1;
        }
        if (opts.signer.preAuthTx) {
            if (typeof opts.signer.preAuthTx === 'string') {
                opts.signer.preAuthTx = Buffer.from(opts.signer.preAuthTx, 'hex');
            }
            if (!(Buffer.isBuffer(opts.signer.preAuthTx) && opts.signer.preAuthTx.length === 32)) {
                throw new Error('signer.preAuthTx must be 32 bytes Buffer.');
            }
            // eslint-disable-next-line new-cap
            key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(opts.signer.preAuthTx);
            setValues += 1;
        }
        if (opts.signer.sha256Hash) {
            if (typeof opts.signer.sha256Hash === 'string') {
                opts.signer.sha256Hash = Buffer.from(opts.signer.sha256Hash, 'hex');
            }
            if (!(Buffer.isBuffer(opts.signer.sha256Hash) && opts.signer.sha256Hash.length === 32)) {
                throw new Error('signer.sha256Hash must be 32 bytes Buffer.');
            }
            // eslint-disable-next-line new-cap
            key = new _xdr["default"].SignerKey.signerKeyTypeHashX(opts.signer.sha256Hash);
            setValues += 1;
        }
        if (opts.signer.ed25519SignedPayload) {
            if (!_strkey.StrKey.isValidSignedPayload(opts.signer.ed25519SignedPayload)) {
                throw new Error('signer.ed25519SignedPayload is invalid.');
            }
            var _rawKey = _strkey.StrKey.decodeSignedPayload(opts.signer.ed25519SignedPayload);
            var signedPayloadXdr = _xdr["default"].SignerKeyEd25519SignedPayload.fromXDR(_rawKey);
            // eslint-disable-next-line new-cap
            key = _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload(signedPayloadXdr);
            setValues += 1;
        }
        if (setValues !== 1) {
            throw new Error('Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.');
        }
        attributes.signer = new _xdr["default"].Signer({
            key: key,
            weight: weight
        });
    }
    var setOptionsOp = new _xdr["default"].SetOptionsOp(attributes);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.setOptions(setOptionsOp);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.beginSponsoringFutureReserves = beginSponsoringFutureReserves;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Create a "begin sponsoring future reserves" operation.
 * @function
 * @alias Operation.beginSponsoringFutureReserves
 * @param {object} opts Options object
 * @param {string} opts.sponsoredId - The sponsored account id.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} xdr operation
 *
 * @example
 * const op = Operation.beginSponsoringFutureReserves({
 *   sponsoredId: 'GDGU5OAPHNPU5UCLE5RDJHG7PXZFQYWKCFOEXSXNMR6KRQRI5T6XXCD7'
 * });
 *
 */ function beginSponsoringFutureReserves() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.sponsoredId)) {
        throw new Error('sponsoredId is invalid');
    }
    var op = new _xdr["default"].BeginSponsoringFutureReservesOp({
        sponsoredId: _keypair.Keypair.fromPublicKey(opts.sponsoredId).xdrAccountId()
    });
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.beginSponsoringFutureReserves(op);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.endSponsoringFutureReserves = endSponsoringFutureReserves;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Create an "end sponsoring future reserves" operation.
 * @function
 * @alias Operation.endSponsoringFutureReserves
 * @param {object} opts Options object
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} xdr operation
 *
 * @example
 * const op = Operation.endSponsoringFutureReserves();
 *
 */ function endSponsoringFutureReserves() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.endSponsoringFutureReserves();
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.revokeAccountSponsorship = revokeAccountSponsorship;
exports.revokeClaimableBalanceSponsorship = revokeClaimableBalanceSponsorship;
exports.revokeDataSponsorship = revokeDataSponsorship;
exports.revokeLiquidityPoolSponsorship = revokeLiquidityPoolSponsorship;
exports.revokeOfferSponsorship = revokeOfferSponsorship;
exports.revokeSignerSponsorship = revokeSignerSponsorship;
exports.revokeTrustlineSponsorship = revokeTrustlineSponsorship;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)");
var _liquidity_pool_id = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Create a "revoke sponsorship" operation for an account.
 *
 * @function
 * @alias Operation.revokeAccountSponsorship
 * @param {object} opts Options object
 * @param {string} opts.account - The sponsored account ID.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} xdr operation
 *
 * @example
 * const op = Operation.revokeAccountSponsorship({
 *   account: 'GDGU5OAPHNPU5UCLE5RDJHG7PXZFQYWKCFOEXSXNMR6KRQRI5T6XXCD7
 * });
 *
 */ function revokeAccountSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error('account is invalid');
    }
    var ledgerKey = _xdr["default"].LedgerKey.account(new _xdr["default"].LedgerKeyAccount({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId()
    }));
    var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
/**
 * Create a "revoke sponsorship" operation for a trustline.
 *
 * @function
 * @alias Operation.revokeTrustlineSponsorship
 * @param {object} opts Options object
 * @param {string} opts.account - The account ID which owns the trustline.
 * @param {Asset | LiquidityPoolId} opts.asset - The trustline asset.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} xdr operation
 *
 * @example
 * const op = Operation.revokeTrustlineSponsorship({
 *   account: 'GDGU5OAPHNPU5UCLE5RDJHG7PXZFQYWKCFOEXSXNMR6KRQRI5T6XXCD7
 *   asset: new StellarBase.LiquidityPoolId(
 *     'USDUSD',
 *     'GDGU5OAPHNPU5UCLE5RDJHG7PXZFQYWKCFOEXSXNMR6KRQRI5T6XXCD7'
 *   )
 * });
 *
 */ function revokeTrustlineSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error('account is invalid');
    }
    var asset;
    if (opts.asset instanceof _asset.Asset) {
        asset = opts.asset.toTrustLineXDRObject();
    } else if (opts.asset instanceof _liquidity_pool_id.LiquidityPoolId) {
        asset = opts.asset.toXDRObject();
    } else {
        throw new TypeError('asset must be an Asset or LiquidityPoolId');
    }
    var ledgerKey = _xdr["default"].LedgerKey.trustline(new _xdr["default"].LedgerKeyTrustLine({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        asset: asset
    }));
    var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
/**
 * Create a "revoke sponsorship" operation for an offer.
 *
 * @function
 * @alias Operation.revokeOfferSponsorship
 * @param {object} opts Options object
 * @param {string} opts.seller - The account ID which created the offer.
 * @param {string} opts.offerId - The offer ID.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} xdr operation
 *
 * @example
 * const op = Operation.revokeOfferSponsorship({
 *   seller: 'GDGU5OAPHNPU5UCLE5RDJHG7PXZFQYWKCFOEXSXNMR6KRQRI5T6XXCD7
 *   offerId: '1234'
 * });
 *
 */ function revokeOfferSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.seller)) {
        throw new Error('seller is invalid');
    }
    if (typeof opts.offerId !== 'string') {
        throw new Error('offerId is invalid');
    }
    var ledgerKey = _xdr["default"].LedgerKey.offer(new _xdr["default"].LedgerKeyOffer({
        sellerId: _keypair.Keypair.fromPublicKey(opts.seller).xdrAccountId(),
        offerId: _xdr["default"].Int64.fromString(opts.offerId)
    }));
    var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
/**
 * Create a "revoke sponsorship" operation for a data entry.
 *
 * @function
 * @alias Operation.revokeDataSponsorship
 * @param {object} opts Options object
 * @param {string} opts.account - The account ID which owns the data entry.
 * @param {string} opts.name - The name of the data entry
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} xdr operation
 *
 * @example
 * const op = Operation.revokeDataSponsorship({
 *   account: 'GDGU5OAPHNPU5UCLE5RDJHG7PXZFQYWKCFOEXSXNMR6KRQRI5T6XXCD7
 *   name: 'foo'
 * });
 *
 */ function revokeDataSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error('account is invalid');
    }
    if (typeof opts.name !== 'string' || opts.name.length > 64) {
        throw new Error('name must be a string, up to 64 characters');
    }
    var ledgerKey = _xdr["default"].LedgerKey.data(new _xdr["default"].LedgerKeyData({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        dataName: opts.name
    }));
    var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
/**
 * Create a "revoke sponsorship" operation for a claimable balance.
 *
 * @function
 * @alias Operation.revokeClaimableBalanceSponsorship
 * @param {object} opts Options object
 * @param {string} opts.balanceId - The sponsored claimable balance ID.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} xdr operation
 *
 * @example
 * const op = Operation.revokeClaimableBalanceSponsorship({
 *   balanceId: '00000000da0d57da7d4850e7fc10d2a9d0ebc731f7afb40574c03395b17d49149b91f5be',
 * });
 *
 */ function revokeClaimableBalanceSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (typeof opts.balanceId !== 'string') {
        throw new Error('balanceId is invalid');
    }
    var ledgerKey = _xdr["default"].LedgerKey.claimableBalance(new _xdr["default"].LedgerKeyClaimableBalance({
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, 'hex')
    }));
    var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
/**
 * Creates a "revoke sponsorship" operation for a liquidity pool.
 *
 * @function
 * @alias Operation.revokeLiquidityPoolSponsorship
 * @param {object} opts – Options object.
 * @param {string} opts.liquidityPoolId - The sponsored liquidity pool ID in 'hex' string.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} xdr Operation.
 *
 * @example
 * const op = Operation.revokeLiquidityPoolSponsorship({
 *   liquidityPoolId: 'dd7b1ab831c273310ddbec6f97870aa83c2fbd78ce22aded37ecbf4f3380fac7',
 * });
 *
 */ function revokeLiquidityPoolSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (typeof opts.liquidityPoolId !== 'string') {
        throw new Error('liquidityPoolId is invalid');
    }
    var ledgerKey = _xdr["default"].LedgerKey.liquidityPool(new _xdr["default"].LedgerKeyLiquidityPool({
        liquidityPoolId: _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, 'hex')
    }));
    var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
    var opAttributes = {
        body: _xdr["default"].OperationBody.revokeSponsorship(op)
    };
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
/**
 * Create a "revoke sponsorship" operation for a signer.
 *
 * @function
 * @alias Operation.revokeSignerSponsorship
 * @param {object} opts Options object
 * @param {string} opts.account - The account ID where the signer sponsorship is being removed from.
 * @param {object} opts.signer - The signer whose sponsorship is being removed.
 * @param {string} [opts.signer.ed25519PublicKey] - The ed25519 public key of the signer.
 * @param {Buffer|string} [opts.signer.sha256Hash] - sha256 hash (Buffer or hex string).
 * @param {Buffer|string} [opts.signer.preAuthTx] - Hash (Buffer or hex string) of transaction.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 * @returns {xdr.Operation} xdr operation
 *
 * @example
 * const op = Operation.revokeSignerSponsorship({
 *   account: 'GDGU5OAPHNPU5UCLE5RDJHG7PXZFQYWKCFOEXSXNMR6KRQRI5T6XXCD7
 *   signer: {
 *     ed25519PublicKey: 'GCEZWKCA5VLDNRLN3RPRJMRZOX3Z6G5CHCGSNFHEYVXM3XOJMDS674JZ'
 *   }
 * })
 *
 */ function revokeSignerSponsorship() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error('account is invalid');
    }
    var key;
    if (opts.signer.ed25519PublicKey) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
            throw new Error('signer.ed25519PublicKey is invalid.');
        }
        var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
        key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
    } else if (opts.signer.preAuthTx) {
        var buffer;
        if (typeof opts.signer.preAuthTx === 'string') {
            buffer = Buffer.from(opts.signer.preAuthTx, 'hex');
        } else {
            buffer = opts.signer.preAuthTx;
        }
        if (!(Buffer.isBuffer(buffer) && buffer.length === 32)) {
            throw new Error('signer.preAuthTx must be 32 bytes Buffer.');
        }
        key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(buffer);
    } else if (opts.signer.sha256Hash) {
        var _buffer;
        if (typeof opts.signer.sha256Hash === 'string') {
            _buffer = Buffer.from(opts.signer.sha256Hash, 'hex');
        } else {
            _buffer = opts.signer.sha256Hash;
        }
        if (!(Buffer.isBuffer(_buffer) && _buffer.length === 32)) {
            throw new Error('signer.sha256Hash must be 32 bytes Buffer.');
        }
        key = new _xdr["default"].SignerKey.signerKeyTypeHashX(_buffer);
    } else {
        throw new Error('signer is invalid');
    }
    var signer = new _xdr["default"].RevokeSponsorshipOpSigner({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        signerKey: key
    });
    var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipSigner(signer);
    var opAttributes = {};
    opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/clawback.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.clawback = clawback;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Creates a clawback operation.
 *
 * @function
 * @alias Operation.clawback
 *
 * @param {object} opts - Options object
 * @param {Asset}  opts.asset   - The asset being clawed back.
 * @param {string} opts.amount  - The amount of the asset to claw back.
 * @param {string} opts.from    - The public key of the (optionally-muxed)
 *     account to claw back from.
 *
 * @param {string} [opts.source] - The source account for the operation.
 *     Defaults to the transaction's source account.
 *
 * @return {xdr.ClawbackOp}
 *
 * @see https://github.com/stellar/stellar-protocol/blob/master/core/cap-0035.md#clawback-operation
 */ function clawback(opts) {
    var attributes = {};
    if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError('amount'));
    }
    attributes.amount = this._toXDRAmount(opts.amount);
    attributes.asset = opts.asset.toXDRObject();
    try {
        attributes.from = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.from);
    } catch (e) {
        throw new Error('from address is invalid');
    }
    var opAttributes = {
        body: _xdr["default"].OperationBody.clawback(new _xdr["default"].ClawbackOp(attributes))
    };
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setTrustLineFlags = setTrustLineFlags;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
/**
 * Creates a trustline flag configuring operation.
 *
 * For the flags, set them to true to enable them and false to disable them. Any
 * unmodified operations will be marked `undefined` in the result.
 *
 * Note that you can only **clear** the clawbackEnabled flag set; it must be set
 * account-wide via operations.SetOptions (setting
 * xdr.AccountFlags.clawbackEnabled).
 *
 * @function
 * @alias Operation.setTrustLineFlags
 *
 * @param {object} opts - Options object
 * @param {string} opts.trustor     - the account whose trustline this is
 * @param {Asset}  opts.asset       - the asset on the trustline
 * @param {object} opts.flags       - the set of flags to modify
 *
 * @param {bool}   [opts.flags.authorized]  - authorize account to perform
 *     transactions with its credit
 * @param {bool}   [opts.flags.authorizedToMaintainLiabilities] - authorize
 *     account to maintain and reduce liabilities for its credit
 * @param {bool}   [opts.flags.clawbackEnabled] - stop claimable balances on
 *     this trustlines from having clawbacks enabled (this flag can only be set
 *     to false!)
 * @param {string} [opts.source] - The source account for the operation.
 *                                 Defaults to the transaction's source account.
 *
 * @note You must include at least one flag.
 *
 * @return {xdr.SetTrustLineFlagsOp}
 *
 * @link xdr.AccountFlags
 * @link xdr.TrustLineFlags
 * @see https://github.com/stellar/stellar-protocol/blob/master/core/cap-0035.md#set-trustline-flags-operation
 * @see https://developers.stellar.org/docs/start/list-of-operations/#set-options
 */ function setTrustLineFlags() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var attributes = {};
    if (_typeof(opts.flags) !== 'object' || Object.keys(opts.flags).length === 0) {
        throw new Error('opts.flags must be a map of boolean flags to modify');
    }
    var mapping = {
        authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
        authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
        clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
    };
    /* eslint no-bitwise: "off" */ var clearFlag = 0;
    var setFlag = 0;
    Object.keys(opts.flags).forEach(function(flagName) {
        if (!Object.prototype.hasOwnProperty.call(mapping, flagName)) {
            throw new Error("unsupported flag name specified: ".concat(flagName));
        }
        var flagValue = opts.flags[flagName];
        var bit = mapping[flagName].value;
        if (flagValue === true) {
            setFlag |= bit;
        } else if (flagValue === false) {
            clearFlag |= bit;
        }
    });
    attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
    attributes.asset = opts.asset.toXDRObject();
    attributes.clearFlags = clearFlag;
    attributes.setFlags = setFlag;
    var opAttributes = {
        body: _xdr["default"].OperationBody.setTrustLineFlags(new _xdr["default"].SetTrustLineFlagsOp(attributes))
    };
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.liquidityPoolDeposit = liquidityPoolDeposit;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Creates a liquidity pool deposit operation.
 *
 * @function
 * @alias Operation.liquidityPoolDeposit
 * @see https://developers.stellar.org/docs/start/list-of-operations/#liquidity-pool-deposit
 *
 * @param {object} opts - Options object
 * @param {string} opts.liquidityPoolId - The liquidity pool ID.
 * @param {string} opts.maxAmountA - Maximum amount of first asset to deposit.
 * @param {string} opts.maxAmountB - Maximum amount of second asset to deposit.
 * @param {number|string|BigNumber|Object} opts.minPrice -  Minimum depositA/depositB price.
 * @param {number} opts.minPrice.n - If `opts.minPrice` is an object: the price numerator
 * @param {number} opts.minPrice.d - If `opts.minPrice` is an object: the price denominator
 * @param {number|string|BigNumber|Object} opts.maxPrice -  Maximum depositA/depositB price.
 * @param {number} opts.maxPrice.n - If `opts.maxPrice` is an object: the price numerator
 * @param {number} opts.maxPrice.d - If `opts.maxPrice` is an object: the price denominator
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 *
 * @returns {xdr.Operation} The resulting operation (xdr.LiquidityPoolDepositOp).
 */ function liquidityPoolDeposit() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var liquidityPoolId = opts.liquidityPoolId, maxAmountA = opts.maxAmountA, maxAmountB = opts.maxAmountB, minPrice = opts.minPrice, maxPrice = opts.maxPrice;
    var attributes = {};
    if (!liquidityPoolId) {
        throw new TypeError('liquidityPoolId argument is required');
    }
    attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(liquidityPoolId, 'hex');
    if (!this.isValidAmount(maxAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError('maxAmountA'));
    }
    attributes.maxAmountA = this._toXDRAmount(maxAmountA);
    if (!this.isValidAmount(maxAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError('maxAmountB'));
    }
    attributes.maxAmountB = this._toXDRAmount(maxAmountB);
    if (minPrice === undefined) {
        throw new TypeError('minPrice argument is required');
    }
    attributes.minPrice = this._toXDRPrice(minPrice);
    if (maxPrice === undefined) {
        throw new TypeError('maxPrice argument is required');
    }
    attributes.maxPrice = this._toXDRPrice(maxPrice);
    var liquidityPoolDepositOp = new _xdr["default"].LiquidityPoolDepositOp(attributes);
    var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolDeposit(liquidityPoolDepositOp)
    };
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.liquidityPoolWithdraw = liquidityPoolWithdraw;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Creates a liquidity pool withdraw operation.
 *
 * @function
 * @alias Operation.liquidityPoolWithdraw
 * @see https://developers.stellar.org/docs/start/list-of-operations/#liquidity-pool-withdraw
 *
 * @param {object} opts - Options object
 * @param {string} opts.liquidityPoolId - The liquidity pool ID.
 * @param {string} opts.amount - Amount of pool shares to withdraw.
 * @param {string} opts.minAmountA - Minimum amount of first asset to withdraw.
 * @param {string} opts.minAmountB - Minimum amount of second asset to withdraw.
 * @param {string} [opts.source] - The source account for the operation. Defaults to the transaction's source account.
 *
 * @returns {xdr.Operation}   The resulting operation (xdr.LiquidityPoolWithdrawOp).
 */ function liquidityPoolWithdraw() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var attributes = {};
    if (!opts.liquidityPoolId) {
        throw new TypeError('liquidityPoolId argument is required');
    }
    attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, 'hex');
    if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError('amount'));
    }
    attributes.amount = this._toXDRAmount(opts.amount);
    if (!this.isValidAmount(opts.minAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError('minAmountA'));
    }
    attributes.minAmountA = this._toXDRAmount(opts.minAmountA);
    if (!this.isValidAmount(opts.minAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError('minAmountB'));
    }
    attributes.minAmountB = this._toXDRAmount(opts.minAmountB);
    var liquidityPoolWithdrawOp = new _xdr["default"].LiquidityPoolWithdrawOp(attributes);
    var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolWithdraw(liquidityPoolWithdrawOp)
    };
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/address.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Address = void 0;
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Create a new Address object.
 *
 * `Address` represents a single address in the Stellar network. An address can
 * represent an account or a contract.
 *
 * @constructor
 *
 * @param {string} address - ID of the account (ex.
 *     `GB3KJPLFUYN5VL6R3GU3EGCGVCKFDSD7BEDX42HWG5BWFKB3KQGJJRMA`). If you
 *     provide a muxed account address, this will throw; use {@link
 *     MuxedAccount} instead.
 */ var Address = exports.Address = /*#__PURE__*/ function() {
    function Address(address) {
        _classCallCheck(this, Address);
        if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
            this._type = 'account';
            this._key = _strkey.StrKey.decodeEd25519PublicKey(address);
        } else if (_strkey.StrKey.isValidContract(address)) {
            this._type = 'contract';
            this._key = _strkey.StrKey.decodeContract(address);
        } else {
            throw new Error("Unsupported address type: ".concat(address));
        }
    }
    /**
   * Parses a string and returns an Address object.
   *
   * @param {string} address - The address to parse. ex. `GB3KJPLFUYN5VL6R3GU3EGCGVCKFDSD7BEDX42HWG5BWFKB3KQGJJRMA`
   * @returns {Address}
   */ return _createClass(Address, [
        {
            key: "toString",
            value: /**
     * Serialize an address to string.
     *
     * @returns {string}
     */ function toString() {
                switch(this._type){
                    case 'account':
                        return _strkey.StrKey.encodeEd25519PublicKey(this._key);
                    case 'contract':
                        return _strkey.StrKey.encodeContract(this._key);
                    default:
                        throw new Error('Unsupported address type');
                }
            }
        },
        {
            key: "toScVal",
            value: function toScVal() {
                return _xdr["default"].ScVal.scvAddress(this.toScAddress());
            }
        },
        {
            key: "toScAddress",
            value: function toScAddress() {
                switch(this._type){
                    case 'account':
                        return _xdr["default"].ScAddress.scAddressTypeAccount(_xdr["default"].PublicKey.publicKeyTypeEd25519(this._key));
                    case 'contract':
                        return _xdr["default"].ScAddress.scAddressTypeContract(this._key);
                    default:
                        throw new Error('Unsupported address type');
                }
            }
        },
        {
            key: "toBuffer",
            value: function toBuffer() {
                return this._key;
            }
        }
    ], [
        {
            key: "fromString",
            value: function fromString(address) {
                return new Address(address);
            }
        },
        {
            key: "account",
            value: function account(buffer) {
                return new Address(_strkey.StrKey.encodeEd25519PublicKey(buffer));
            }
        },
        {
            key: "contract",
            value: function contract(buffer) {
                return new Address(_strkey.StrKey.encodeContract(buffer));
            }
        },
        {
            key: "fromScVal",
            value: function fromScVal(scVal) {
                return Address.fromScAddress(scVal.address());
            }
        },
        {
            key: "fromScAddress",
            value: function fromScAddress(scAddress) {
                switch(scAddress["switch"]().value){
                    case _xdr["default"].ScAddressType.scAddressTypeAccount().value:
                        return Address.account(scAddress.accountId().ed25519());
                    case _xdr["default"].ScAddressType.scAddressTypeContract().value:
                        return Address.contract(scAddress.contractId());
                    default:
                        throw new Error('Unsupported address type');
                }
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createCustomContract = createCustomContract;
exports.createStellarAssetContract = createStellarAssetContract;
exports.invokeContractFunction = invokeContractFunction;
exports.invokeHostFunction = invokeHostFunction;
exports.uploadContractWasm = uploadContractWasm;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _address = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/address.js [app-ssr] (ecmascript)");
var _asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
        var e, n, i, u, a = [], f = !0, o = !1;
        try {
            if (i = (t = t.call(r)).next, 0 === l) {
                if (Object(t) !== t) return;
                f = !1;
            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
            o = !0, n = r;
        } finally{
            try {
                if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally{
                if (o) throw n;
            }
        }
        return a;
    }
}
function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
}
/**
 * Invokes a single smart contract host function.
 *
 * @function
 * @alias Operation.invokeHostFunction
 *
 * @param {object} opts - options object
 * @param {xdr.HostFunction} opts.func - host function to execute (with its
 *    wrapped parameters)
 * @param {xdr.SorobanAuthorizationEntry[]} [opts.auth] - list outlining the
 *    tree of authorizations required for the call
 * @param {string} [opts.source] - an optional source account
 *
 * @returns {xdr.Operation} an Invoke Host Function operation
 *    (xdr.InvokeHostFunctionOp)
 *
 * @see https://soroban.stellar.org/docs/fundamentals-and-concepts/invoking-contracts-with-transactions#function
 * @see Operation.invokeContractFunction
 * @see Operation.createCustomContract
 * @see Operation.createStellarAssetContract
 * @see Operation.uploadContractWasm
 * @see Contract.call
 */ function invokeHostFunction(opts) {
    if (!opts.func) {
        throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(opts), ")"));
    }
    var invokeHostFunctionOp = new _xdr["default"].InvokeHostFunctionOp({
        hostFunction: opts.func,
        auth: opts.auth || []
    });
    var opAttributes = {
        body: _xdr["default"].OperationBody.invokeHostFunction(invokeHostFunctionOp)
    };
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
/**
 * Returns an operation that invokes a contract function.
 *
 * @function
 * @alias Operation.invokeContractFunction
 *
 * @param {any}         opts - the set of parameters
 * @param {string}      opts.contract - a strkey-fied contract address (`C...`)
 * @param {string}      opts.function - the name of the contract fn to invoke
 * @param {xdr.ScVal[]} opts.args - parameters to pass to the function
 *    invocation (try {@link nativeToScVal} or {@link ScInt} to make building
 *    these easier)
 * @param {xdr.SorobanAuthorizationEntry[]} [opts.auth] - an optional list
 *    outlining the tree of authorizations required for the call
 * @param {string} [opts.source] - an optional source account
 *
 * @returns {xdr.Operation} an Invoke Host Function operation
 *    (xdr.InvokeHostFunctionOp)
 *
 * @see Operation.invokeHostFunction
 * @see Contract.call
 * @see Address
 */ function invokeContractFunction(opts) {
    var c = new _address.Address(opts.contract);
    if (c._type !== 'contract') {
        throw new TypeError("expected contract strkey instance, got ".concat(c));
    }
    return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeInvokeContract(new _xdr["default"].InvokeContractArgs({
            contractAddress: c.toScAddress(),
            functionName: opts["function"],
            args: opts.args
        }))
    });
}
/**
 * Returns an operation that creates a custom WASM contract and atomically
 * invokes its constructor.
 *
 * @function
 * @alias Operation.createCustomContract
 *
 * @param {any}     opts - the set of parameters
 * @param {Address} opts.address - the contract uploader address
 * @param {Uint8Array|Buffer}  opts.wasmHash - the SHA-256 hash of the contract
 *    WASM you're uploading (see {@link hash} and
 *    {@link Operation.uploadContractWasm})
 * @param {xdr.ScVal[]} [opts.constructorArgs] - the optional parameters to pass
 *    to the constructor of this contract (see {@link nativeToScVal} for ways to
 *    easily create these parameters from native JS values)
 * @param {Uint8Array|Buffer} [opts.salt] - an optional, 32-byte salt to
 *    distinguish deployment instances of the same wasm from the same user (if
 *    omitted, one will be generated for you)
 * @param {xdr.SorobanAuthorizationEntry[]} [opts.auth] - an optional list
 *    outlining the tree of authorizations required for the call
 * @param {string} [opts.source] - an optional source account
 *
 * @returns {xdr.Operation} an Invoke Host Function operation
 *    (xdr.InvokeHostFunctionOp)
 *
 * @see
 * https://soroban.stellar.org/docs/fundamentals-and-concepts/invoking-contracts-with-transactions#function
 */ function createCustomContract(opts) {
    var _opts$constructorArgs;
    var salt = Buffer.from(opts.salt || getSalty());
    if (!opts.wasmHash || opts.wasmHash.length !== 32) {
        throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(opts.wasmHash));
    }
    if (salt.length !== 32) {
        throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(opts.wasmHash));
    }
    return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContractV2(new _xdr["default"].CreateContractArgsV2({
            executable: _xdr["default"].ContractExecutable.contractExecutableWasm(Buffer.from(opts.wasmHash)),
            contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAddress(new _xdr["default"].ContractIdPreimageFromAddress({
                address: opts.address.toScAddress(),
                salt: salt
            })),
            constructorArgs: (_opts$constructorArgs = opts.constructorArgs) !== null && _opts$constructorArgs !== void 0 ? _opts$constructorArgs : []
        }))
    });
}
/**
 * Returns an operation that wraps a Stellar asset into a token contract.
 *
 * @function
 * @alias Operation.createStellarAssetContract
 *
 * @param {any}          opts - the set of parameters
 * @param {Asset|string} opts.asset - the Stellar asset to wrap, either as an
 *    {@link Asset} object or in canonical form (SEP-11, `code:issuer`)
 * @param {xdr.SorobanAuthorizationEntry[]} [opts.auth] - an optional list
 *    outlining the tree of authorizations required for the call
 * @param {string} [opts.source] - an optional source account
 *
 * @returns {xdr.Operation} an Invoke Host Function operation
 *    (xdr.InvokeHostFunctionOp)
 *
 * @see https://stellar.org/protocol/sep-11#alphanum4-alphanum12
 * @see
 * https://soroban.stellar.org/docs/fundamentals-and-concepts/invoking-contracts-with-transactions
 * @see
 * https://soroban.stellar.org/docs/advanced-tutorials/stellar-asset-contract
 * @see Operation.invokeHostFunction
 */ function createStellarAssetContract(opts) {
    var asset = opts.asset;
    if (typeof asset === 'string') {
        var _asset$split = asset.split(':'), _asset$split2 = _slicedToArray(_asset$split, 2), code = _asset$split2[0], issuer = _asset$split2[1];
        asset = new _asset.Asset(code, issuer); // handles 'xlm' by default
    }
    if (!(asset instanceof _asset.Asset)) {
        throw new TypeError("expected Asset in 'opts.asset', got ".concat(asset));
    }
    return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContract(new _xdr["default"].CreateContractArgs({
            executable: _xdr["default"].ContractExecutable.contractExecutableStellarAsset(),
            contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(asset.toXDRObject())
        }))
    });
}
/**
 * Returns an operation that uploads WASM for a contract.
 *
 * @function
 * @alias Operation.uploadContractWasm
 *
 * @param {any}               opts - the set of parameters
 * @param {Uint8Array|Buffer} opts.wasm - a WASM blob to upload to the ledger
 * @param {xdr.SorobanAuthorizationEntry[]} [opts.auth] - an optional list
 *    outlining the tree of authorizations required for the call
 * @param {string} [opts.source] - an optional source account
 *
 * @returns {xdr.Operation} an Invoke Host Function operation
 *    (xdr.InvokeHostFunctionOp)
 *
 * @see
 * https://soroban.stellar.org/docs/fundamentals-and-concepts/invoking-contracts-with-transactions#function
 */ function uploadContractWasm(opts) {
    return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeUploadContractWasm(Buffer.from(opts.wasm) // coalesce so we can drop `Buffer` someday
        )
    });
}
/** @returns {Buffer} a random 256-bit "salt" value. */ function getSalty() {
    return _keypair.Keypair.random().xdrPublicKey().value(); // ed25519 is 256 bits, too
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extendFootprintTtl = extendFootprintTtl;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Builds an operation to bump the time-to-live (TTL) of the ledger keys. The
 * keys for extension have to be provided in the read-only footprint of
 * the transaction.
 *
 * The only parameter of the operation itself is the new minimum TTL for
 * all the provided entries. If an entry already has a higher TTL, then it
 * will just be skipped.
 *
 * TTL is the number of ledgers from the current ledger (exclusive) until
 * the last ledger the entry is still considered alive (inclusive). Thus
 * the exact ledger until the entries will live will only be determined
 * when transaction has been applied.
 *
 * The footprint has to be specified in the transaction. See
 * {@link TransactionBuilder}'s `opts.sorobanData` parameter, which is a
 * {@link xdr.SorobanTransactionData} instance that contains fee data & resource
 * usage as part of {@link xdr.SorobanResources}.
 *
 * @function
 * @alias Operation.extendFootprintTtl
 *
 * @param {object} opts - object holding operation parameters
 * @param {number} opts.extendTo - the minimum TTL that all the entries in
 *    the read-only footprint will have
 * @param {string} [opts.source] - an optional source account
 *
 * @returns {xdr.Operation} an Extend Footprint TTL operation
 *    (xdr.ExtendFootprintTTLOp)
 */ function extendFootprintTtl(opts) {
    var _opts$extendTo;
    if (((_opts$extendTo = opts.extendTo) !== null && _opts$extendTo !== void 0 ? _opts$extendTo : -1) <= 0) {
        throw new RangeError('extendTo has to be positive');
    }
    var extendFootprintOp = new _xdr["default"].ExtendFootprintTtlOp({
        ext: new _xdr["default"].ExtensionPoint(0),
        extendTo: opts.extendTo
    });
    var opAttributes = {
        body: _xdr["default"].OperationBody.extendFootprintTtl(extendFootprintOp)
    };
    this.setSourceAccount(opAttributes, opts);
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.restoreFootprint = restoreFootprint;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/**
 * Builds an operation to restore the archived ledger entries specified
 * by the ledger keys.
 *
 * The ledger keys to restore are specified separately from the operation
 * in read-write footprint of the transaction.
 *
 * It takes no parameters because the relevant footprint is derived from the
 * transaction itself. See {@link TransactionBuilder}'s `opts.sorobanData`
 * parameter (or {@link TransactionBuilder.setSorobanData} /
 * {@link TransactionBuilder.setLedgerKeys}), which is a
 * {@link xdr.SorobanTransactionData} instance that contains fee data & resource
 * usage as part of {@link xdr.SorobanTransactionData}.
 *
 * @function
 * @alias Operation.restoreFootprint
 *
 * @param {object} [opts] - an optional set of parameters
 * @param {string} [opts.source] - an optional source account
 *
 * @returns {xdr.Operation} a Bump Footprint Expiration operation
 *    (xdr.RestoreFootprintOp)
 */ function restoreFootprint() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var op = new _xdr["default"].RestoreFootprintOp({
        ext: new _xdr["default"].ExtensionPoint(0)
    });
    var opAttributes = {
        body: _xdr["default"].OperationBody.restoreFootprint(op)
    };
    this.setSourceAccount(opAttributes, opts !== null && opts !== void 0 ? opts : {});
    return new _xdr["default"].Operation(opAttributes);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operations/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "accountMerge", {
    enumerable: true,
    get: function get() {
        return _account_merge.accountMerge;
    }
});
Object.defineProperty(exports, "allowTrust", {
    enumerable: true,
    get: function get() {
        return _allow_trust.allowTrust;
    }
});
Object.defineProperty(exports, "beginSponsoringFutureReserves", {
    enumerable: true,
    get: function get() {
        return _begin_sponsoring_future_reserves.beginSponsoringFutureReserves;
    }
});
Object.defineProperty(exports, "bumpSequence", {
    enumerable: true,
    get: function get() {
        return _bump_sequence.bumpSequence;
    }
});
Object.defineProperty(exports, "changeTrust", {
    enumerable: true,
    get: function get() {
        return _change_trust.changeTrust;
    }
});
Object.defineProperty(exports, "claimClaimableBalance", {
    enumerable: true,
    get: function get() {
        return _claim_claimable_balance.claimClaimableBalance;
    }
});
Object.defineProperty(exports, "clawback", {
    enumerable: true,
    get: function get() {
        return _clawback.clawback;
    }
});
Object.defineProperty(exports, "clawbackClaimableBalance", {
    enumerable: true,
    get: function get() {
        return _clawback_claimable_balance.clawbackClaimableBalance;
    }
});
Object.defineProperty(exports, "createAccount", {
    enumerable: true,
    get: function get() {
        return _create_account.createAccount;
    }
});
Object.defineProperty(exports, "createClaimableBalance", {
    enumerable: true,
    get: function get() {
        return _create_claimable_balance.createClaimableBalance;
    }
});
Object.defineProperty(exports, "createCustomContract", {
    enumerable: true,
    get: function get() {
        return _invoke_host_function.createCustomContract;
    }
});
Object.defineProperty(exports, "createPassiveSellOffer", {
    enumerable: true,
    get: function get() {
        return _create_passive_sell_offer.createPassiveSellOffer;
    }
});
Object.defineProperty(exports, "createStellarAssetContract", {
    enumerable: true,
    get: function get() {
        return _invoke_host_function.createStellarAssetContract;
    }
});
Object.defineProperty(exports, "endSponsoringFutureReserves", {
    enumerable: true,
    get: function get() {
        return _end_sponsoring_future_reserves.endSponsoringFutureReserves;
    }
});
Object.defineProperty(exports, "extendFootprintTtl", {
    enumerable: true,
    get: function get() {
        return _extend_footprint_ttl.extendFootprintTtl;
    }
});
Object.defineProperty(exports, "inflation", {
    enumerable: true,
    get: function get() {
        return _inflation.inflation;
    }
});
Object.defineProperty(exports, "invokeContractFunction", {
    enumerable: true,
    get: function get() {
        return _invoke_host_function.invokeContractFunction;
    }
});
Object.defineProperty(exports, "invokeHostFunction", {
    enumerable: true,
    get: function get() {
        return _invoke_host_function.invokeHostFunction;
    }
});
Object.defineProperty(exports, "liquidityPoolDeposit", {
    enumerable: true,
    get: function get() {
        return _liquidity_pool_deposit.liquidityPoolDeposit;
    }
});
Object.defineProperty(exports, "liquidityPoolWithdraw", {
    enumerable: true,
    get: function get() {
        return _liquidity_pool_withdraw.liquidityPoolWithdraw;
    }
});
Object.defineProperty(exports, "manageBuyOffer", {
    enumerable: true,
    get: function get() {
        return _manage_buy_offer.manageBuyOffer;
    }
});
Object.defineProperty(exports, "manageData", {
    enumerable: true,
    get: function get() {
        return _manage_data.manageData;
    }
});
Object.defineProperty(exports, "manageSellOffer", {
    enumerable: true,
    get: function get() {
        return _manage_sell_offer.manageSellOffer;
    }
});
Object.defineProperty(exports, "pathPaymentStrictReceive", {
    enumerable: true,
    get: function get() {
        return _path_payment_strict_receive.pathPaymentStrictReceive;
    }
});
Object.defineProperty(exports, "pathPaymentStrictSend", {
    enumerable: true,
    get: function get() {
        return _path_payment_strict_send.pathPaymentStrictSend;
    }
});
Object.defineProperty(exports, "payment", {
    enumerable: true,
    get: function get() {
        return _payment.payment;
    }
});
Object.defineProperty(exports, "restoreFootprint", {
    enumerable: true,
    get: function get() {
        return _restore_footprint.restoreFootprint;
    }
});
Object.defineProperty(exports, "revokeAccountSponsorship", {
    enumerable: true,
    get: function get() {
        return _revoke_sponsorship.revokeAccountSponsorship;
    }
});
Object.defineProperty(exports, "revokeClaimableBalanceSponsorship", {
    enumerable: true,
    get: function get() {
        return _revoke_sponsorship.revokeClaimableBalanceSponsorship;
    }
});
Object.defineProperty(exports, "revokeDataSponsorship", {
    enumerable: true,
    get: function get() {
        return _revoke_sponsorship.revokeDataSponsorship;
    }
});
Object.defineProperty(exports, "revokeLiquidityPoolSponsorship", {
    enumerable: true,
    get: function get() {
        return _revoke_sponsorship.revokeLiquidityPoolSponsorship;
    }
});
Object.defineProperty(exports, "revokeOfferSponsorship", {
    enumerable: true,
    get: function get() {
        return _revoke_sponsorship.revokeOfferSponsorship;
    }
});
Object.defineProperty(exports, "revokeSignerSponsorship", {
    enumerable: true,
    get: function get() {
        return _revoke_sponsorship.revokeSignerSponsorship;
    }
});
Object.defineProperty(exports, "revokeTrustlineSponsorship", {
    enumerable: true,
    get: function get() {
        return _revoke_sponsorship.revokeTrustlineSponsorship;
    }
});
Object.defineProperty(exports, "setOptions", {
    enumerable: true,
    get: function get() {
        return _set_options.setOptions;
    }
});
Object.defineProperty(exports, "setTrustLineFlags", {
    enumerable: true,
    get: function get() {
        return _set_trustline_flags.setTrustLineFlags;
    }
});
Object.defineProperty(exports, "uploadContractWasm", {
    enumerable: true,
    get: function get() {
        return _invoke_host_function.uploadContractWasm;
    }
});
var _manage_sell_offer = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js [app-ssr] (ecmascript)");
var _create_passive_sell_offer = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js [app-ssr] (ecmascript)");
var _account_merge = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/account_merge.js [app-ssr] (ecmascript)");
var _allow_trust = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js [app-ssr] (ecmascript)");
var _bump_sequence = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js [app-ssr] (ecmascript)");
var _change_trust = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/change_trust.js [app-ssr] (ecmascript)");
var _create_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/create_account.js [app-ssr] (ecmascript)");
var _create_claimable_balance = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js [app-ssr] (ecmascript)");
var _claim_claimable_balance = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js [app-ssr] (ecmascript)");
var _clawback_claimable_balance = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js [app-ssr] (ecmascript)");
var _inflation = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/inflation.js [app-ssr] (ecmascript)");
var _manage_data = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/manage_data.js [app-ssr] (ecmascript)");
var _manage_buy_offer = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js [app-ssr] (ecmascript)");
var _path_payment_strict_receive = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js [app-ssr] (ecmascript)");
var _path_payment_strict_send = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js [app-ssr] (ecmascript)");
var _payment = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/payment.js [app-ssr] (ecmascript)");
var _set_options = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/set_options.js [app-ssr] (ecmascript)");
var _begin_sponsoring_future_reserves = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js [app-ssr] (ecmascript)");
var _end_sponsoring_future_reserves = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js [app-ssr] (ecmascript)");
var _revoke_sponsorship = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js [app-ssr] (ecmascript)");
var _clawback = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/clawback.js [app-ssr] (ecmascript)");
var _set_trustline_flags = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js [app-ssr] (ecmascript)");
var _liquidity_pool_deposit = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js [app-ssr] (ecmascript)");
var _liquidity_pool_withdraw = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js [app-ssr] (ecmascript)");
var _invoke_host_function = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js [app-ssr] (ecmascript)");
var _extend_footprint_ttl = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js [app-ssr] (ecmascript)");
var _restore_footprint = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/@stellar/stellar-base/lib/operation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Operation = exports.AuthRevocableFlag = exports.AuthRequiredFlag = exports.AuthImmutableFlag = exports.AuthClawbackEnabledFlag = void 0;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var _bignumber = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/bignumber.js [app-ssr] (ecmascript)"));
var _util = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/util.js [app-ssr] (ecmascript)");
var _continued_fraction = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js [app-ssr] (ecmascript)");
var _asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)");
var _liquidity_pool_asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js [app-ssr] (ecmascript)");
var _claimant = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/claimant.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _liquidity_pool_id = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js [app-ssr] (ecmascript)");
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var ops = _interopRequireWildcard(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operations/index.js [app-ssr] (ecmascript)"));
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != _typeof(e) && "function" != typeof e) return {
        "default": e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n["default"] = e, t && t.set(e, n), n;
}
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
} /* eslint-disable no-bitwise */ 
var ONE = 10000000;
var MAX_INT64 = '9223372036854775807';
/**
 * When set using `{@link Operation.setOptions}` option, requires the issuing
 * account to give other accounts permission before they can hold the issuing
 * account’s credit.
 *
 * @constant
 * @see [Account flags](https://developers.stellar.org/docs/glossary/accounts/#flags)
 */ var AuthRequiredFlag = exports.AuthRequiredFlag = 1 << 0;
/**
 * When set using `{@link Operation.setOptions}` option, allows the issuing
 * account to revoke its credit held by other accounts.
 *
 * @constant
 * @see [Account flags](https://developers.stellar.org/docs/glossary/accounts/#flags)
 */ var AuthRevocableFlag = exports.AuthRevocableFlag = 1 << 1;
/**
 * When set using `{@link Operation.setOptions}` option, then none of the
 * authorization flags can be set and the account can never be deleted.
 *
 * @constant
 * @see [Account flags](https://developers.stellar.org/docs/glossary/accounts/#flags)
 */ var AuthImmutableFlag = exports.AuthImmutableFlag = 1 << 2;
/**
 * When set using `{@link Operation.setOptions}` option, then any trustlines
 * created by this account can have a ClawbackOp operation submitted for the
 * corresponding asset.
 *
 * @constant
 * @see [Account flags](https://developers.stellar.org/docs/glossary/accounts/#flags)
 */ var AuthClawbackEnabledFlag = exports.AuthClawbackEnabledFlag = 1 << 3;
/**
 * `Operation` class represents
 * [operations](https://developers.stellar.org/docs/glossary/operations/) in
 * Stellar network.
 *
 * Use one of static methods to create operations:
 * * `{@link Operation.createAccount}`
 * * `{@link Operation.payment}`
 * * `{@link Operation.pathPaymentStrictReceive}`
 * * `{@link Operation.pathPaymentStrictSend}`
 * * `{@link Operation.manageSellOffer}`
 * * `{@link Operation.manageBuyOffer}`
 * * `{@link Operation.createPassiveSellOffer}`
 * * `{@link Operation.setOptions}`
 * * `{@link Operation.changeTrust}`
 * * `{@link Operation.allowTrust}`
 * * `{@link Operation.accountMerge}`
 * * `{@link Operation.inflation}`
 * * `{@link Operation.manageData}`
 * * `{@link Operation.bumpSequence}`
 * * `{@link Operation.createClaimableBalance}`
 * * `{@link Operation.claimClaimableBalance}`
 * * `{@link Operation.beginSponsoringFutureReserves}`
 * * `{@link Operation.endSponsoringFutureReserves}`
 * * `{@link Operation.revokeAccountSponsorship}`
 * * `{@link Operation.revokeTrustlineSponsorship}`
 * * `{@link Operation.revokeOfferSponsorship}`
 * * `{@link Operation.revokeDataSponsorship}`
 * * `{@link Operation.revokeClaimableBalanceSponsorship}`
 * * `{@link Operation.revokeLiquidityPoolSponsorship}`
 * * `{@link Operation.revokeSignerSponsorship}`
 * * `{@link Operation.clawback}`
 * * `{@link Operation.clawbackClaimableBalance}`
 * * `{@link Operation.setTrustLineFlags}`
 * * `{@link Operation.liquidityPoolDeposit}`
 * * `{@link Operation.liquidityPoolWithdraw}`
 * * `{@link Operation.invokeHostFunction}`, which has the following additional
 *   "pseudo-operations" that make building host functions easier:
 *   - `{@link Operation.createStellarAssetContract}`
 *   - `{@link Operation.invokeContractFunction}`
 *   - `{@link Operation.createCustomContract}`
 *   - `{@link Operation.uploadContractWasm}`
 * * `{@link Operation.extendFootprintTtlOp}`
 * * `{@link Operation.restoreFootprint}`
 *
 * @class Operation
 */ var Operation = exports.Operation = /*#__PURE__*/ function() {
    function Operation() {
        _classCallCheck(this, Operation);
    }
    return _createClass(Operation, null, [
        {
            key: "setSourceAccount",
            value: function setSourceAccount(opAttributes, opts) {
                if (opts.source) {
                    try {
                        opAttributes.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.source);
                    } catch (e) {
                        throw new Error('Source address is invalid');
                    }
                }
            }
        },
        {
            key: "fromXDRObject",
            value: function fromXDRObject(operation) {
                var result = {};
                if (operation.sourceAccount()) {
                    result.source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(operation.sourceAccount());
                }
                var attrs = operation.body().value();
                var operationName = operation.body()["switch"]().name;
                switch(operationName){
                    case 'createAccount':
                        {
                            result.type = 'createAccount';
                            result.destination = accountIdtoAddress(attrs.destination());
                            result.startingBalance = this._fromXDRAmount(attrs.startingBalance());
                            break;
                        }
                    case 'payment':
                        {
                            result.type = 'payment';
                            result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
                            result.asset = _asset.Asset.fromOperation(attrs.asset());
                            result.amount = this._fromXDRAmount(attrs.amount());
                            break;
                        }
                    case 'pathPaymentStrictReceive':
                        {
                            result.type = 'pathPaymentStrictReceive';
                            result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
                            result.sendMax = this._fromXDRAmount(attrs.sendMax());
                            result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
                            result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
                            result.destAmount = this._fromXDRAmount(attrs.destAmount());
                            result.path = [];
                            var path = attrs.path();
                            // note that Object.values isn't supported by node 6!
                            Object.keys(path).forEach(function(pathKey) {
                                result.path.push(_asset.Asset.fromOperation(path[pathKey]));
                            });
                            break;
                        }
                    case 'pathPaymentStrictSend':
                        {
                            result.type = 'pathPaymentStrictSend';
                            result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
                            result.sendAmount = this._fromXDRAmount(attrs.sendAmount());
                            result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
                            result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
                            result.destMin = this._fromXDRAmount(attrs.destMin());
                            result.path = [];
                            var _path = attrs.path();
                            // note that Object.values isn't supported by node 6!
                            Object.keys(_path).forEach(function(pathKey) {
                                result.path.push(_asset.Asset.fromOperation(_path[pathKey]));
                            });
                            break;
                        }
                    case 'changeTrust':
                        {
                            result.type = 'changeTrust';
                            switch(attrs.line()["switch"]()){
                                case _xdr["default"].AssetType.assetTypePoolShare():
                                    result.line = _liquidity_pool_asset.LiquidityPoolAsset.fromOperation(attrs.line());
                                    break;
                                default:
                                    result.line = _asset.Asset.fromOperation(attrs.line());
                                    break;
                            }
                            result.limit = this._fromXDRAmount(attrs.limit());
                            break;
                        }
                    case 'allowTrust':
                        {
                            result.type = 'allowTrust';
                            result.trustor = accountIdtoAddress(attrs.trustor());
                            result.assetCode = attrs.asset().value().toString();
                            result.assetCode = (0, _util.trimEnd)(result.assetCode, '\0');
                            result.authorize = attrs.authorize();
                            break;
                        }
                    case 'setOptions':
                        {
                            result.type = 'setOptions';
                            if (attrs.inflationDest()) {
                                result.inflationDest = accountIdtoAddress(attrs.inflationDest());
                            }
                            result.clearFlags = attrs.clearFlags();
                            result.setFlags = attrs.setFlags();
                            result.masterWeight = attrs.masterWeight();
                            result.lowThreshold = attrs.lowThreshold();
                            result.medThreshold = attrs.medThreshold();
                            result.highThreshold = attrs.highThreshold();
                            // home_domain is checked by iscntrl in stellar-core
                            result.homeDomain = attrs.homeDomain() !== undefined ? attrs.homeDomain().toString('ascii') : undefined;
                            if (attrs.signer()) {
                                var signer = {};
                                var arm = attrs.signer().key().arm();
                                if (arm === 'ed25519') {
                                    signer.ed25519PublicKey = accountIdtoAddress(attrs.signer().key());
                                } else if (arm === 'preAuthTx') {
                                    signer.preAuthTx = attrs.signer().key().preAuthTx();
                                } else if (arm === 'hashX') {
                                    signer.sha256Hash = attrs.signer().key().hashX();
                                } else if (arm === 'ed25519SignedPayload') {
                                    var signedPayload = attrs.signer().key().ed25519SignedPayload();
                                    signer.ed25519SignedPayload = _strkey.StrKey.encodeSignedPayload(signedPayload.toXDR());
                                }
                                signer.weight = attrs.signer().weight();
                                result.signer = signer;
                            }
                            break;
                        }
                    // the next case intentionally falls through!
                    case 'manageOffer':
                    case 'manageSellOffer':
                        {
                            result.type = 'manageSellOffer';
                            result.selling = _asset.Asset.fromOperation(attrs.selling());
                            result.buying = _asset.Asset.fromOperation(attrs.buying());
                            result.amount = this._fromXDRAmount(attrs.amount());
                            result.price = this._fromXDRPrice(attrs.price());
                            result.offerId = attrs.offerId().toString();
                            break;
                        }
                    case 'manageBuyOffer':
                        {
                            result.type = 'manageBuyOffer';
                            result.selling = _asset.Asset.fromOperation(attrs.selling());
                            result.buying = _asset.Asset.fromOperation(attrs.buying());
                            result.buyAmount = this._fromXDRAmount(attrs.buyAmount());
                            result.price = this._fromXDRPrice(attrs.price());
                            result.offerId = attrs.offerId().toString();
                            break;
                        }
                    // the next case intentionally falls through!
                    case 'createPassiveOffer':
                    case 'createPassiveSellOffer':
                        {
                            result.type = 'createPassiveSellOffer';
                            result.selling = _asset.Asset.fromOperation(attrs.selling());
                            result.buying = _asset.Asset.fromOperation(attrs.buying());
                            result.amount = this._fromXDRAmount(attrs.amount());
                            result.price = this._fromXDRPrice(attrs.price());
                            break;
                        }
                    case 'accountMerge':
                        {
                            result.type = 'accountMerge';
                            result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs);
                            break;
                        }
                    case 'manageData':
                        {
                            result.type = 'manageData';
                            // manage_data.name is checked by iscntrl in stellar-core
                            result.name = attrs.dataName().toString('ascii');
                            result.value = attrs.dataValue();
                            break;
                        }
                    case 'inflation':
                        {
                            result.type = 'inflation';
                            break;
                        }
                    case 'bumpSequence':
                        {
                            result.type = 'bumpSequence';
                            result.bumpTo = attrs.bumpTo().toString();
                            break;
                        }
                    case 'createClaimableBalance':
                        {
                            result.type = 'createClaimableBalance';
                            result.asset = _asset.Asset.fromOperation(attrs.asset());
                            result.amount = this._fromXDRAmount(attrs.amount());
                            result.claimants = [];
                            attrs.claimants().forEach(function(claimant) {
                                result.claimants.push(_claimant.Claimant.fromXDR(claimant));
                            });
                            break;
                        }
                    case 'claimClaimableBalance':
                        {
                            result.type = 'claimClaimableBalance';
                            result.balanceId = attrs.toXDR('hex');
                            break;
                        }
                    case 'beginSponsoringFutureReserves':
                        {
                            result.type = 'beginSponsoringFutureReserves';
                            result.sponsoredId = accountIdtoAddress(attrs.sponsoredId());
                            break;
                        }
                    case 'endSponsoringFutureReserves':
                        {
                            result.type = 'endSponsoringFutureReserves';
                            break;
                        }
                    case 'revokeSponsorship':
                        {
                            extractRevokeSponshipDetails(attrs, result);
                            break;
                        }
                    case 'clawback':
                        {
                            result.type = 'clawback';
                            result.amount = this._fromXDRAmount(attrs.amount());
                            result.from = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.from());
                            result.asset = _asset.Asset.fromOperation(attrs.asset());
                            break;
                        }
                    case 'clawbackClaimableBalance':
                        {
                            result.type = 'clawbackClaimableBalance';
                            result.balanceId = attrs.toXDR('hex');
                            break;
                        }
                    case 'setTrustLineFlags':
                        {
                            result.type = 'setTrustLineFlags';
                            result.asset = _asset.Asset.fromOperation(attrs.asset());
                            result.trustor = accountIdtoAddress(attrs.trustor());
                            // Convert from the integer-bitwised flag into a sensible object that
                            // indicates true/false for each flag that's on/off.
                            var clears = attrs.clearFlags();
                            var sets = attrs.setFlags();
                            var mapping = {
                                authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
                                authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
                                clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
                            };
                            var getFlagValue = function getFlagValue(key) {
                                var bit = mapping[key].value;
                                if (sets & bit) {
                                    return true;
                                }
                                if (clears & bit) {
                                    return false;
                                }
                                return undefined;
                            };
                            result.flags = {};
                            Object.keys(mapping).forEach(function(flagName) {
                                result.flags[flagName] = getFlagValue(flagName);
                            });
                            break;
                        }
                    case 'liquidityPoolDeposit':
                        {
                            result.type = 'liquidityPoolDeposit';
                            result.liquidityPoolId = attrs.liquidityPoolId().toString('hex');
                            result.maxAmountA = this._fromXDRAmount(attrs.maxAmountA());
                            result.maxAmountB = this._fromXDRAmount(attrs.maxAmountB());
                            result.minPrice = this._fromXDRPrice(attrs.minPrice());
                            result.maxPrice = this._fromXDRPrice(attrs.maxPrice());
                            break;
                        }
                    case 'liquidityPoolWithdraw':
                        {
                            result.type = 'liquidityPoolWithdraw';
                            result.liquidityPoolId = attrs.liquidityPoolId().toString('hex');
                            result.amount = this._fromXDRAmount(attrs.amount());
                            result.minAmountA = this._fromXDRAmount(attrs.minAmountA());
                            result.minAmountB = this._fromXDRAmount(attrs.minAmountB());
                            break;
                        }
                    case 'invokeHostFunction':
                        {
                            var _attrs$auth;
                            result.type = 'invokeHostFunction';
                            result.func = attrs.hostFunction();
                            result.auth = (_attrs$auth = attrs.auth()) !== null && _attrs$auth !== void 0 ? _attrs$auth : [];
                            break;
                        }
                    case 'extendFootprintTtl':
                        {
                            result.type = 'extendFootprintTtl';
                            result.extendTo = attrs.extendTo();
                            break;
                        }
                    case 'restoreFootprint':
                        {
                            result.type = 'restoreFootprint';
                            break;
                        }
                    default:
                        {
                            throw new Error("Unknown operation: ".concat(operationName));
                        }
                }
                return result;
            }
        },
        {
            key: "isValidAmount",
            value: function isValidAmount(value) {
                var allowZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                if (typeof value !== 'string') {
                    return false;
                }
                var amount;
                try {
                    amount = new _bignumber["default"](value);
                } catch (e) {
                    return false;
                }
                if (// == 0
                !allowZero && amount.isZero() || // < 0
                amount.isNegative() || // > Max value
                amount.times(ONE).gt(new _bignumber["default"](MAX_INT64).toString()) || // Decimal places (max 7)
                amount.decimalPlaces() > 7 || // NaN or Infinity
                amount.isNaN() || !amount.isFinite()) {
                    return false;
                }
                return true;
            }
        },
        {
            key: "constructAmountRequirementsError",
            value: function constructAmountRequirementsError(arg) {
                return "".concat(arg, " argument must be of type String, represent a positive number and have at most 7 digits after the decimal");
            }
        },
        {
            key: "_checkUnsignedIntValue",
            value: function _checkUnsignedIntValue(name, value) {
                var isValidFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                if (typeof value === 'undefined') {
                    return undefined;
                }
                if (typeof value === 'string') {
                    value = parseFloat(value);
                }
                switch(true){
                    case typeof value !== 'number' || !Number.isFinite(value) || value % 1 !== 0:
                        throw new Error("".concat(name, " value is invalid"));
                    case value < 0:
                        throw new Error("".concat(name, " value must be unsigned"));
                    case !isValidFunction || isValidFunction && isValidFunction(value, name):
                        return value;
                    default:
                        throw new Error("".concat(name, " value is invalid"));
                }
            }
        },
        {
            key: "_toXDRAmount",
            value: function _toXDRAmount(value) {
                var amount = new _bignumber["default"](value).times(ONE);
                return _jsXdr.Hyper.fromString(amount.toString());
            }
        },
        {
            key: "_fromXDRAmount",
            value: function _fromXDRAmount(value) {
                return new _bignumber["default"](value).div(ONE).toFixed(7);
            }
        },
        {
            key: "_fromXDRPrice",
            value: function _fromXDRPrice(price) {
                var n = new _bignumber["default"](price.n());
                return n.div(new _bignumber["default"](price.d())).toString();
            }
        },
        {
            key: "_toXDRPrice",
            value: function _toXDRPrice(price) {
                var xdrObject;
                if (price.n && price.d) {
                    xdrObject = new _xdr["default"].Price(price);
                } else {
                    var approx = (0, _continued_fraction.best_r)(price);
                    xdrObject = new _xdr["default"].Price({
                        n: parseInt(approx[0], 10),
                        d: parseInt(approx[1], 10)
                    });
                }
                if (xdrObject.n() < 0 || xdrObject.d() < 0) {
                    throw new Error('price must be positive');
                }
                return xdrObject;
            }
        }
    ]);
}();
function extractRevokeSponshipDetails(attrs, result) {
    switch(attrs["switch"]().name){
        case 'revokeSponsorshipLedgerEntry':
            {
                var ledgerKey = attrs.ledgerKey();
                switch(ledgerKey["switch"]().name){
                    case _xdr["default"].LedgerEntryType.account().name:
                        {
                            result.type = 'revokeAccountSponsorship';
                            result.account = accountIdtoAddress(ledgerKey.account().accountId());
                            break;
                        }
                    case _xdr["default"].LedgerEntryType.trustline().name:
                        {
                            result.type = 'revokeTrustlineSponsorship';
                            result.account = accountIdtoAddress(ledgerKey.trustLine().accountId());
                            var xdrAsset = ledgerKey.trustLine().asset();
                            switch(xdrAsset["switch"]()){
                                case _xdr["default"].AssetType.assetTypePoolShare():
                                    result.asset = _liquidity_pool_id.LiquidityPoolId.fromOperation(xdrAsset);
                                    break;
                                default:
                                    result.asset = _asset.Asset.fromOperation(xdrAsset);
                                    break;
                            }
                            break;
                        }
                    case _xdr["default"].LedgerEntryType.offer().name:
                        {
                            result.type = 'revokeOfferSponsorship';
                            result.seller = accountIdtoAddress(ledgerKey.offer().sellerId());
                            result.offerId = ledgerKey.offer().offerId().toString();
                            break;
                        }
                    case _xdr["default"].LedgerEntryType.data().name:
                        {
                            result.type = 'revokeDataSponsorship';
                            result.account = accountIdtoAddress(ledgerKey.data().accountId());
                            result.name = ledgerKey.data().dataName().toString('ascii');
                            break;
                        }
                    case _xdr["default"].LedgerEntryType.claimableBalance().name:
                        {
                            result.type = 'revokeClaimableBalanceSponsorship';
                            result.balanceId = ledgerKey.claimableBalance().balanceId().toXDR('hex');
                            break;
                        }
                    case _xdr["default"].LedgerEntryType.liquidityPool().name:
                        {
                            result.type = 'revokeLiquidityPoolSponsorship';
                            result.liquidityPoolId = ledgerKey.liquidityPool().liquidityPoolId().toString('hex');
                            break;
                        }
                    default:
                        {
                            throw new Error("Unknown ledgerKey: ".concat(attrs["switch"]().name));
                        }
                }
                break;
            }
        case 'revokeSponsorshipSigner':
            {
                result.type = 'revokeSignerSponsorship';
                result.account = accountIdtoAddress(attrs.signer().accountId());
                result.signer = convertXDRSignerKeyToObject(attrs.signer().signerKey());
                break;
            }
        default:
            {
                throw new Error("Unknown revokeSponsorship: ".concat(attrs["switch"]().name));
            }
    }
}
function convertXDRSignerKeyToObject(signerKey) {
    var attrs = {};
    switch(signerKey["switch"]().name){
        case _xdr["default"].SignerKeyType.signerKeyTypeEd25519().name:
            {
                attrs.ed25519PublicKey = _strkey.StrKey.encodeEd25519PublicKey(signerKey.ed25519());
                break;
            }
        case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx().name:
            {
                attrs.preAuthTx = signerKey.preAuthTx().toString('hex');
                break;
            }
        case _xdr["default"].SignerKeyType.signerKeyTypeHashX().name:
            {
                attrs.sha256Hash = signerKey.hashX().toString('hex');
                break;
            }
        default:
            {
                throw new Error("Unknown signerKey: ".concat(signerKey["switch"]().name));
            }
    }
    return attrs;
}
function accountIdtoAddress(accountId) {
    return _strkey.StrKey.encodeEd25519PublicKey(accountId.ed25519());
}
// Attach all imported operations as static methods on the Operation class
Operation.accountMerge = ops.accountMerge;
Operation.allowTrust = ops.allowTrust;
Operation.bumpSequence = ops.bumpSequence;
Operation.changeTrust = ops.changeTrust;
Operation.createAccount = ops.createAccount;
Operation.createClaimableBalance = ops.createClaimableBalance;
Operation.claimClaimableBalance = ops.claimClaimableBalance;
Operation.clawbackClaimableBalance = ops.clawbackClaimableBalance;
Operation.createPassiveSellOffer = ops.createPassiveSellOffer;
Operation.inflation = ops.inflation;
Operation.manageData = ops.manageData;
Operation.manageSellOffer = ops.manageSellOffer;
Operation.manageBuyOffer = ops.manageBuyOffer;
Operation.pathPaymentStrictReceive = ops.pathPaymentStrictReceive;
Operation.pathPaymentStrictSend = ops.pathPaymentStrictSend;
Operation.payment = ops.payment;
Operation.setOptions = ops.setOptions;
Operation.beginSponsoringFutureReserves = ops.beginSponsoringFutureReserves;
Operation.endSponsoringFutureReserves = ops.endSponsoringFutureReserves;
Operation.revokeAccountSponsorship = ops.revokeAccountSponsorship;
Operation.revokeTrustlineSponsorship = ops.revokeTrustlineSponsorship;
Operation.revokeOfferSponsorship = ops.revokeOfferSponsorship;
Operation.revokeDataSponsorship = ops.revokeDataSponsorship;
Operation.revokeClaimableBalanceSponsorship = ops.revokeClaimableBalanceSponsorship;
Operation.revokeLiquidityPoolSponsorship = ops.revokeLiquidityPoolSponsorship;
Operation.revokeSignerSponsorship = ops.revokeSignerSponsorship;
Operation.clawback = ops.clawback;
Operation.setTrustLineFlags = ops.setTrustLineFlags;
Operation.liquidityPoolDeposit = ops.liquidityPoolDeposit;
Operation.liquidityPoolWithdraw = ops.liquidityPoolWithdraw;
Operation.invokeHostFunction = ops.invokeHostFunction;
Operation.extendFootprintTtl = ops.extendFootprintTtl;
Operation.restoreFootprint = ops.restoreFootprint;
// these are not `xdr.Operation`s directly, but are proxies for complex but
// common versions of `Operation.invokeHostFunction`
Operation.createStellarAssetContract = ops.createStellarAssetContract;
Operation.invokeContractFunction = ops.invokeContractFunction;
Operation.createCustomContract = ops.createCustomContract;
Operation.uploadContractWasm = ops.uploadContractWasm;
}}),
"[project]/node_modules/@stellar/stellar-base/lib/memo.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MemoText = exports.MemoReturn = exports.MemoNone = exports.MemoID = exports.MemoHash = exports.Memo = void 0;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var _bignumber = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/bignumber.js [app-ssr] (ecmascript)"));
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Type of {@link Memo}.
 */ var MemoNone = exports.MemoNone = 'none';
/**
 * Type of {@link Memo}.
 */ var MemoID = exports.MemoID = 'id';
/**
 * Type of {@link Memo}.
 */ var MemoText = exports.MemoText = 'text';
/**
 * Type of {@link Memo}.
 */ var MemoHash = exports.MemoHash = 'hash';
/**
 * Type of {@link Memo}.
 */ var MemoReturn = exports.MemoReturn = 'return';
/**
 * `Memo` represents memos attached to transactions.
 *
 * @param {string} type - `MemoNone`, `MemoID`, `MemoText`, `MemoHash` or `MemoReturn`
 * @param {*} value - `string` for `MemoID`, `MemoText`, buffer of hex string for `MemoHash` or `MemoReturn`
 * @see [Transactions concept](https://developers.stellar.org/docs/glossary/transactions/)
 * @class Memo
 */ var Memo = exports.Memo = /*#__PURE__*/ function() {
    function Memo(type) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        _classCallCheck(this, Memo);
        this._type = type;
        this._value = value;
        switch(this._type){
            case MemoNone:
                break;
            case MemoID:
                Memo._validateIdValue(value);
                break;
            case MemoText:
                Memo._validateTextValue(value);
                break;
            case MemoHash:
            case MemoReturn:
                Memo._validateHashValue(value);
                // We want MemoHash and MemoReturn to have Buffer as a value
                if (typeof value === 'string') {
                    this._value = Buffer.from(value, 'hex');
                }
                break;
            default:
                throw new Error('Invalid memo type');
        }
    }
    /**
   * Contains memo type: `MemoNone`, `MemoID`, `MemoText`, `MemoHash` or `MemoReturn`
   */ return _createClass(Memo, [
        {
            key: "type",
            get: function get() {
                return this._type;
            },
            set: function set(type) {
                throw new Error('Memo is immutable');
            }
        },
        {
            key: "value",
            get: function get() {
                switch(this._type){
                    case MemoNone:
                        return null;
                    case MemoID:
                    case MemoText:
                        return this._value;
                    case MemoHash:
                    case MemoReturn:
                        return Buffer.from(this._value);
                    default:
                        throw new Error('Invalid memo type');
                }
            },
            set: function set(value) {
                throw new Error('Memo is immutable');
            }
        },
        {
            key: "toXDRObject",
            value: /**
     * Returns XDR memo object.
     * @returns {xdr.Memo}
     */ function toXDRObject() {
                switch(this._type){
                    case MemoNone:
                        return _xdr["default"].Memo.memoNone();
                    case MemoID:
                        return _xdr["default"].Memo.memoId(_jsXdr.UnsignedHyper.fromString(this._value));
                    case MemoText:
                        return _xdr["default"].Memo.memoText(this._value);
                    case MemoHash:
                        return _xdr["default"].Memo.memoHash(this._value);
                    case MemoReturn:
                        return _xdr["default"].Memo.memoReturn(this._value);
                    default:
                        return null;
                }
            }
        }
    ], [
        {
            key: "_validateIdValue",
            value: function _validateIdValue(value) {
                var error = new Error("Expects a int64 as a string. Got ".concat(value));
                if (typeof value !== 'string') {
                    throw error;
                }
                var number;
                try {
                    number = new _bignumber["default"](value);
                } catch (e) {
                    throw error;
                }
                // Infinity
                if (!number.isFinite()) {
                    throw error;
                }
                // NaN
                if (number.isNaN()) {
                    throw error;
                }
            }
        },
        {
            key: "_validateTextValue",
            value: function _validateTextValue(value) {
                if (!_xdr["default"].Memo.armTypeForArm('text').isValid(value)) {
                    throw new Error('Expects string, array or buffer, max 28 bytes');
                }
            }
        },
        {
            key: "_validateHashValue",
            value: function _validateHashValue(value) {
                var error = new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(value));
                if (value === null || typeof value === 'undefined') {
                    throw error;
                }
                var valueBuffer;
                if (typeof value === 'string') {
                    if (!/^[0-9A-Fa-f]{64}$/g.test(value)) {
                        throw error;
                    }
                    valueBuffer = Buffer.from(value, 'hex');
                } else if (Buffer.isBuffer(value)) {
                    valueBuffer = Buffer.from(value);
                } else {
                    throw error;
                }
                if (!valueBuffer.length || valueBuffer.length !== 32) {
                    throw error;
                }
            }
        },
        {
            key: "none",
            value: function none() {
                return new Memo(MemoNone);
            }
        },
        {
            key: "text",
            value: function text(_text) {
                return new Memo(MemoText, _text);
            }
        },
        {
            key: "id",
            value: function id(_id) {
                return new Memo(MemoID, _id);
            }
        },
        {
            key: "hash",
            value: function hash(_hash) {
                return new Memo(MemoHash, _hash);
            }
        },
        {
            key: "return",
            value: function _return(hash) {
                return new Memo(MemoReturn, hash);
            }
        },
        {
            key: "fromXDRObject",
            value: function fromXDRObject(object) {
                switch(object.arm()){
                    case 'id':
                        return Memo.id(object.value().toString());
                    case 'text':
                        return Memo.text(object.value());
                    case 'hash':
                        return Memo.hash(object.value());
                    case 'retHash':
                        return Memo["return"](object.value());
                    default:
                        break;
                }
                if (typeof object.value() === 'undefined') {
                    return Memo.none();
                }
                throw new Error('Unknown type');
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/transaction.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Transaction = void 0;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _hashing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/hashing.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _operation = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operation.js [app-ssr] (ecmascript)");
var _memo = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/memo.js [app-ssr] (ecmascript)");
var _transaction_base = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/transaction_base.js [app-ssr] (ecmascript)");
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
}
function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(t, "prototype", {
        writable: !1
    }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
}
/**
 * Use {@link TransactionBuilder} to build a transaction object. If you have an
 * object or base64-encoded string of the transaction envelope XDR, use {@link
 * TransactionBuilder.fromXDR}.
 *
 * Once a Transaction has been created, its attributes and operations should not
 * be changed. You should only add signatures (using {@link Transaction#sign})
 * to a Transaction object before submitting to the network or forwarding on to
 * additional signers.
 *
 * @constructor
 *
 * @param {string|xdr.TransactionEnvelope} envelope - transaction envelope
 *     object or base64 encoded string
 * @param {string}  [networkPassphrase] - passphrase of the target stellar
 *     network (e.g. "Public Global Stellar Network ; September 2015")
 *
 * @extends TransactionBase
 */ var Transaction = exports.Transaction = /*#__PURE__*/ function(_TransactionBase) {
    function Transaction(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, Transaction);
        if (typeof envelope === 'string') {
            var buffer = Buffer.from(envelope, 'base64');
            envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (!(envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0() || envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTx())) {
            throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, Transaction, [
            tx,
            signatures,
            fee,
            networkPassphrase
        ]);
        _this._envelopeType = envelopeType;
        _this._memo = tx.memo();
        _this._sequence = tx.seqNum().toString();
        switch(_this._envelopeType){
            case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
                _this._source = _strkey.StrKey.encodeEd25519PublicKey(_this.tx.sourceAccountEd25519());
                break;
            default:
                _this._source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.sourceAccount());
                break;
        }
        var cond = null;
        var timeBounds = null;
        switch(_this._envelopeType){
            case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
                timeBounds = tx.timeBounds();
                break;
            case _xdr["default"].EnvelopeType.envelopeTypeTx():
                switch(tx.cond()["switch"]()){
                    case _xdr["default"].PreconditionType.precondTime():
                        timeBounds = tx.cond().timeBounds();
                        break;
                    case _xdr["default"].PreconditionType.precondV2():
                        cond = tx.cond().v2();
                        timeBounds = cond.timeBounds();
                        break;
                    default:
                        break;
                }
                break;
            default:
                break;
        }
        if (timeBounds) {
            _this._timeBounds = {
                minTime: timeBounds.minTime().toString(),
                maxTime: timeBounds.maxTime().toString()
            };
        }
        if (cond) {
            var ledgerBounds = cond.ledgerBounds();
            if (ledgerBounds) {
                _this._ledgerBounds = {
                    minLedger: ledgerBounds.minLedger(),
                    maxLedger: ledgerBounds.maxLedger()
                };
            }
            var minSeq = cond.minSeqNum();
            if (minSeq) {
                _this._minAccountSequence = minSeq.toString();
            }
            _this._minAccountSequenceAge = cond.minSeqAge();
            _this._minAccountSequenceLedgerGap = cond.minSeqLedgerGap();
            _this._extraSigners = cond.extraSigners();
        }
        var operations = tx.operations() || [];
        _this._operations = operations.map(function(op) {
            return _operation.Operation.fromXDRObject(op);
        });
        return _this;
    }
    /**
   * @type {object}
   * @property {string} 64 bit unix timestamp
   * @property {string} 64 bit unix timestamp
   * @readonly
   */ _inherits(Transaction, _TransactionBase);
    return _createClass(Transaction, [
        {
            key: "timeBounds",
            get: function get() {
                return this._timeBounds;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "ledgerBounds",
            get: function get() {
                return this._ledgerBounds;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "minAccountSequence",
            get: function get() {
                return this._minAccountSequence;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "minAccountSequenceAge",
            get: function get() {
                return this._minAccountSequenceAge;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "minAccountSequenceLedgerGap",
            get: function get() {
                return this._minAccountSequenceLedgerGap;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "extraSigners",
            get: function get() {
                return this._extraSigners;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "sequence",
            get: function get() {
                return this._sequence;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "source",
            get: function get() {
                return this._source;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "operations",
            get: function get() {
                return this._operations;
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "memo",
            get: function get() {
                return _memo.Memo.fromXDRObject(this._memo);
            },
            set: function set(value) {
                throw new Error('Transaction is immutable');
            }
        },
        {
            key: "signatureBase",
            value: function signatureBase() {
                var tx = this.tx;
                // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0
                // we need a Transaction to generate the signature base
                if (this._envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
                    tx = _xdr["default"].Transaction.fromXDR(Buffer.concat([
                        // TransactionV0 is a transaction with the AccountID discriminant
                        // stripped off, we need to put it back to build a valid transaction
                        // which we can use to build a TransactionSignaturePayloadTaggedTransaction
                        _xdr["default"].PublicKeyType.publicKeyTypeEd25519().toXDR(),
                        tx.toXDR()
                    ]));
                }
                var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(tx);
                var txSignature = new _xdr["default"].TransactionSignaturePayload({
                    networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
                    taggedTransaction: taggedTransaction
                });
                return txSignature.toXDR();
            }
        },
        {
            key: "toEnvelope",
            value: function toEnvelope() {
                var rawTx = this.tx.toXDR();
                var signatures = this.signatures.slice(); // make a copy of the signatures
                var envelope;
                switch(this._envelopeType){
                    case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
                        envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxV0(new _xdr["default"].TransactionV0Envelope({
                            tx: _xdr["default"].TransactionV0.fromXDR(rawTx),
                            // make a copy of tx
                            signatures: signatures
                        }));
                        break;
                    case _xdr["default"].EnvelopeType.envelopeTypeTx():
                        envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
                            tx: _xdr["default"].Transaction.fromXDR(rawTx),
                            // make a copy of tx
                            signatures: signatures
                        }));
                        break;
                    default:
                        throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name, "."));
                }
                return envelope;
            }
        },
        {
            key: "getClaimableBalanceId",
            value: function getClaimableBalanceId(opIndex) {
                // Validate and then extract the operation from the transaction.
                if (!Number.isInteger(opIndex) || opIndex < 0 || opIndex >= this.operations.length) {
                    throw new RangeError('invalid operation index');
                }
                var op = this.operations[opIndex];
                try {
                    op = _operation.Operation.createClaimableBalance(op);
                } catch (err) {
                    throw new TypeError("expected createClaimableBalance, got ".concat(op.type, ": ").concat(err));
                }
                // Always use the transaction's *unmuxed* source.
                var account = _strkey.StrKey.decodeEd25519PublicKey((0, _decode_encode_muxed_account.extractBaseAddress)(this.source));
                var operationId = _xdr["default"].HashIdPreimage.envelopeTypeOpId(new _xdr["default"].HashIdPreimageOperationId({
                    sourceAccount: _xdr["default"].AccountId.publicKeyTypeEd25519(account),
                    seqNum: _xdr["default"].SequenceNumber.fromString(this.sequence),
                    opNum: opIndex
                }));
                var opIdHash = (0, _hashing.hash)(operationId.toXDR('raw'));
                var balanceId = _xdr["default"].ClaimableBalanceId.claimableBalanceIdTypeV0(opIdHash);
                return balanceId.toXDR('hex');
            }
        }
    ]);
}(_transaction_base.TransactionBase);
}}),
"[project]/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FeeBumpTransaction = void 0;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _hashing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/hashing.js [app-ssr] (ecmascript)");
var _transaction = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/transaction.js [app-ssr] (ecmascript)");
var _transaction_base = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/transaction_base.js [app-ssr] (ecmascript)");
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
}
function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(t, "prototype", {
        writable: !1
    }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
}
/**
 * Use {@link TransactionBuilder.buildFeeBumpTransaction} to build a
 * FeeBumpTransaction object. If you have an object or base64-encoded string of
 * the transaction envelope XDR use {@link TransactionBuilder.fromXDR}.
 *
 * Once a {@link FeeBumpTransaction} has been created, its attributes and operations
 * should not be changed. You should only add signatures (using {@link FeeBumpTransaction#sign}) before
 * submitting to the network or forwarding on to additional signers.
 *
 * @param {string|xdr.TransactionEnvelope} envelope - transaction envelope
 *     object or base64 encoded string.
 * @param {string} networkPassphrase - passphrase of the target Stellar network
 *     (e.g. "Public Global Stellar Network ; September 2015").
 *
 * @extends TransactionBase
 */ var FeeBumpTransaction = exports.FeeBumpTransaction = /*#__PURE__*/ function(_TransactionBase) {
    function FeeBumpTransaction(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, FeeBumpTransaction);
        if (typeof envelope === 'string') {
            var buffer = Buffer.from(envelope, 'base64');
            envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (envelopeType !== _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
            throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        // clone signatures
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, FeeBumpTransaction, [
            tx,
            signatures,
            fee,
            networkPassphrase
        ]);
        var innerTxEnvelope = _xdr["default"].TransactionEnvelope.envelopeTypeTx(tx.innerTx().v1());
        _this._feeSource = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.feeSource());
        _this._innerTransaction = new _transaction.Transaction(innerTxEnvelope, networkPassphrase);
        return _this;
    }
    /**
   * @type {Transaction}
   * @readonly
   */ _inherits(FeeBumpTransaction, _TransactionBase);
    return _createClass(FeeBumpTransaction, [
        {
            key: "innerTransaction",
            get: function get() {
                return this._innerTransaction;
            }
        },
        {
            key: "operations",
            get: function get() {
                return this._innerTransaction.operations;
            }
        },
        {
            key: "feeSource",
            get: function get() {
                return this._feeSource;
            }
        },
        {
            key: "signatureBase",
            value: function signatureBase() {
                var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx);
                var txSignature = new _xdr["default"].TransactionSignaturePayload({
                    networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
                    taggedTransaction: taggedTransaction
                });
                return txSignature.toXDR();
            }
        },
        {
            key: "toEnvelope",
            value: function toEnvelope() {
                var envelope = new _xdr["default"].FeeBumpTransactionEnvelope({
                    tx: _xdr["default"].FeeBumpTransaction.fromXDR(this.tx.toXDR()),
                    // make a copy of the tx
                    signatures: this.signatures.slice() // make a copy of the signatures
                });
                return new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(envelope);
            }
        }
    ]);
}(_transaction_base.TransactionBase);
}}),
"[project]/node_modules/@stellar/stellar-base/lib/account.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Account = void 0;
var _bignumber = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/bignumber.js [app-ssr] (ecmascript)"));
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Create a new Account object.
 *
 * `Account` represents a single account in the Stellar network and its sequence
 * number. Account tracks the sequence number as it is used by {@link
 * TransactionBuilder}. See
 * [Accounts](https://developers.stellar.org/docs/glossary/accounts/) for
 * more information about how accounts work in Stellar.
 *
 * @constructor
 *
 * @param {string} accountId - ID of the account (ex.
 *     `GB3KJPLFUYN5VL6R3GU3EGCGVCKFDSD7BEDX42HWG5BWFKB3KQGJJRMA`). If you
 *     provide a muxed account address, this will throw; use {@link
 *     MuxedAccount} instead.
 * @param {string} sequence  - current sequence number of the account
 */ var Account = exports.Account = /*#__PURE__*/ function() {
    function Account(accountId, sequence) {
        _classCallCheck(this, Account);
        if (_strkey.StrKey.isValidMed25519PublicKey(accountId)) {
            throw new Error('accountId is an M-address; use MuxedAccount instead');
        }
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
            throw new Error('accountId is invalid');
        }
        if (!(typeof sequence === 'string')) {
            throw new Error('sequence must be of type string');
        }
        this._accountId = accountId;
        this.sequence = new _bignumber["default"](sequence);
    }
    /**
   * Returns Stellar account ID, ex.
   * `GB3KJPLFUYN5VL6R3GU3EGCGVCKFDSD7BEDX42HWG5BWFKB3KQGJJRMA`.
   * @returns {string}
   */ return _createClass(Account, [
        {
            key: "accountId",
            value: function accountId() {
                return this._accountId;
            }
        },
        {
            key: "sequenceNumber",
            value: function sequenceNumber() {
                return this.sequence.toString();
            }
        },
        {
            key: "incrementSequenceNumber",
            value: function incrementSequenceNumber() {
                this.sequence = this.sequence.plus(1);
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/muxed_account.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MuxedAccount = void 0;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/account.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Represents a muxed account for transactions and operations.
 *
 * A muxed (or *multiplexed*) account (defined rigorously in
 * [CAP-27](https://stellar.org/protocol/cap-27) and briefly in
 * [SEP-23](https://stellar.org/protocol/sep-23)) is one that resolves a single
 * Stellar `G...`` account to many different underlying IDs.
 *
 * For example, you may have a single Stellar address for accounting purposes:
 *   GA7QYNF7SOWQ3GLR2BGMZEHXAVIRZA4KVWLTJJFC7MGXUA74P7UJVSGZ
 *
 * Yet would like to use it for 4 different family members:
 *   1: MA7QYNF7SOWQ3GLR2BGMZEHXAVIRZA4KVWLTJJFC7MGXUA74P7UJUAAAAAAAAAAAAGZFQ
 *   2: MA7QYNF7SOWQ3GLR2BGMZEHXAVIRZA4KVWLTJJFC7MGXUA74P7UJUAAAAAAAAAAAALIWQ
 *   3: MA7QYNF7SOWQ3GLR2BGMZEHXAVIRZA4KVWLTJJFC7MGXUA74P7UJUAAAAAAAAAAAAPYHQ
 *   4: MA7QYNF7SOWQ3GLR2BGMZEHXAVIRZA4KVWLTJJFC7MGXUA74P7UJUAAAAAAAAAAAAQLQQ
 *
 * This object makes it easy to create muxed accounts from regular accounts,
 * duplicate them, get/set the underlying IDs, etc. without mucking around with
 * the raw XDR.
 *
 * Because muxed accounts are purely an off-chain convention, they all share the
 * sequence number tied to their underlying G... account. Thus, this object
 * *requires* an {@link Account} instance to be passed in, so that muxed
 * instances of an account can collectively modify the sequence number whenever
 * a muxed account is used as the source of a @{link Transaction} with {@link
 * TransactionBuilder}.
 *
 * @constructor
 *
 * @param {Account}   account - the @{link Account} instance representing the
 *                              underlying G... address
 * @param {string}    id      - a stringified uint64 value that represents the
 *                              ID of the muxed account
 *
 * @link https://developers.stellar.org/docs/glossary/muxed-accounts/
 */ var MuxedAccount = exports.MuxedAccount = /*#__PURE__*/ function() {
    function MuxedAccount(baseAccount, id) {
        _classCallCheck(this, MuxedAccount);
        var accountId = baseAccount.accountId();
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
            throw new Error('accountId is invalid');
        }
        this.account = baseAccount;
        this._muxedXdr = (0, _decode_encode_muxed_account.encodeMuxedAccount)(accountId, id);
        this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
        this._id = id;
    }
    /**
   * Parses an M-address into a MuxedAccount object.
   *
   * @param  {string} mAddress    - an M-address to transform
   * @param  {string} sequenceNum - the sequence number of the underlying {@link
   *     Account}, to use for the underlying base account (@link
   *     MuxedAccount.baseAccount). If you're using the SDK, you can use
   *     `server.loadAccount` to fetch this if you don't know it.
   *
   * @return {MuxedAccount}
   */ return _createClass(MuxedAccount, [
        {
            key: "baseAccount",
            value: /**
     * @return {Account} the underlying account object shared among all muxed
     *     accounts with this Stellar address
     */ function baseAccount() {
                return this.account;
            }
        },
        {
            key: "accountId",
            value: function accountId() {
                return this._mAddress;
            }
        },
        {
            key: "id",
            value: function id() {
                return this._id;
            }
        },
        {
            key: "setId",
            value: function setId(id) {
                if (typeof id !== 'string') {
                    throw new Error('id should be a string representing a number (uint64)');
                }
                this._muxedXdr.med25519().id(_xdr["default"].Uint64.fromString(id));
                this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
                this._id = id;
                return this;
            }
        },
        {
            key: "sequenceNumber",
            value: function sequenceNumber() {
                return this.account.sequenceNumber();
            }
        },
        {
            key: "incrementSequenceNumber",
            value: function incrementSequenceNumber() {
                return this.account.incrementSequenceNumber();
            }
        },
        {
            key: "toXDRObject",
            value: function toXDRObject() {
                return this._muxedXdr;
            }
        },
        {
            key: "equals",
            value: function equals(otherMuxedAccount) {
                return this.accountId() === otherMuxedAccount.accountId();
            }
        }
    ], [
        {
            key: "fromAddress",
            value: function fromAddress(mAddress, sequenceNum) {
                var muxedAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(mAddress);
                var gAddress = (0, _decode_encode_muxed_account.extractBaseAddress)(mAddress);
                var id = muxedAccount.med25519().id().toString();
                return new MuxedAccount(new _account.Account(gAddress, sequenceNum), id);
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SorobanDataBuilder = void 0;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Supports building {@link xdr.SorobanTransactionData} structures with various
 * items set to specific values.
 *
 * This is recommended for when you are building
 * {@link Operation.extendFootprintTtl} / {@link Operation.restoreFootprint}
 * operations and need to {@link TransactionBuilder.setSorobanData} to avoid
 * (re)building the entire data structure from scratch.
 *
 * @constructor
 *
 * @param {string | xdr.SorobanTransactionData} [sorobanData]  either a
 *      base64-encoded string that represents an
 *      {@link xdr.SorobanTransactionData} instance or an XDR instance itself
 *      (it will be copied); if omitted or "falsy" (e.g. an empty string), it
 *      starts with an empty instance
 *
 * @example
 * // You want to use an existing data blob but override specific parts.
 * const newData = new SorobanDataBuilder(existing)
 *   .setReadOnly(someLedgerKeys)
 *   .setRefundableFee("1000")
 *   .build();
 *
 * // You want an instance from scratch
 * const newData = new SorobanDataBuilder()
 *   .setFootprint([someLedgerKey], [])
 *   .setRefundableFee("1000")
 *   .build();
 */ var SorobanDataBuilder = exports.SorobanDataBuilder = /*#__PURE__*/ function() {
    function SorobanDataBuilder(sorobanData) {
        _classCallCheck(this, SorobanDataBuilder);
        _defineProperty(this, "_data", void 0);
        var data;
        if (!sorobanData) {
            data = new _xdr["default"].SorobanTransactionData({
                resources: new _xdr["default"].SorobanResources({
                    footprint: new _xdr["default"].LedgerFootprint({
                        readOnly: [],
                        readWrite: []
                    }),
                    instructions: 0,
                    readBytes: 0,
                    writeBytes: 0
                }),
                ext: new _xdr["default"].ExtensionPoint(0),
                resourceFee: new _xdr["default"].Int64(0)
            });
        } else if (typeof sorobanData === 'string' || ArrayBuffer.isView(sorobanData)) {
            data = SorobanDataBuilder.fromXDR(sorobanData);
        } else {
            data = SorobanDataBuilder.fromXDR(sorobanData.toXDR()); // copy
        }
        this._data = data;
    }
    /**
   * Decodes and builds a {@link xdr.SorobanTransactionData} instance.
   * @param {Uint8Array|Buffer|string} data   raw input to decode
   * @returns {xdr.SorobanTransactionData}
   */ return _createClass(SorobanDataBuilder, [
        {
            key: "setResourceFee",
            value: /**
     * Sets the resource fee portion of the Soroban data.
     * @param {number | bigint | string} fee  the resource fee to set (int64)
     * @returns {SorobanDataBuilder}
     */ function setResourceFee(fee) {
                this._data.resourceFee(new _xdr["default"].Int64(fee));
                return this;
            }
        },
        {
            key: "setResources",
            value: function setResources(cpuInstrs, readBytes, writeBytes) {
                this._data.resources().instructions(cpuInstrs);
                this._data.resources().readBytes(readBytes);
                this._data.resources().writeBytes(writeBytes);
                return this;
            }
        },
        {
            key: "appendFootprint",
            value: function appendFootprint(readOnly, readWrite) {
                return this.setFootprint(this.getReadOnly().concat(readOnly), this.getReadWrite().concat(readWrite));
            }
        },
        {
            key: "setFootprint",
            value: function setFootprint(readOnly, readWrite) {
                if (readOnly !== null) {
                    // null means "leave me alone"
                    this.setReadOnly(readOnly);
                }
                if (readWrite !== null) {
                    this.setReadWrite(readWrite);
                }
                return this;
            }
        },
        {
            key: "setReadOnly",
            value: function setReadOnly(readOnly) {
                this._data.resources().footprint().readOnly(readOnly !== null && readOnly !== void 0 ? readOnly : []);
                return this;
            }
        },
        {
            key: "setReadWrite",
            value: function setReadWrite(readWrite) {
                this._data.resources().footprint().readWrite(readWrite !== null && readWrite !== void 0 ? readWrite : []);
                return this;
            }
        },
        {
            key: "build",
            value: function build() {
                return _xdr["default"].SorobanTransactionData.fromXDR(this._data.toXDR()); // clone
            }
        },
        {
            key: "getReadOnly",
            value: function getReadOnly() {
                return this.getFootprint().readOnly();
            }
        },
        {
            key: "getReadWrite",
            value: function getReadWrite() {
                return this.getFootprint().readWrite();
            }
        },
        {
            key: "getFootprint",
            value: function getFootprint() {
                return this._data.resources().footprint();
            }
        }
    ], [
        {
            key: "fromXDR",
            value: function fromXDR(data) {
                return _xdr["default"].SorobanTransactionData.fromXDR(data, typeof data === 'string' ? 'base64' : 'raw');
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/signerkey.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SignerKey = void 0;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * A container class with helpers to convert between signer keys
 * (`xdr.SignerKey`) and {@link StrKey}s.
 *
 * It's primarly used for manipulating the `extraSigners` precondition on a
 * {@link Transaction}.
 *
 * @see {@link TransactionBuilder.setExtraSigners}
 */ var SignerKey = exports.SignerKey = /*#__PURE__*/ function() {
    function SignerKey() {
        _classCallCheck(this, SignerKey);
    }
    return _createClass(SignerKey, null, [
        {
            key: "decodeAddress",
            value: /**
     * Decodes a StrKey address into an xdr.SignerKey instance.
     *
     * Only ED25519 public keys (G...), pre-auth transactions (T...), hashes
     * (H...), and signed payloads (P...) can be signer keys.
     *
     * @param   {string} address  a StrKey-encoded signer address
     * @returns {xdr.SignerKey}
     */ function decodeAddress(address) {
                var signerKeyMap = {
                    ed25519PublicKey: _xdr["default"].SignerKey.signerKeyTypeEd25519,
                    preAuthTx: _xdr["default"].SignerKey.signerKeyTypePreAuthTx,
                    sha256Hash: _xdr["default"].SignerKey.signerKeyTypeHashX,
                    signedPayload: _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload
                };
                var vb = _strkey.StrKey.getVersionByteForPrefix(address);
                var encoder = signerKeyMap[vb];
                if (!encoder) {
                    throw new Error("invalid signer key type (".concat(vb, ")"));
                }
                var raw = (0, _strkey.decodeCheck)(vb, address);
                switch(vb){
                    case 'signedPayload':
                        return encoder(new _xdr["default"].SignerKeyEd25519SignedPayload({
                            ed25519: raw.slice(0, 32),
                            payload: raw.slice(32 + 4)
                        }));
                    case 'ed25519PublicKey':
                    case 'preAuthTx':
                    case 'sha256Hash':
                    default:
                        return encoder(raw);
                }
            }
        },
        {
            key: "encodeSignerKey",
            value: function encodeSignerKey(signerKey) {
                var strkeyType;
                var raw;
                switch(signerKey["switch"]()){
                    case _xdr["default"].SignerKeyType.signerKeyTypeEd25519():
                        strkeyType = 'ed25519PublicKey';
                        raw = signerKey.value();
                        break;
                    case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx():
                        strkeyType = 'preAuthTx';
                        raw = signerKey.value();
                        break;
                    case _xdr["default"].SignerKeyType.signerKeyTypeHashX():
                        strkeyType = 'sha256Hash';
                        raw = signerKey.value();
                        break;
                    case _xdr["default"].SignerKeyType.signerKeyTypeEd25519SignedPayload():
                        strkeyType = 'signedPayload';
                        raw = signerKey.ed25519SignedPayload().toXDR('raw');
                        break;
                    default:
                        throw new Error("invalid SignerKey (type: ".concat(signerKey["switch"](), ")"));
                }
                return (0, _strkey.encodeCheck)(strkeyType, raw);
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/transaction_builder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = void 0;
exports.isValidDate = isValidDate;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var _bignumber = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/bignumber.js [app-ssr] (ecmascript)"));
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/account.js [app-ssr] (ecmascript)");
var _muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/muxed_account.js [app-ssr] (ecmascript)");
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
var _transaction = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/transaction.js [app-ssr] (ecmascript)");
var _fee_bump_transaction = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js [app-ssr] (ecmascript)");
var _sorobandata_builder = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _signerkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/signerkey.js [app-ssr] (ecmascript)");
var _memo = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/memo.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Minimum base fee for transactions. If this fee is below the network
 * minimum, the transaction will fail. The more operations in the
 * transaction, the greater the required fee. Use {@link
 * Server#fetchBaseFee} to get an accurate value of minimum transaction
 * fee on the network.
 *
 * @constant
 * @see [Fees](https://developers.stellar.org/docs/glossary/fees/)
 */ var BASE_FEE = exports.BASE_FEE = '100'; // Stroops
/**
 * @constant
 * @see {@link TransactionBuilder#setTimeout}
 * @see [Timeout](https://developers.stellar.org/api/resources/transactions/post/)
 */ var TimeoutInfinite = exports.TimeoutInfinite = 0;
/**
 * <p>Transaction builder helps constructs a new `{@link Transaction}` using the
 * given {@link Account} as the transaction's "source account". The transaction
 * will use the current sequence number of the given account as its sequence
 * number and increment the given account's sequence number by one. The given
 * source account must include a private key for signing the transaction or an
 * error will be thrown.</p>
 *
 * <p>Operations can be added to the transaction via their corresponding builder
 * methods, and each returns the TransactionBuilder object so they can be
 * chained together. After adding the desired operations, call the `build()`
 * method on the `TransactionBuilder` to return a fully constructed `{@link
 * Transaction}` that can be signed. The returned transaction will contain the
 * sequence number of the source account and include the signature from the
 * source account.</p>
 *
 * <p><strong>Be careful about unsubmitted transactions!</strong> When you build
 * a transaction, `stellar-sdk` automatically increments the source account's
 * sequence number. If you end up not submitting this transaction and submitting
 * another one instead, it'll fail due to the sequence number being wrong. So if
 * you decide not to use a built transaction, make sure to update the source
 * account's sequence number with
 * [Server.loadAccount](https://stellar.github.io/js-stellar-sdk/Server.html#loadAccount)
 * before creating another transaction.</p>
 *
 * <p>The following code example creates a new transaction with {@link
 * Operation.createAccount} and {@link Operation.payment} operations. The
 * Transaction's source account first funds `destinationA`, then sends a payment
 * to `destinationB`. The built transaction is then signed by
 * `sourceKeypair`.</p>
 *
 * ```
 * var transaction = new TransactionBuilder(source, { fee, networkPassphrase: Networks.TESTNET })
 * .addOperation(Operation.createAccount({
 *     destination: destinationA,
 *     startingBalance: "20"
 * })) // <- funds and creates destinationA
 * .addOperation(Operation.payment({
 *     destination: destinationB,
 *     amount: "100",
 *     asset: Asset.native()
 * })) // <- sends 100 XLM to destinationB
 * .setTimeout(30)
 * .build();
 *
 * transaction.sign(sourceKeypair);
 * ```
 *
 * @constructor
 *
 * @param {Account} sourceAccount - source account for this transaction
 * @param {object}  opts          - Options object
 * @param {string}  opts.fee      - max fee you're willing to pay per
 *     operation in this transaction (**in stroops**)
 *
 * @param {object}              [opts.timebounds] - timebounds for the
 *     validity of this transaction
 * @param {number|string|Date}  [opts.timebounds.minTime] - 64-bit UNIX
 *     timestamp or Date object
 * @param {number|string|Date}  [opts.timebounds.maxTime] - 64-bit UNIX
 *     timestamp or Date object
 * @param {object}              [opts.ledgerbounds] - ledger bounds for the
 *     validity of this transaction
 * @param {number}              [opts.ledgerbounds.minLedger] - number of the minimum
 *     ledger sequence
 * @param {number}              [opts.ledgerbounds.maxLedger] - number of the maximum
 *     ledger sequence
 * @param {string}              [opts.minAccountSequence] - number for
 *     the minimum account sequence
 * @param {number}              [opts.minAccountSequenceAge] - number of
 *     seconds for the minimum account sequence age
 * @param {number}              [opts.minAccountSequenceLedgerGap] - number of
 *     ledgers for the minimum account sequence ledger gap
 * @param {string[]}            [opts.extraSigners] - list of the extra signers
 *     required for this transaction
 * @param {Memo}                [opts.memo] - memo for the transaction
 * @param {string}              [opts.networkPassphrase] passphrase of the
 *     target Stellar network (e.g. "Public Global Stellar Network ; September
 *     2015" for the pubnet)
 * @param {xdr.SorobanTransactionData | string}  [opts.sorobanData] - an
 *     optional instance of {@link xdr.SorobanTransactionData} to be set as the
 *     internal `Transaction.Ext.SorobanData` field (either the xdr object or a
 *     base64 string). In the case of Soroban transactions, this can be obtained
 *     from a prior simulation of the transaction with a contract invocation and
 *     provides necessary resource estimations. You can also use
 *     {@link SorobanDataBuilder} to construct complicated combinations of
 *     parameters without mucking with XDR directly. **Note:** For
 *     non-contract(non-Soroban) transactions, this has no effect.
 */ var TransactionBuilder = exports.TransactionBuilder = /*#__PURE__*/ function() {
    function TransactionBuilder(sourceAccount) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        _classCallCheck(this, TransactionBuilder);
        if (!sourceAccount) {
            throw new Error('must specify source account for the transaction');
        }
        if (opts.fee === undefined) {
            throw new Error('must specify fee for the transaction (in stroops)');
        }
        this.source = sourceAccount;
        this.operations = [];
        this.baseFee = opts.fee;
        this.timebounds = opts.timebounds ? _objectSpread({}, opts.timebounds) : null;
        this.ledgerbounds = opts.ledgerbounds ? _objectSpread({}, opts.ledgerbounds) : null;
        this.minAccountSequence = opts.minAccountSequence || null;
        this.minAccountSequenceAge = opts.minAccountSequenceAge || null;
        this.minAccountSequenceLedgerGap = opts.minAccountSequenceLedgerGap || null;
        this.extraSigners = opts.extraSigners ? _toConsumableArray(opts.extraSigners) : null;
        this.memo = opts.memo || _memo.Memo.none();
        this.networkPassphrase = opts.networkPassphrase || null;
        this.sorobanData = opts.sorobanData ? new _sorobandata_builder.SorobanDataBuilder(opts.sorobanData).build() : null;
    }
    /**
   * Creates a builder instance using an existing {@link Transaction} as a
   * template, ignoring any existing envelope signatures.
   *
   * Note that the sequence number WILL be cloned, so EITHER this transaction or
   * the one it was cloned from will be valid. This is useful in situations
   * where you are constructing a transaction in pieces and need to make
   * adjustments as you go (for example, when filling out Soroban resource
   * information).
   *
   * @param {Transaction} tx  a "template" transaction to clone exactly
   * @param {object} [opts]   additional options to override the clone, e.g.
   *    {fee: '1000'} will override the existing base fee derived from `tx` (see
   *    the {@link TransactionBuilder} constructor for detailed options)
   *
   * @returns {TransactionBuilder} a "prepared" builder instance with the same
   *    configuration and operations as the given transaction
   *
   * @warning This does not clone the transaction's
   *    {@link xdr.SorobanTransactionData} (if applicable), use
   *    {@link SorobanDataBuilder} and {@link TransactionBuilder.setSorobanData}
   *    as needed, instead..
   *
   * @todo This cannot clone {@link FeeBumpTransaction}s, yet.
   */ return _createClass(TransactionBuilder, [
        {
            key: "addOperation",
            value: /**
     * Adds an operation to the transaction.
     *
     * @param {xdr.Operation} operation   The xdr operation object, use {@link
     *     Operation} static methods.
     *
     * @returns {TransactionBuilder}
     */ function addOperation(operation) {
                this.operations.push(operation);
                return this;
            }
        },
        {
            key: "addOperationAt",
            value: function addOperationAt(operation, index) {
                this.operations.splice(index, 0, operation);
                return this;
            }
        },
        {
            key: "clearOperations",
            value: function clearOperations() {
                this.operations = [];
                return this;
            }
        },
        {
            key: "clearOperationAt",
            value: function clearOperationAt(index) {
                this.operations.splice(index, 1);
                return this;
            }
        },
        {
            key: "addMemo",
            value: function addMemo(memo) {
                this.memo = memo;
                return this;
            }
        },
        {
            key: "setTimeout",
            value: function setTimeout(timeoutSeconds) {
                if (this.timebounds !== null && this.timebounds.maxTime > 0) {
                    throw new Error('TimeBounds.max_time has been already set - setting timeout would overwrite it.');
                }
                if (timeoutSeconds < 0) {
                    throw new Error('timeout cannot be negative');
                }
                if (timeoutSeconds > 0) {
                    var timeoutTimestamp = Math.floor(Date.now() / 1000) + timeoutSeconds;
                    if (this.timebounds === null) {
                        this.timebounds = {
                            minTime: 0,
                            maxTime: timeoutTimestamp
                        };
                    } else {
                        this.timebounds = {
                            minTime: this.timebounds.minTime,
                            maxTime: timeoutTimestamp
                        };
                    }
                } else {
                    this.timebounds = {
                        minTime: 0,
                        maxTime: 0
                    };
                }
                return this;
            }
        },
        {
            key: "setTimebounds",
            value: function setTimebounds(minEpochOrDate, maxEpochOrDate) {
                // Force it to a date type
                if (typeof minEpochOrDate === 'number') {
                    minEpochOrDate = new Date(minEpochOrDate * 1000);
                }
                if (typeof maxEpochOrDate === 'number') {
                    maxEpochOrDate = new Date(maxEpochOrDate * 1000);
                }
                if (this.timebounds !== null) {
                    throw new Error('TimeBounds has been already set - setting timebounds would overwrite it.');
                }
                // Convert that date to the epoch seconds
                var minTime = Math.floor(minEpochOrDate.valueOf() / 1000);
                var maxTime = Math.floor(maxEpochOrDate.valueOf() / 1000);
                if (minTime < 0) {
                    throw new Error('min_time cannot be negative');
                }
                if (maxTime < 0) {
                    throw new Error('max_time cannot be negative');
                }
                if (maxTime > 0 && minTime > maxTime) {
                    throw new Error('min_time cannot be greater than max_time');
                }
                this.timebounds = {
                    minTime: minTime,
                    maxTime: maxTime
                };
                return this;
            }
        },
        {
            key: "setLedgerbounds",
            value: function setLedgerbounds(minLedger, maxLedger) {
                if (this.ledgerbounds !== null) {
                    throw new Error('LedgerBounds has been already set - setting ledgerbounds would overwrite it.');
                }
                if (minLedger < 0) {
                    throw new Error('min_ledger cannot be negative');
                }
                if (maxLedger < 0) {
                    throw new Error('max_ledger cannot be negative');
                }
                if (maxLedger > 0 && minLedger > maxLedger) {
                    throw new Error('min_ledger cannot be greater than max_ledger');
                }
                this.ledgerbounds = {
                    minLedger: minLedger,
                    maxLedger: maxLedger
                };
                return this;
            }
        },
        {
            key: "setMinAccountSequence",
            value: function setMinAccountSequence(minAccountSequence) {
                if (this.minAccountSequence !== null) {
                    throw new Error('min_account_sequence has been already set - setting min_account_sequence would overwrite it.');
                }
                this.minAccountSequence = minAccountSequence;
                return this;
            }
        },
        {
            key: "setMinAccountSequenceAge",
            value: function setMinAccountSequenceAge(durationInSeconds) {
                if (typeof durationInSeconds !== 'number') {
                    throw new Error('min_account_sequence_age must be a number');
                }
                if (this.minAccountSequenceAge !== null) {
                    throw new Error('min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.');
                }
                if (durationInSeconds < 0) {
                    throw new Error('min_account_sequence_age cannot be negative');
                }
                this.minAccountSequenceAge = durationInSeconds;
                return this;
            }
        },
        {
            key: "setMinAccountSequenceLedgerGap",
            value: function setMinAccountSequenceLedgerGap(gap) {
                if (this.minAccountSequenceLedgerGap !== null) {
                    throw new Error('min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.');
                }
                if (gap < 0) {
                    throw new Error('min_account_sequence_ledger_gap cannot be negative');
                }
                this.minAccountSequenceLedgerGap = gap;
                return this;
            }
        },
        {
            key: "setExtraSigners",
            value: function setExtraSigners(extraSigners) {
                if (!Array.isArray(extraSigners)) {
                    throw new Error('extra_signers must be an array of strings.');
                }
                if (this.extraSigners !== null) {
                    throw new Error('extra_signers has been already set - setting extra_signers would overwrite it.');
                }
                if (extraSigners.length > 2) {
                    throw new Error('extra_signers cannot be longer than 2 elements.');
                }
                this.extraSigners = _toConsumableArray(extraSigners);
                return this;
            }
        },
        {
            key: "setNetworkPassphrase",
            value: function setNetworkPassphrase(networkPassphrase) {
                this.networkPassphrase = networkPassphrase;
                return this;
            }
        },
        {
            key: "setSorobanData",
            value: function setSorobanData(sorobanData) {
                this.sorobanData = new _sorobandata_builder.SorobanDataBuilder(sorobanData).build();
                return this;
            }
        },
        {
            key: "build",
            value: function build() {
                var sequenceNumber = new _bignumber["default"](this.source.sequenceNumber()).plus(1);
                var fee = new _bignumber["default"](this.baseFee).times(this.operations.length).toNumber();
                var attrs = {
                    fee: fee,
                    seqNum: _xdr["default"].SequenceNumber.fromString(sequenceNumber.toString()),
                    memo: this.memo ? this.memo.toXDRObject() : null
                };
                if (this.timebounds === null || typeof this.timebounds.minTime === 'undefined' || typeof this.timebounds.maxTime === 'undefined') {
                    throw new Error('TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).');
                }
                if (isValidDate(this.timebounds.minTime)) {
                    this.timebounds.minTime = this.timebounds.minTime.getTime() / 1000;
                }
                if (isValidDate(this.timebounds.maxTime)) {
                    this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1000;
                }
                this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());
                this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
                var timeBounds = new _xdr["default"].TimeBounds(this.timebounds);
                if (this.hasV2Preconditions()) {
                    var ledgerBounds = null;
                    if (this.ledgerbounds !== null) {
                        ledgerBounds = new _xdr["default"].LedgerBounds(this.ledgerbounds);
                    }
                    var minSeqNum = this.minAccountSequence || '0';
                    minSeqNum = _xdr["default"].SequenceNumber.fromString(minSeqNum);
                    var minSeqAge = _jsXdr.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : '0');
                    var minSeqLedgerGap = this.minAccountSequenceLedgerGap || 0;
                    var extraSigners = this.extraSigners !== null ? this.extraSigners.map(_signerkey.SignerKey.decodeAddress) : [];
                    attrs.cond = _xdr["default"].Preconditions.precondV2(new _xdr["default"].PreconditionsV2({
                        timeBounds: timeBounds,
                        ledgerBounds: ledgerBounds,
                        minSeqNum: minSeqNum,
                        minSeqAge: minSeqAge,
                        minSeqLedgerGap: minSeqLedgerGap,
                        extraSigners: extraSigners
                    }));
                } else {
                    attrs.cond = _xdr["default"].Preconditions.precondTime(timeBounds);
                }
                attrs.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(this.source.accountId());
                // TODO - remove this workaround for TransactionExt ts constructor
                //       and use the typescript generated static factory method once fixed
                //       https://github.com/stellar/dts-xdr/issues/5
                if (this.sorobanData) {
                    // @ts-ignore
                    attrs.ext = new _xdr["default"].TransactionExt(1, this.sorobanData);
                } else {
                    // @ts-ignore
                    attrs.ext = new _xdr["default"].TransactionExt(0, _xdr["default"].Void);
                }
                var xtx = new _xdr["default"].Transaction(attrs);
                xtx.operations(this.operations);
                var txEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
                    tx: xtx
                }));
                var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase);
                this.source.incrementSequenceNumber();
                return tx;
            }
        },
        {
            key: "hasV2Preconditions",
            value: function hasV2Preconditions() {
                return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0;
            }
        }
    ], [
        {
            key: "cloneFrom",
            value: function cloneFrom(tx) {
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                if (!(tx instanceof _transaction.Transaction)) {
                    throw new TypeError("expected a 'Transaction', got: ".concat(tx));
                }
                var sequenceNum = (BigInt(tx.sequence) - 1n).toString();
                var source;
                // rebuild the source account based on the strkey
                if (_strkey.StrKey.isValidMed25519PublicKey(tx.source)) {
                    source = _muxed_account.MuxedAccount.fromAddress(tx.source, sequenceNum);
                } else if (_strkey.StrKey.isValidEd25519PublicKey(tx.source)) {
                    source = new _account.Account(tx.source, sequenceNum);
                } else {
                    throw new TypeError("unsupported tx source account: ".concat(tx.source));
                }
                // the initial fee passed to the builder gets scaled up based on the number
                // of operations at the end, so we have to down-scale first
                var unscaledFee = parseInt(tx.fee, 10) / tx.operations.length;
                var builder = new TransactionBuilder(source, _objectSpread({
                    fee: (unscaledFee || BASE_FEE).toString(),
                    memo: tx.memo,
                    networkPassphrase: tx.networkPassphrase,
                    timebounds: tx.timeBounds,
                    ledgerbounds: tx.ledgerBounds,
                    minAccountSequence: tx.minAccountSequence,
                    minAccountSequenceAge: tx.minAccountSequenceAge,
                    minAccountSequenceLedgerGap: tx.minAccountSequenceLedgerGap,
                    extraSigners: tx.extraSigners
                }, opts));
                tx._tx.operations().forEach(function(op) {
                    return builder.addOperation(op);
                });
                return builder;
            }
        },
        {
            key: "buildFeeBumpTransaction",
            value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase) {
                var innerOps = innerTx.operations.length;
                var innerBaseFeeRate = new _bignumber["default"](innerTx.fee).div(innerOps);
                var base = new _bignumber["default"](baseFee);
                // The fee rate for fee bump is at least the fee rate of the inner transaction
                if (base.lt(innerBaseFeeRate)) {
                    throw new Error("Invalid baseFee, it should be at least ".concat(innerBaseFeeRate, " stroops."));
                }
                var minBaseFee = new _bignumber["default"](BASE_FEE);
                // The fee rate is at least the minimum fee
                if (base.lt(minBaseFee)) {
                    throw new Error("Invalid baseFee, it should be at least ".concat(minBaseFee, " stroops."));
                }
                var innerTxEnvelope = innerTx.toEnvelope();
                if (innerTxEnvelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
                    var v0Tx = innerTxEnvelope.v0().tx();
                    var v1Tx = new _xdr["default"].Transaction({
                        sourceAccount: new _xdr["default"].MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),
                        fee: v0Tx.fee(),
                        seqNum: v0Tx.seqNum(),
                        cond: _xdr["default"].Preconditions.precondTime(v0Tx.timeBounds()),
                        memo: v0Tx.memo(),
                        operations: v0Tx.operations(),
                        ext: new _xdr["default"].TransactionExt(0)
                    });
                    innerTxEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
                        tx: v1Tx,
                        signatures: innerTxEnvelope.v0().signatures()
                    }));
                }
                var feeSourceAccount;
                if (typeof feeSource === 'string') {
                    feeSourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(feeSource);
                } else {
                    feeSourceAccount = feeSource.xdrMuxedAccount();
                }
                var tx = new _xdr["default"].FeeBumpTransaction({
                    feeSource: feeSourceAccount,
                    fee: _xdr["default"].Int64.fromString(base.times(innerOps + 1).toString()),
                    innerTx: _xdr["default"].FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),
                    ext: new _xdr["default"].FeeBumpTransactionExt(0)
                });
                var feeBumpTxEnvelope = new _xdr["default"].FeeBumpTransactionEnvelope({
                    tx: tx,
                    signatures: []
                });
                var envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);
                return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
            }
        },
        {
            key: "fromXDR",
            value: function fromXDR(envelope, networkPassphrase) {
                if (typeof envelope === 'string') {
                    envelope = _xdr["default"].TransactionEnvelope.fromXDR(envelope, 'base64');
                }
                if (envelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
                    return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
                }
                return new _transaction.Transaction(envelope, networkPassphrase);
            }
        }
    ]);
}();
/**
 * Checks whether a provided object is a valid Date.
 * @argument {Date} d date object
 * @returns {boolean}
 */ function isValidDate(d) {
    // isnan is okay here because it correctly checks for invalid date objects
    // eslint-disable-next-line no-restricted-globals
    return d instanceof Date && !isNaN(d);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/network.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Networks = void 0;
/**
 * Contains passphrases for common networks:
 * * `Networks.PUBLIC`: `Public Global Stellar Network ; September 2015`
 * * `Networks.TESTNET`: `Test SDF Network ; September 2015`
 * * `Networks.FUTURENET`: `Test SDF Future Network ; October 2022`
 * * `Networks.STANDALONE`: `Standalone Network ; February 2017`
 *
 * @type {{PUBLIC: string, TESTNET: string, FUTURENET: string, STANDALONE: string }}
 */ var Networks = exports.Networks = {
    PUBLIC: 'Public Global Stellar Network ; September 2015',
    TESTNET: 'Test SDF Network ; September 2015',
    FUTURENET: 'Test SDF Future Network ; October 2022',
    SANDBOX: 'Local Sandbox Stellar Network ; September 2022',
    STANDALONE: 'Standalone Network ; February 2017'
};
}}),
"[project]/node_modules/@stellar/stellar-base/lib/soroban.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Soroban = void 0;
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _toArray(r) {
    return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/* Helper class to assist with formatting and parsing token amounts. */ var Soroban = exports.Soroban = /*#__PURE__*/ function() {
    function Soroban() {
        _classCallCheck(this, Soroban);
    }
    return _createClass(Soroban, null, [
        {
            key: "formatTokenAmount",
            value: /**
     * Given a whole number smart contract amount of a token and an amount of
     * decimal places (if the token has any), it returns a "display" value.
     *
     * All arithmetic inside the contract is performed on integers to avoid
     * potential precision and consistency issues of floating-point.
     *
     * @param {string} amount   the token amount you want to display
     * @param {number} decimals specify how many decimal places a token has
     *
     * @returns {string} the display value
     * @throws {TypeError} if the given amount has a decimal point already
     * @example
     * formatTokenAmount("123000", 4) === "12.3";
     */ function formatTokenAmount(amount, decimals) {
                if (amount.includes('.')) {
                    throw new TypeError('No decimals are allowed');
                }
                var formatted = amount;
                if (decimals > 0) {
                    if (decimals > formatted.length) {
                        formatted = [
                            '0',
                            formatted.toString().padStart(decimals, '0')
                        ].join('.');
                    } else {
                        formatted = [
                            formatted.slice(0, -decimals),
                            formatted.slice(-decimals)
                        ].join('.');
                    }
                }
                // remove trailing zero if any
                return formatted.replace(/(\.\d*?)0+$/, '$1');
            }
        },
        {
            key: "parseTokenAmount",
            value: function parseTokenAmount(value, decimals) {
                var _fraction$padEnd;
                var _value$split$slice = value.split('.').slice(), _value$split$slice2 = _toArray(_value$split$slice), whole = _value$split$slice2[0], fraction = _value$split$slice2[1], rest = _value$split$slice2.slice(2);
                if (rest.length) {
                    throw new Error("Invalid decimal value: ".concat(value));
                }
                var shifted = BigInt(whole + ((_fraction$padEnd = fraction === null || fraction === void 0 ? void 0 : fraction.padEnd(decimals, '0')) !== null && _fraction$padEnd !== void 0 ? _fraction$padEnd : '0'.repeat(decimals)));
                return shifted.toString();
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/contract.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Contract = void 0;
var _address = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/address.js [app-ssr] (ecmascript)");
var _operation = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operation.js [app-ssr] (ecmascript)");
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Create a new Contract object.
 *
 * `Contract` represents a single contract in the Stellar network, embodying the
 * interface of the contract. See
 * [Contracts](https://soroban.stellar.org/docs/learn/interacting-with-contracts)
 * for more information about how contracts work in Stellar.
 *
 * @constructor
 *
 * @param {string} contractId - ID of the contract (ex.
 *     `CA3D5KRYM6CB7OWQ6TWYRR3Z4T7GNZLKERYNZGGA5SOAOPIFY6YQGAXE`).
 */ var Contract = exports.Contract = /*#__PURE__*/ function() {
    function Contract(contractId) {
        _classCallCheck(this, Contract);
        try {
            // First, try it as a strkey
            this._id = _strkey.StrKey.decodeContract(contractId);
        } catch (_) {
            throw new Error("Invalid contract ID: ".concat(contractId));
        }
    }
    /**
   * Returns Stellar contract ID as a strkey, ex.
   * `CA3D5KRYM6CB7OWQ6TWYRR3Z4T7GNZLKERYNZGGA5SOAOPIFY6YQGAXE`.
   * @returns {string}
   */ return _createClass(Contract, [
        {
            key: "contractId",
            value: function contractId() {
                return _strkey.StrKey.encodeContract(this._id);
            }
        },
        {
            key: "toString",
            value: function toString() {
                return this.contractId();
            }
        },
        {
            key: "address",
            value: function address() {
                return _address.Address.contract(this._id);
            }
        },
        {
            key: "call",
            value: function call(method) {
                for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    params[_key - 1] = arguments[_key];
                }
                return _operation.Operation.invokeContractFunction({
                    contract: this.address().toString(),
                    "function": method,
                    args: params
                });
            }
        },
        {
            key: "getFootprint",
            value: function getFootprint() {
                return _xdr["default"].LedgerKey.contractData(new _xdr["default"].LedgerKeyContractData({
                    contract: this.address().toScAddress(),
                    key: _xdr["default"].ScVal.scvLedgerKeyContractInstance(),
                    durability: _xdr["default"].ContractDataDurability.persistent()
                }));
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/numbers/uint128.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Uint128 = void 0;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
}
function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(t, "prototype", {
        writable: !1
    }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
}
var Uint128 = exports.Uint128 = /*#__PURE__*/ function(_LargeInt) {
    /**
   * Construct an unsigned 128-bit integer that can be XDR-encoded.
   *
   * @param  {Array<number|bigint|string>}  args - one or more slices to encode
   *     in big-endian format (i.e. earlier elements are higher bits)
   */ function Uint128() {
        _classCallCheck(this, Uint128);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint128, [
            args
        ]);
    }
    _inherits(Uint128, _LargeInt);
    return _createClass(Uint128, [
        {
            key: "unsigned",
            get: function get() {
                return true;
            }
        },
        {
            key: "size",
            get: function get() {
                return 128;
            }
        }
    ]);
}(_jsXdr.LargeInt);
Uint128.defineIntBoundaries();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/numbers/uint256.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Uint256 = void 0;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
}
function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(t, "prototype", {
        writable: !1
    }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
}
var Uint256 = exports.Uint256 = /*#__PURE__*/ function(_LargeInt) {
    /**
   * Construct an unsigned 256-bit integer that can be XDR-encoded.
   *
   * @param  {Array<number|bigint|string>}  args - one or more slices to encode
   *     in big-endian format (i.e. earlier elements are higher bits)
   */ function Uint256() {
        _classCallCheck(this, Uint256);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint256, [
            args
        ]);
    }
    _inherits(Uint256, _LargeInt);
    return _createClass(Uint256, [
        {
            key: "unsigned",
            get: function get() {
                return true;
            }
        },
        {
            key: "size",
            get: function get() {
                return 256;
            }
        }
    ]);
}(_jsXdr.LargeInt);
Uint256.defineIntBoundaries();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/numbers/int128.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Int128 = void 0;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
}
function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(t, "prototype", {
        writable: !1
    }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
}
var Int128 = exports.Int128 = /*#__PURE__*/ function(_LargeInt) {
    /**
   * Construct a signed 128-bit integer that can be XDR-encoded.
   *
   * @param  {Array<number|bigint|string>}  args - one or more slices to encode
   *     in big-endian format (i.e. earlier elements are higher bits)
   */ function Int128() {
        _classCallCheck(this, Int128);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return _callSuper(this, Int128, [
            args
        ]);
    }
    _inherits(Int128, _LargeInt);
    return _createClass(Int128, [
        {
            key: "unsigned",
            get: function get() {
                return false;
            }
        },
        {
            key: "size",
            get: function get() {
                return 128;
            }
        }
    ]);
}(_jsXdr.LargeInt);
Int128.defineIntBoundaries();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/numbers/int256.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Int256 = void 0;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
}
function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(t, "prototype", {
        writable: !1
    }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
}
var Int256 = exports.Int256 = /*#__PURE__*/ function(_LargeInt) {
    /**
   * Construct a signed 256-bit integer that can be XDR-encoded.
   *
   * @param  {Array<number|bigint|string>}  args - one or more slices to encode
   *     in big-endian format (i.e. earlier elements are higher bits)
   */ function Int256() {
        _classCallCheck(this, Int256);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return _callSuper(this, Int256, [
            args
        ]);
    }
    _inherits(Int256, _LargeInt);
    return _createClass(Int256, [
        {
            key: "unsigned",
            get: function get() {
                return false;
            }
        },
        {
            key: "size",
            get: function get() {
                return 256;
            }
        }
    ]);
}(_jsXdr.LargeInt);
Int256.defineIntBoundaries();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XdrLargeInt = void 0;
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var _uint = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/uint128.js [app-ssr] (ecmascript)");
var _uint2 = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/uint256.js [app-ssr] (ecmascript)");
var _int = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/int128.js [app-ssr] (ecmascript)");
var _int2 = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/int256.js [app-ssr] (ecmascript)");
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
} /* eslint no-bitwise: ["error", {"allow": [">>"]}] */ 
/**
 * A wrapper class to represent large XDR-encodable integers.
 *
 * This operates at a lower level than {@link ScInt} by forcing you to specify
 * the type / width / size in bits of the integer you're targeting, regardless
 * of the input value(s) you provide.
 *
 * @param {string}  type - force a specific data type. the type choices are:
 *    'i64', 'u64', 'i128', 'u128', 'i256', and 'u256' (default: the smallest
 *    one that fits the `value`) (see {@link XdrLargeInt.isType})
 * @param {number|bigint|string|Array<number|bigint|string>} values   a list of
 *    integer-like values interpreted in big-endian order
 */ var XdrLargeInt = exports.XdrLargeInt = /*#__PURE__*/ function() {
    function XdrLargeInt(type, values) {
        _classCallCheck(this, XdrLargeInt);
        /** @type {xdr.LargeInt} */ _defineProperty(this, "int", void 0);
        // child class of a jsXdr.LargeInt
        /** @type {string} */ _defineProperty(this, "type", void 0);
        if (!(values instanceof Array)) {
            values = [
                values
            ];
        }
        // normalize values to one type
        values = values.map(function(i) {
            // micro-optimization to no-op on the likeliest input value:
            if (typeof i === 'bigint') {
                return i;
            }
            if (i instanceof XdrLargeInt) {
                return i.toBigInt();
            }
            return BigInt(i);
        });
        switch(type){
            case 'i64':
                this["int"] = new _jsXdr.Hyper(values);
                break;
            case 'i128':
                this["int"] = new _int.Int128(values);
                break;
            case 'i256':
                this["int"] = new _int2.Int256(values);
                break;
            case 'u64':
                this["int"] = new _jsXdr.UnsignedHyper(values);
                break;
            case 'u128':
                this["int"] = new _uint.Uint128(values);
                break;
            case 'u256':
                this["int"] = new _uint2.Uint256(values);
                break;
            default:
                throw TypeError("invalid type: ".concat(type));
        }
        this.type = type;
    }
    /**
   * @returns {number}
   * @throws {RangeError} if the value can't fit into a Number
   */ return _createClass(XdrLargeInt, [
        {
            key: "toNumber",
            value: function toNumber() {
                var bi = this["int"].toBigInt();
                if (bi > Number.MAX_SAFE_INTEGER || bi < Number.MIN_SAFE_INTEGER) {
                    throw RangeError("value ".concat(bi, " not in range for Number ") + "[".concat(Number.MAX_SAFE_INTEGER, ", ").concat(Number.MIN_SAFE_INTEGER, "]"));
                }
                return Number(bi);
            }
        },
        {
            key: "toBigInt",
            value: function toBigInt() {
                return this["int"].toBigInt();
            }
        },
        {
            key: "toI64",
            value: function toI64() {
                this._sizeCheck(64);
                var v = this.toBigInt();
                if (BigInt.asIntN(64, v) !== v) {
                    throw RangeError("value too large for i64: ".concat(v));
                }
                return _xdr["default"].ScVal.scvI64(new _xdr["default"].Int64(v));
            }
        },
        {
            key: "toU64",
            value: function toU64() {
                this._sizeCheck(64);
                return _xdr["default"].ScVal.scvU64(new _xdr["default"].Uint64(BigInt.asUintN(64, this.toBigInt())) // reiterpret as unsigned
                );
            }
        },
        {
            key: "toI128",
            value: function toI128() {
                this._sizeCheck(128);
                var v = this["int"].toBigInt();
                var hi64 = BigInt.asIntN(64, v >> 64n); // encode top 64 w/ sign bit
                var lo64 = BigInt.asUintN(64, v); // grab btm 64, encode sign
                return _xdr["default"].ScVal.scvI128(new _xdr["default"].Int128Parts({
                    hi: new _xdr["default"].Int64(hi64),
                    lo: new _xdr["default"].Uint64(lo64)
                }));
            }
        },
        {
            key: "toU128",
            value: function toU128() {
                this._sizeCheck(128);
                var v = this["int"].toBigInt();
                return _xdr["default"].ScVal.scvU128(new _xdr["default"].UInt128Parts({
                    hi: new _xdr["default"].Uint64(BigInt.asUintN(64, v >> 64n)),
                    lo: new _xdr["default"].Uint64(BigInt.asUintN(64, v))
                }));
            }
        },
        {
            key: "toI256",
            value: function toI256() {
                var v = this["int"].toBigInt();
                var hiHi64 = BigInt.asIntN(64, v >> 192n); // keep sign bit
                var hiLo64 = BigInt.asUintN(64, v >> 128n);
                var loHi64 = BigInt.asUintN(64, v >> 64n);
                var loLo64 = BigInt.asUintN(64, v);
                return _xdr["default"].ScVal.scvI256(new _xdr["default"].Int256Parts({
                    hiHi: new _xdr["default"].Int64(hiHi64),
                    hiLo: new _xdr["default"].Uint64(hiLo64),
                    loHi: new _xdr["default"].Uint64(loHi64),
                    loLo: new _xdr["default"].Uint64(loLo64)
                }));
            }
        },
        {
            key: "toU256",
            value: function toU256() {
                var v = this["int"].toBigInt();
                var hiHi64 = BigInt.asUintN(64, v >> 192n); // encode sign bit
                var hiLo64 = BigInt.asUintN(64, v >> 128n);
                var loHi64 = BigInt.asUintN(64, v >> 64n);
                var loLo64 = BigInt.asUintN(64, v);
                return _xdr["default"].ScVal.scvU256(new _xdr["default"].UInt256Parts({
                    hiHi: new _xdr["default"].Uint64(hiHi64),
                    hiLo: new _xdr["default"].Uint64(hiLo64),
                    loHi: new _xdr["default"].Uint64(loHi64),
                    loLo: new _xdr["default"].Uint64(loLo64)
                }));
            }
        },
        {
            key: "toScVal",
            value: function toScVal() {
                switch(this.type){
                    case 'i64':
                        return this.toI64();
                    case 'i128':
                        return this.toI128();
                    case 'i256':
                        return this.toI256();
                    case 'u64':
                        return this.toU64();
                    case 'u128':
                        return this.toU128();
                    case 'u256':
                        return this.toU256();
                    default:
                        throw TypeError("invalid type: ".concat(this.type));
                }
            }
        },
        {
            key: "valueOf",
            value: function valueOf() {
                return this["int"].valueOf();
            }
        },
        {
            key: "toString",
            value: function toString() {
                return this["int"].toString();
            }
        },
        {
            key: "toJSON",
            value: function toJSON() {
                return {
                    value: this.toBigInt().toString(),
                    type: this.type
                };
            }
        },
        {
            key: "_sizeCheck",
            value: function _sizeCheck(bits) {
                if (this["int"].size > bits) {
                    throw RangeError("value too large for ".concat(bits, " bits (").concat(this.type, ")"));
                }
            }
        }
    ], [
        {
            key: "isType",
            value: function isType(type) {
                switch(type){
                    case 'i64':
                    case 'i128':
                    case 'i256':
                    case 'u64':
                    case 'u128':
                    case 'u256':
                        return true;
                    default:
                        return false;
                }
            }
        },
        {
            key: "getType",
            value: function getType(scvType) {
                return scvType.slice(3).toLowerCase();
            }
        }
    ]);
}();
}}),
"[project]/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScInt = void 0;
var _xdr_large_int = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js [app-ssr] (ecmascript)");
function _defineProperties(e, r) {
    for(var t = 0; t < r.length; t++){
        var o = r[t];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
}
function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
}
function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
function _isNativeReflectConstruct() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
    })();
}
function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
}
function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(t, "prototype", {
        writable: !1
    }), e && _setPrototypeOf(t, e);
}
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
}
/**
 * Provides an easier way to manipulate large numbers for Stellar operations.
 *
 * You can instantiate this "**s**mart **c**ontract integer" value either from
 * bigints, strings, or numbers (whole numbers, or this will throw).
 *
 * If you need to create a native BigInt from a list of integer "parts" (for
 * example, you have a series of encoded 32-bit integers that represent a larger
 * value), you can use the lower level abstraction {@link XdrLargeInt}. For
 * example, you could do `new XdrLargeInt('u128', bytes...).toBigInt()`.
 *
 * @example
 * import { xdr, ScInt, scValToBigInt } from "@stellar/stellar-base";
 *
 * // You have an ScVal from a contract and want to parse it into JS native.
 * const value = xdr.ScVal.fromXDR(someXdr, "base64");
 * const bigi = scValToBigInt(value); // grab it as a BigInt
 * let sci = new ScInt(bigi);
 *
 * sci.toNumber(); // gives native JS type (w/ size check)
 * sci.toBigInt(); // gives the native BigInt value
 * sci.toU64();    // gives ScValType-specific XDR constructs (with size checks)
 *
 * // You have a number and want to shove it into a contract.
 * sci = ScInt(0xdeadcafebabe);
 * sci.toBigInt() // returns 244838016400062n
 * sci.toNumber() // throws: too large
 *
 * // Pass any to e.g. a Contract.call(), conversion happens automatically
 * // regardless of the initial type.
 * const scValU128 = sci.toU128();
 * const scValI256 = sci.toI256();
 * const scValU64  = sci.toU64();
 *
 * // Lots of ways to initialize:
 * ScInt("123456789123456789")
 * ScInt(123456789123456789n);
 * ScInt(1n << 140n);
 * ScInt(-42);
 * ScInt(scValToBigInt(scValU128)); // from above
 *
 * // If you know the type ahead of time (accessing `.raw` is faster than
 * // conversions), you can specify the type directly (otherwise, it's
 * // interpreted from the numbers you pass in):
 * const i = ScInt(123456789n, { type: "u256" });
 *
 * // For example, you can use the underlying `sdk.U256` and convert it to an
 * // `xdr.ScVal` directly like so:
 * const scv = new xdr.ScVal.scvU256(i.raw);
 *
 * // Or reinterpret it as a different type (size permitting):
 * const scv = i.toI64();
 *
 * @param {number|bigint|string} value - a single, integer-like value which will
 *    be interpreted in the smallest appropriate XDR type supported by Stellar
 *    (64, 128, or 256 bit integer values). signed values are supported, though
 *    they are sanity-checked against `opts.type`. if you need 32-bit values,
 *    you can construct them directly without needing this wrapper, e.g.
 *    `xdr.ScVal.scvU32(1234)`.
 *
 * @param {object}  [opts] - an optional object controlling optional parameters
 * @param {string}  [opts.type] - force a specific data type. the type choices
 *    are: 'i64', 'u64', 'i128', 'u128', 'i256', and 'u256' (default: the
 *    smallest one that fits the `value`)
 *
 * @throws {RangeError} if the `value` is invalid (e.g. floating point), too
 *    large (i.e. exceeds a 256-bit value), or doesn't fit in the `opts.type`
 * @throws {TypeError} on missing parameters, or if the "signedness" of `opts`
 *    doesn't match input `value`, e.g. passing `{type: 'u64'}` yet passing -1n
 * @throws {SyntaxError} if a string `value` can't be parsed as a big integer
 */ var ScInt = exports.ScInt = /*#__PURE__*/ function(_XdrLargeInt) {
    function ScInt(value, opts) {
        var _opts$type;
        _classCallCheck(this, ScInt);
        var signed = value < 0;
        var type = (_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : '';
        if (type.startsWith('u') && signed) {
            throw TypeError("specified type ".concat(opts.type, " yet negative (").concat(value, ")"));
        }
        // If unspecified, we make a best guess at the type based on the bit length
        // of the value, treating 64 as a minimum and 256 as a maximum.
        if (type === '') {
            type = signed ? 'i' : 'u';
            var bitlen = nearestBigIntSize(value);
            switch(bitlen){
                case 64:
                case 128:
                case 256:
                    type += bitlen.toString();
                    break;
                default:
                    throw RangeError("expected 64/128/256 bits for input (".concat(value, "), got ").concat(bitlen));
            }
        }
        return _callSuper(this, ScInt, [
            type,
            value
        ]);
    }
    _inherits(ScInt, _XdrLargeInt);
    return _createClass(ScInt);
}(_xdr_large_int.XdrLargeInt);
function nearestBigIntSize(bigI) {
    var _find;
    // Note: Even though BigInt.toString(2) includes the negative sign for
    // negative values (???), the following is still accurate, because the
    // negative sign would be represented by a sign bit.
    var bitlen = bigI.toString(2).length;
    return (_find = [
        64,
        128,
        256
    ].find(function(len) {
        return bitlen <= len;
    })) !== null && _find !== void 0 ? _find : bitlen;
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/numbers/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Int128", {
    enumerable: true,
    get: function get() {
        return _int.Int128;
    }
});
Object.defineProperty(exports, "Int256", {
    enumerable: true,
    get: function get() {
        return _int2.Int256;
    }
});
Object.defineProperty(exports, "ScInt", {
    enumerable: true,
    get: function get() {
        return _sc_int.ScInt;
    }
});
Object.defineProperty(exports, "Uint128", {
    enumerable: true,
    get: function get() {
        return _uint.Uint128;
    }
});
Object.defineProperty(exports, "Uint256", {
    enumerable: true,
    get: function get() {
        return _uint2.Uint256;
    }
});
Object.defineProperty(exports, "XdrLargeInt", {
    enumerable: true,
    get: function get() {
        return _xdr_large_int.XdrLargeInt;
    }
});
exports.scValToBigInt = scValToBigInt;
var _xdr_large_int = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js [app-ssr] (ecmascript)");
var _uint = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/uint128.js [app-ssr] (ecmascript)");
var _uint2 = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/uint256.js [app-ssr] (ecmascript)");
var _int = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/int128.js [app-ssr] (ecmascript)");
var _int2 = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/int256.js [app-ssr] (ecmascript)");
var _sc_int = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js [app-ssr] (ecmascript)");
/**
 * Transforms an opaque {@link xdr.ScVal} into a native bigint, if possible.
 *
 * If you then want to use this in the abstractions provided by this module,
 * you can pass it to the constructor of {@link XdrLargeInt}.
 *
 * @example
 * let scv = contract.call("add", x, y); // assume it returns an xdr.ScVal
 * let bigi = scValToBigInt(scv);
 *
 * new ScInt(bigi);               // if you don't care about types, and
 * new XdrLargeInt('i128', bigi); // if you do
 *
 * @param {xdr.ScVal} scv - the raw XDR value to parse into an integer
 * @returns {bigint} the native value of this input value
 *
 * @throws {TypeError} if the `scv` input value doesn't represent an integer
 */ function scValToBigInt(scv) {
    var scIntType = _xdr_large_int.XdrLargeInt.getType(scv["switch"]().name);
    switch(scv["switch"]().name){
        case 'scvU32':
        case 'scvI32':
            return BigInt(scv.value());
        case 'scvU64':
        case 'scvI64':
            return new _xdr_large_int.XdrLargeInt(scIntType, scv.value()).toBigInt();
        case 'scvU128':
        case 'scvI128':
            return new _xdr_large_int.XdrLargeInt(scIntType, [
                scv.value().lo(),
                scv.value().hi()
            ]).toBigInt();
        case 'scvU256':
        case 'scvI256':
            return new _xdr_large_int.XdrLargeInt(scIntType, [
                scv.value().loLo(),
                scv.value().loHi(),
                scv.value().hiLo(),
                scv.value().hiHi()
            ]).toBigInt();
        default:
            throw TypeError("expected integer type, got ".concat(scv["switch"]()));
    }
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/scval.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.nativeToScVal = nativeToScVal;
exports.scValToNative = scValToNative;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _address = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/address.js [app-ssr] (ecmascript)");
var _contract = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/contract.js [app-ssr] (ecmascript)");
var _index = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/index.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}
function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
        var e, n, i, u, a = [], f = !0, o = !1;
        try {
            if (i = (t = t.call(r)).next, 0 === l) {
                if (Object(t) !== t) return;
                f = !1;
            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
            o = !0, n = r;
        } finally{
            try {
                if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally{
                if (o) throw n;
            }
        }
        return a;
    }
}
function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
/**
 * Attempts to convert native types into smart contract values
 * ({@link xdr.ScVal}).
 *
 * Provides conversions from smart contract XDR values ({@link xdr.ScVal}) to
 * native JavaScript types.
 *
 * The conversions are as follows:
 *
 *  - xdr.ScVal -> passthrough
 *  - null/undefined -> scvVoid
 *  - string -> scvString (a copy is made)
 *  - UintArray8 -> scvBytes (a copy is made)
 *  - boolean -> scvBool
 *
 *  - number/bigint -> the smallest possible XDR integer type that will fit the
 *    input value (if you want a specific type, use {@link ScInt})
 *
 *  - {@link Address} or {@link Contract} -> scvAddress (for contracts and
 *    public keys)
 *
 *  - Array<T> -> scvVec after attempting to convert each item of type `T` to an
 *    xdr.ScVal (recursively). note that all values must be the same type!
 *
 *  - object -> scvMap after attempting to convert each key and value to an
 *    xdr.ScVal (recursively). note that there is no restriction on types
 *    matching anywhere (unlike arrays)
 *
 * When passing an integer-like native value, you can also optionally specify a
 * type which will force a particular interpretation of that value.
 *
 * Note that not all type specifications are compatible with all `ScVal`s, e.g.
 * `toScVal("a string", {type: "i256"})` will throw.
 *
 * @param {any} val -       a native (or convertible) input value to wrap
 * @param {object} [opts] - an optional set of hints around the type of
 *    conversion you'd like to see
 * @param {string} [opts.type] - there is different behavior for different input
 *    types for `val`:
 *
 *     - when `val` is an integer-like type (i.e. number|bigint), this will be
 *       forwarded to {@link ScInt} or forced to be u32/i32.
 *
 *     - when `val` is an array type, this is forwarded to the recursion
 *
 *     - when `val` is an object type (key-value entries), this should be an
 *       object in which each key has a pair of types (to represent forced types
 *       for the key and the value), where `null` (or a missing entry) indicates
 *       the default interpretation(s) (refer to the examples, below)
 *
 *     - when `val` is a string type, this can be 'string' or 'symbol' to force
 *       a particular interpretation of `val`.
 *
 *     - when `val` is a bytes-like type, this can be 'string', 'symbol', or
 *       'bytes' to force a particular interpretation
 *
 *    As a simple example, `nativeToScVal("hello", {type: 'symbol'})` will
 *    return an `scvSymbol`, whereas without the type it would have been an
 *    `scvString`.
 *
 * @returns {xdr.ScVal} a wrapped, smart, XDR version of the input value
 * @throws {TypeError} if...
 *  - there are arrays with more than one type in them
 *  - there are values that do not have a sensible conversion (e.g. random XDR
 *    types, custom classes)
 *  - the type of the input object (or some inner value of said object) cannot
 *    be determined (via `typeof`)
 *  - the type you specified (via `opts.type`) is incompatible with the value
 *    you passed in (`val`), e.g. `nativeToScVal("a string", { type: 'i128' })`,
 *    though this does not apply for types that ignore `opts` (e.g. addresses).
 * @see scValToNative
 *
 * @example
 * nativeToScVal(1000);                   // gives ScValType === scvU64
 * nativeToScVal(1000n);                  // gives ScValType === scvU64
 * nativeToScVal(1n << 100n);             // gives ScValType === scvU128
 * nativeToScVal(1000, { type: 'u32' });  // gives ScValType === scvU32
 * nativeToScVal(1000, { type: 'i125' }); // gives ScValType === scvI256
 * nativeToScVal("a string");                     // gives ScValType === scvString
 * nativeToScVal("a string", { type: 'symbol' }); // gives scvSymbol
 * nativeToScVal(new Uint8Array(5));                      // scvBytes
 * nativeToScVal(new Uint8Array(5), { type: 'symbol' });  // scvSymbol
 * nativeToScVal(null); // scvVoid
 * nativeToScVal(true); // scvBool
 * nativeToScVal([1, 2, 3]);                    // gives scvVec with each element as scvU64
 * nativeToScVal([1, 2, 3], { type: 'i128' });  // scvVec<scvI128>
 * nativeToScVal({ 'hello': 1, 'world': [ true, false ] }, {
 *   type: {
 *     'hello': [ 'symbol', 'i128' ],
 *   }
 * })
 * // gives scvMap with entries: [
 * //     [ scvSymbol, scvI128 ],
 * //     [ scvString, scvArray<scvBool> ]
 * // ]
 *
 * @example
 * import {
 *   nativeToScVal,
 *   scValToNative,
 *   ScInt,
 *   xdr
 * } from '@stellar/stellar-base';
 *
 * let gigaMap = {
 *   bool: true,
 *   void: null,
 *   u32: xdr.ScVal.scvU32(1),
 *   i32: xdr.ScVal.scvI32(1),
 *   u64: 1n,
 *   i64: -1n,
 *   u128: new ScInt(1).toU128(),
 *   i128: new ScInt(1).toI128(),
 *   u256: new ScInt(1).toU256(),
 *   i256: new ScInt(1).toI256(),
 *   map: {
 *     arbitrary: 1n,
 *     nested: 'values',
 *     etc: false
 *   },
 *   vec: ['same', 'type', 'list'],
 * };
 *
 * // then, simply:
 * let scv = nativeToScVal(gigaMap);    // scv.switch() == xdr.ScValType.scvMap()
 *
 * // then...
 * someContract.call("method", scv);
 *
 * // Similarly, the inverse should work:
 * scValToNative(scv) == gigaMap;       // true
 */ function nativeToScVal(val) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    switch(_typeof(val)){
        case 'object':
            {
                var _val$constructor$name, _val$constructor;
                if (val === null) {
                    return _xdr["default"].ScVal.scvVoid();
                }
                if (val instanceof _xdr["default"].ScVal) {
                    return val; // should we copy?
                }
                if (val instanceof _address.Address) {
                    return val.toScVal();
                }
                if (val instanceof _keypair.Keypair) {
                    return nativeToScVal(val.publicKey(), {
                        type: 'address'
                    });
                }
                if (val instanceof _contract.Contract) {
                    return val.address().toScVal();
                }
                if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
                    var _opts$type;
                    var copy = Uint8Array.from(val);
                    switch((_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : 'bytes'){
                        case 'bytes':
                            return _xdr["default"].ScVal.scvBytes(copy);
                        case 'symbol':
                            return _xdr["default"].ScVal.scvSymbol(copy);
                        case 'string':
                            return _xdr["default"].ScVal.scvString(copy);
                        default:
                            throw new TypeError("invalid type (".concat(opts.type, ") specified for bytes-like value"));
                    }
                }
                if (Array.isArray(val)) {
                    return _xdr["default"].ScVal.scvVec(val.map(function(v) {
                        return nativeToScVal(v, opts);
                    }));
                }
                if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : '') !== 'Object') {
                    var _val$constructor2;
                    throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
                }
                return _xdr["default"].ScVal.scvMap(Object.entries(val)// The Soroban runtime expects maps to have their keys in sorted
                // order, so let's do that here as part of the conversion to prevent
                // confusing error messages on execution.
                .sort(function(_ref, _ref2) {
                    var _ref3 = _slicedToArray(_ref, 1), key1 = _ref3[0];
                    var _ref4 = _slicedToArray(_ref2, 1), key2 = _ref4[0];
                    return key1.localeCompare(key2);
                }).map(function(_ref5) {
                    var _k, _opts$type2;
                    var _ref6 = _slicedToArray(_ref5, 2), k = _ref6[0], v = _ref6[1];
                    // the type can be specified with an entry for the key and the value,
                    // e.g. val = { 'hello': 1 } and opts.type = { hello: [ 'symbol',
                    // 'u128' ]} or you can use `null` for the default interpretation
                    var _ref7 = (_k = ((_opts$type2 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type2 !== void 0 ? _opts$type2 : {})[k]) !== null && _k !== void 0 ? _k : [
                        null,
                        null
                    ], _ref8 = _slicedToArray(_ref7, 2), keyType = _ref8[0], valType = _ref8[1];
                    var keyOpts = keyType ? {
                        type: keyType
                    } : {};
                    var valOpts = valType ? {
                        type: valType
                    } : {};
                    return new _xdr["default"].ScMapEntry({
                        key: nativeToScVal(k, keyOpts),
                        val: nativeToScVal(v, valOpts)
                    });
                }));
            }
        case 'number':
        case 'bigint':
            switch(opts === null || opts === void 0 ? void 0 : opts.type){
                case 'u32':
                    return _xdr["default"].ScVal.scvU32(val);
                case 'i32':
                    return _xdr["default"].ScVal.scvI32(val);
                default:
                    break;
            }
            return new _index.ScInt(val, {
                type: opts === null || opts === void 0 ? void 0 : opts.type
            }).toScVal();
        case 'string':
            {
                var _opts$type3;
                var optType = (_opts$type3 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type3 !== void 0 ? _opts$type3 : 'string';
                switch(optType){
                    case 'string':
                        return _xdr["default"].ScVal.scvString(val);
                    case 'symbol':
                        return _xdr["default"].ScVal.scvSymbol(val);
                    case 'address':
                        return new _address.Address(val).toScVal();
                    case 'u32':
                        return _xdr["default"].ScVal.scvU32(parseInt(val, 10));
                    case 'i32':
                        return _xdr["default"].ScVal.scvI32(parseInt(val, 10));
                    default:
                        if (_index.XdrLargeInt.isType(optType)) {
                            return new _index.XdrLargeInt(optType, val).toScVal();
                        }
                        throw new TypeError("invalid type (".concat(opts.type, ") specified for string value"));
                }
            }
        case 'boolean':
            return _xdr["default"].ScVal.scvBool(val);
        case 'undefined':
            return _xdr["default"].ScVal.scvVoid();
        case 'function':
            // FIXME: Is this too helpful?
            return nativeToScVal(val());
        default:
            throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
    }
}
/**
 * Given a smart contract value, attempt to convert it to a native type.
 * Possible conversions include:
 *
 *  - void -> `null`
 *  - u32, i32 -> `number`
 *  - u64, i64, u128, i128, u256, i256 -> `bigint`
 *  - vec -> `Array` of any of the above (via recursion)
 *  - map -> key-value object of any of the above (via recursion)
 *  - bool -> `boolean`
 *  - bytes -> `Uint8Array`
 *  - symbol -> `string`
 *  - string -> `string` IF the underlying buffer can be decoded as ascii/utf8,
 *              `Uint8Array` of the raw contents in any error case
 *
 * If no viable conversion can be determined, this just "unwraps" the smart
 * value to return its underlying XDR value.
 *
 * @param {xdr.ScVal} scv - the input smart contract value
 *
 * @returns {any}
 * @see nativeToScVal
 */ function scValToNative(scv) {
    var _scv$vec, _scv$map;
    // we use the verbose xdr.ScValType.<type>.value form here because it's faster
    // than string comparisons and the underlying constants never need to be
    // updated
    switch(scv["switch"]().value){
        case _xdr["default"].ScValType.scvVoid().value:
            return null;
        // these can be converted to bigints directly
        case _xdr["default"].ScValType.scvU64().value:
        case _xdr["default"].ScValType.scvI64().value:
            return scv.value().toBigInt();
        // these can be parsed by internal abstractions note that this can also
        // handle the above two cases, but it's not as efficient (another
        // type-check, parsing, etc.)
        case _xdr["default"].ScValType.scvU128().value:
        case _xdr["default"].ScValType.scvI128().value:
        case _xdr["default"].ScValType.scvU256().value:
        case _xdr["default"].ScValType.scvI256().value:
            return (0, _index.scValToBigInt)(scv);
        case _xdr["default"].ScValType.scvVec().value:
            return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(scValToNative);
        case _xdr["default"].ScValType.scvAddress().value:
            return _address.Address.fromScVal(scv).toString();
        case _xdr["default"].ScValType.scvMap().value:
            return Object.fromEntries(((_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : []).map(function(entry) {
                return [
                    scValToNative(entry.key()),
                    scValToNative(entry.val())
                ];
            }));
        // these return the primitive type directly
        case _xdr["default"].ScValType.scvBool().value:
        case _xdr["default"].ScValType.scvU32().value:
        case _xdr["default"].ScValType.scvI32().value:
        case _xdr["default"].ScValType.scvBytes().value:
            return scv.value();
        // Symbols are limited to [a-zA-Z0-9_]+, so we can safely make ascii strings
        //
        // Strings, however, are "presented" as strings and we treat them as such
        // (in other words, string = bytes with a hint that it's text). If the user
        // encoded non-printable bytes in their string value, that's on them.
        //
        // Note that we assume a utf8 encoding (ascii-compatible). For other
        // encodings, you should probably use bytes anyway. If it cannot be decoded,
        // the raw bytes are returned.
        case _xdr["default"].ScValType.scvSymbol().value:
        case _xdr["default"].ScValType.scvString().value:
            {
                var v = scv.value(); // string|Buffer
                if (Buffer.isBuffer(v) || ArrayBuffer.isView(v)) {
                    try {
                        return new TextDecoder().decode(v);
                    } catch (e) {
                        return new Uint8Array(v.buffer); // copy of bytes
                    }
                }
                return v; // string already
            }
        // these can be converted to bigint
        case _xdr["default"].ScValType.scvTimepoint().value:
        case _xdr["default"].ScValType.scvDuration().value:
            return new _xdr["default"].Uint64(scv.value()).toBigInt();
        case _xdr["default"].ScValType.scvError().value:
            switch(scv.error()["switch"]().value){
                // Distinguish errors from the user contract.
                case _xdr["default"].ScErrorType.sceContract().value:
                    return {
                        type: 'contract',
                        code: scv.error().contractCode()
                    };
                default:
                    {
                        var err = scv.error();
                        return {
                            type: 'system',
                            code: err.code().value,
                            value: err.code().name
                        };
                    }
            }
        // in the fallthrough case, just return the underlying value directly
        default:
            return scv.value();
    }
}
/// Inject a sortable map builder into the xdr module.
_xdr["default"].scvSortedMap = function(items) {
    var sorted = Array.from(items).sort(function(a, b) {
        // Both a and b are `ScMapEntry`s, so we need to sort by underlying key.
        //
        // We couldn't possibly handle every combination of keys since Soroban
        // maps don't enforce consistent types, so we do a best-effort and try
        // sorting by "number-like" or "string-like."
        var nativeA = scValToNative(a.key());
        var nativeB = scValToNative(b.key());
        switch(_typeof(nativeA)){
            case 'number':
            case 'bigint':
                return nativeA < nativeB ? -1 : 1;
            default:
                return nativeA.toString().localeCompare(nativeB.toString());
        }
    });
    return _xdr["default"].ScVal.scvMap(sorted);
};
}}),
"[project]/node_modules/@stellar/stellar-base/lib/events.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.humanizeEvents = humanizeEvents;
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _scval = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/scval.js [app-ssr] (ecmascript)");
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * Converts raw diagnostic or contract events into something with a flatter,
 * human-readable, and understandable structure.
 *
 * @param {xdr.DiagnosticEvent[] | xdr.ContractEvent[]} events  either contract
 *    events or diagnostic events to parse into a friendly format
 *
 * @returns {SorobanEvent[]}  a list of human-readable event structures, where
 *    each element has the following properties:
 *  - type: a string of one of 'system', 'contract', 'diagnostic
 *  - contractId?: optionally, a `C...` encoded strkey
 *  - topics: a list of {@link scValToNative} invocations on the topics
 *  - data: similarly, a {@link scValToNative} invocation on the raw event data
 */ function humanizeEvents(events) {
    return events.map(function(e) {
        // A pseudo-instanceof check for xdr.DiagnosticEvent more reliable
        // in mixed SDK environments:
        if (e.inSuccessfulContractCall) {
            return extractEvent(e.event());
        }
        return extractEvent(e);
    });
}
function extractEvent(event) {
    return _objectSpread(_objectSpread({}, typeof event.contractId === 'function' && event.contractId() != null && {
        contractId: _strkey.StrKey.encodeContract(event.contractId())
    }), {}, {
        type: event.type().name,
        topics: event.body().value().topics().map(function(t) {
            return (0, _scval.scValToNative)(t);
        }),
        data: (0, _scval.scValToNative)(event.body().value().data())
    });
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/auth.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.authorizeEntry = authorizeEntry;
exports.authorizeInvocation = authorizeInvocation;
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _network = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/network.js [app-ssr] (ecmascript)");
var _hashing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/hashing.js [app-ssr] (ecmascript)");
var _address = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/address.js [app-ssr] (ecmascript)");
var _scval = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/scval.js [app-ssr] (ecmascript)");
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function _regeneratorRuntime() {
    "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ 
    _regeneratorRuntime = function _regeneratorRuntime() {
        return e;
    };
    var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t, e, r) {
        t[e] = r.value;
    }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
        return Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }), t[e];
    }
    try {
        define({}, "");
    } catch (t) {
        define = function define(t, e, r) {
            return t[e] = r;
        };
    }
    function wrap(t, e, r, n) {
        var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []);
        return o(a, "_invoke", {
            value: makeInvokeMethod(t, r, c)
        }), a;
    }
    function tryCatch(t, e, r) {
        try {
            return {
                type: "normal",
                arg: t.call(e, r)
            };
        } catch (t) {
            return {
                type: "throw",
                arg: t
            };
        }
    }
    e.wrap = wrap;
    var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function() {
        return this;
    });
    var d = Object.getPrototypeOf, v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
        [
            "next",
            "throw",
            "return"
        ].forEach(function(e) {
            define(t, e, function(t) {
                return this._invoke(e, t);
            });
        });
    }
    function AsyncIterator(t, e) {
        function invoke(r, o, i, a) {
            var c = tryCatch(t[r], t, o);
            if ("throw" !== c.type) {
                var u = c.arg, h = u.value;
                return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function(t) {
                    invoke("next", t, i, a);
                }, function(t) {
                    invoke("throw", t, i, a);
                }) : e.resolve(h).then(function(t) {
                    u.value = t, i(u);
                }, function(t) {
                    return invoke("throw", t, i, a);
                });
            }
            a(c.arg);
        }
        var r;
        o(this, "_invoke", {
            value: function value(t, n) {
                function callInvokeWithMethodAndArg() {
                    return new e(function(e, r) {
                        invoke(t, n, e, r);
                    });
                }
                return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }
        });
    }
    function makeInvokeMethod(e, r, n) {
        var o = h;
        return function(i, a) {
            if (o === f) throw Error("Generator is already running");
            if (o === s) {
                if ("throw" === i) throw a;
                return {
                    value: t,
                    done: !0
                };
            }
            for(n.method = i, n.arg = a;;){
                var c = n.delegate;
                if (c) {
                    var u = maybeInvokeDelegate(c, n);
                    if (u) {
                        if (u === y) continue;
                        return u;
                    }
                }
                if ("next" === n.method) n.sent = n._sent = n.arg;
                else if ("throw" === n.method) {
                    if (o === h) throw o = s, n.arg;
                    n.dispatchException(n.arg);
                } else "return" === n.method && n.abrupt("return", n.arg);
                o = f;
                var p = tryCatch(e, r, n);
                if ("normal" === p.type) {
                    if (o = n.done ? s : l, p.arg === y) continue;
                    return {
                        value: p.arg,
                        done: n.done
                    };
                }
                "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
            }
        };
    }
    function maybeInvokeDelegate(e, r) {
        var n = r.method, o = e.iterator[n];
        if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
        var i = tryCatch(o, e.iterator, r.arg);
        if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
        var a = i.arg;
        return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
        var e = {
            tryLoc: t[0]
        };
        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
        var e = t.completion || {};
        e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
        this.tryEntries = [
            {
                tryLoc: "root"
            }
        ], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
        if (e || "" === e) {
            var r = e[a];
            if (r) return r.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
                var o = -1, i = function next() {
                    for(; ++o < e.length;)if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
                    return next.value = t, next.done = !0, next;
                };
                return i.next = i;
            }
        }
        throw new TypeError(_typeof(e) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t) {
        var e = "function" == typeof t && t.constructor;
        return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function(t) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function(t) {
        return {
            __await: t
        };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function(t, r, n, o, i) {
        void 0 === i && (i = Promise);
        var a = new AsyncIterator(wrap(t, r, n, o), i);
        return e.isGeneratorFunction(r) ? a : a.next().then(function(t) {
            return t.done ? t.value : a.next();
        });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
    }), define(g, "toString", function() {
        return "[object Generator]";
    }), e.keys = function(t) {
        var e = Object(t), r = [];
        for(var n in e)r.push(n);
        return r.reverse(), function next() {
            for(; r.length;){
                var t = r.pop();
                if (t in e) return next.value = t, next.done = !1, next;
            }
            return next.done = !0, next;
        };
    }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for(var r in this)"t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
        },
        stop: function stop() {
            this.done = !0;
            var t = this.tryEntries[0].completion;
            if ("throw" === t.type) throw t.arg;
            return this.rval;
        },
        dispatchException: function dispatchException(e) {
            if (this.done) throw e;
            var r = this;
            function handle(n, o) {
                return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
            }
            for(var o = this.tryEntries.length - 1; o >= 0; --o){
                var i = this.tryEntries[o], a = i.completion;
                if ("root" === i.tryLoc) return handle("end");
                if (i.tryLoc <= this.prev) {
                    var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc");
                    if (c && u) {
                        if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                        if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                    } else if (c) {
                        if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                    } else {
                        if (!u) throw Error("try statement without catch or finally");
                        if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                    }
                }
            }
        },
        abrupt: function abrupt(t, e) {
            for(var r = this.tryEntries.length - 1; r >= 0; --r){
                var o = this.tryEntries[r];
                if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
                    var i = o;
                    break;
                }
            }
            i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
            var a = i ? i.completion : {};
            return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
        },
        complete: function complete(t, e) {
            if ("throw" === t.type) throw t.arg;
            return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
        },
        finish: function finish(t) {
            for(var e = this.tryEntries.length - 1; e >= 0; --e){
                var r = this.tryEntries[e];
                if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
            }
        },
        "catch": function _catch(t) {
            for(var e = this.tryEntries.length - 1; e >= 0; --e){
                var r = this.tryEntries[e];
                if (r.tryLoc === t) {
                    var n = r.completion;
                    if ("throw" === n.type) {
                        var o = n.arg;
                        resetTryEntry(r);
                    }
                    return o;
                }
            }
            throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e, r, n) {
            return this.delegate = {
                iterator: values(e),
                resultName: r,
                nextLoc: n
            }, "next" === this.method && (this.arg = t), y;
        }
    }, e;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n) {
        return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n) {
                asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
            }
            function _throw(n) {
                asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
            }
            _next(void 0);
        });
    };
}
/**
 * @async
 * @callback SigningCallback A callback for signing an XDR structure
 * representing all of the details necessary to authorize an invocation tree.
 *
 * @param {xdr.HashIdPreimage} preimage   the entire authorization envelope
 *    whose hash you should sign, so that you can inspect the entire structure
 *    if necessary (rather than blindly signing a hash)
 *
 * @returns {
 *    Promise<Uint8Array> |
 *    Promise<{signature: Uint8Array, publicKey: string}
 * }  the signature of the raw payload (which is the sha256 hash of the preimage
 *    bytes, so `hash(preimage.toXDR())`) either naked, implying it is signed
 *    by the key corresponding to the public key in the entry you pass to
 *    {@link authorizeEntry} (decipherable from its
 *    `credentials().address().address()`), or alongside an explicit `publicKey`.
 */ /**
 * Actually authorizes an existing authorization entry using the given the
 * credentials and expiration details, returning a signed copy.
 *
 * This "fills out" the authorization entry with a signature, indicating to the
 * {@link Operation.invokeHostFunction} its attached to that:
 *   - a particular identity (i.e. signing {@link Keypair} or other signer)
 *   - approving the execution of an invocation tree (i.e. a simulation-acquired
 *     {@link xdr.SorobanAuthorizedInvocation} or otherwise built)
 *   - on a particular network (uniquely identified by its passphrase, see
 *     {@link Networks})
 *   - until a particular ledger sequence is reached.
 *
 * This one lets you pass a either a {@link Keypair} (or, more accurately,
 * anything with a `sign(Buffer): Buffer` method) or a callback function (see
 * {@link SigningCallback}) to handle signing the envelope hash.
 *
 * @param {xdr.SorobanAuthorizationEntry} entry   an unsigned authorization entr
 * @param {Keypair | SigningCallback} signer  either a {@link Keypair} instance
 *    or a function which takes a {@link xdr.HashIdPreimageSorobanAuthorization}
 *    input payload and returns EITHER
 *
 *      (a) an object containing a `signature` of the hash of the raw payload bytes
 *          as a Buffer-like and a `publicKey` string representing who just
 *          created this signature, or
 *      (b) just the naked signature of the hash of the raw payload bytes (where
 *          the signing key is implied to be the address in the `entry`).
 *
 *    The latter option (b) is JUST for backwards compatibility and will be
 *    removed in the future.
 * @param {number} validUntilLedgerSeq   the (exclusive) future ledger sequence
 *    number until which this authorization entry should be valid (if
 *    `currentLedgerSeq==validUntil`, this is expired))
 * @param {string} [networkPassphrase]  the network passphrase is incorprated
 *    into the signature (see {@link Networks} for options)
 *
 * @returns {Promise<xdr.SorobanAuthorizationEntry>} a promise for an
 *    authorization entry that you can pass along to
 *    {@link Operation.invokeHostFunction}
 *
 * @note If using the `SigningCallback` variation, the signer is assumed to be
 *    the entry's credential address unless you use the variant that returns
 *    the object.
 *
 * @see authorizeInvocation
 * @example
 * import {
 *   SorobanRpc,
 *   Transaction,
 *   Networks,
 *   authorizeEntry
 * } from '@stellar/stellar-sdk';
 *
 * // Assume signPayloadCallback is a well-formed signing callback.
 * //
 * // It might, for example, pop up a modal from a browser extension, send the
 * // transaction to a third-party service for signing, or just do simple
 * // signing via Keypair like it does here:
 * function signPayloadCallback(payload) {
 *    return signer.sign(hash(payload.toXDR());
 * }
 *
 * function multiPartyAuth(
 *    server: SorobanRpc.Server,
 *    // assume this involves multi-party auth
 *    tx: Transaction,
 * ) {
 *    return server
 *      .simulateTransaction(tx)
 *      .then((simResult) => {
 *          tx.operations[0].auth.map(entry =>
 *            authorizeEntry(
 *              entry,
 *              signPayloadCallback,
 *              currentLedger + 1000,
 *              Networks.TESTNET);
 *          ));
 *
 *          return server.prepareTransaction(tx, simResult);
 *      })
 *      .then((preppedTx) => {
 *        preppedTx.sign(source);
 *        return server.sendTransaction(preppedTx);
 *      });
 * }
 */ function authorizeEntry(_x, _x2, _x3) {
    return _authorizeEntry.apply(this, arguments);
}
/**
 * This builds an entry from scratch, allowing you to express authorization as a
 * function of:
 *   - a particular identity (i.e. signing {@link Keypair} or other signer)
 *   - approving the execution of an invocation tree (i.e. a simulation-acquired
 *     {@link xdr.SorobanAuthorizedInvocation} or otherwise built)
 *   - on a particular network (uniquely identified by its passphrase, see
 *     {@link Networks})
 *   - until a particular ledger sequence is reached.
 *
 * This is in contrast to {@link authorizeEntry}, which signs an existing entry.
 *
 * @param {Keypair | SigningCallback} signer  either a {@link Keypair} instance
 *    (or anything with a `.sign(buf): Buffer-like` method) or a function which
 *    takes a payload (a {@link xdr.HashIdPreimageSorobanAuthorization}
 *    instance) input and returns the signature of the hash of the raw payload
 *    bytes (where the signing key should correspond to the address in the
 *    `entry`)
 * @param {number}  validUntilLedgerSeq  the (exclusive) future ledger sequence
 *    number until which this authorization entry should be valid (if
 *    `currentLedgerSeq==validUntilLedgerSeq`, this is expired))
 * @param {xdr.SorobanAuthorizedInvocation} invocation the invocation tree that
 *    we're authorizing (likely, this comes from transaction simulation)
 * @param {string}  [publicKey]   the public identity of the signer (when
 *    providing a {@link Keypair} to `signer`, this can be omitted, as it just
 *    uses {@link Keypair.publicKey})
 * @param {string}  [networkPassphrase]   the network passphrase is incorprated
 *    into the signature (see {@link Networks} for options, default:
 *    {@link Networks.FUTURENET})
 *
 * @returns {Promise<xdr.SorobanAuthorizationEntry>} a promise for an
 *    authorization entry that you can pass along to
 *    {@link Operation.invokeHostFunction}
 *
 * @see authorizeEntry
 */ function _authorizeEntry() {
    _authorizeEntry = _asyncToGenerator(/*#__PURE__*/ _regeneratorRuntime().mark(function _callee(entry, signer, validUntilLedgerSeq) {
        var networkPassphrase, clone, addrAuth, networkId, preimage, payload, signature, publicKey, sigResult, sigScVal, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
            while(1)switch(_context.prev = _context.next){
                case 0:
                    networkPassphrase = _args.length > 3 && _args[3] !== undefined ? _args[3] : _network.Networks.FUTURENET;
                    if (!(entry.credentials()["switch"]().value !== _xdr["default"].SorobanCredentialsType.sorobanCredentialsAddress().value)) {
                        _context.next = 3;
                        break;
                    }
                    return _context.abrupt("return", entry);
                case 3:
                    clone = _xdr["default"].SorobanAuthorizationEntry.fromXDR(entry.toXDR());
                    /** @type {xdr.SorobanAddressCredentials} */ addrAuth = clone.credentials().address();
                    addrAuth.signatureExpirationLedger(validUntilLedgerSeq);
                    networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
                    preimage = _xdr["default"].HashIdPreimage.envelopeTypeSorobanAuthorization(new _xdr["default"].HashIdPreimageSorobanAuthorization({
                        networkId: networkId,
                        nonce: addrAuth.nonce(),
                        invocation: clone.rootInvocation(),
                        signatureExpirationLedger: addrAuth.signatureExpirationLedger()
                    }));
                    payload = (0, _hashing.hash)(preimage.toXDR());
                    if (!(typeof signer === 'function')) {
                        _context.next = 16;
                        break;
                    }
                    _context.next = 12;
                    return signer(preimage);
                case 12:
                    sigResult = _context.sent;
                    if (sigResult !== null && sigResult !== void 0 && sigResult.signature) {
                        signature = Buffer.from(sigResult.signature);
                        publicKey = sigResult.publicKey;
                    } else {
                        // if using the deprecated form, assume it's for the entry
                        signature = Buffer.from(sigResult);
                        publicKey = _address.Address.fromScAddress(addrAuth.address()).toString();
                    }
                    _context.next = 18;
                    break;
                case 16:
                    signature = Buffer.from(signer.sign(payload));
                    publicKey = signer.publicKey();
                case 18:
                    if (_keypair.Keypair.fromPublicKey(publicKey).verify(payload, signature)) {
                        _context.next = 20;
                        break;
                    }
                    throw new Error("signature doesn't match payload");
                case 20:
                    // This structure is defined here:
                    // https://soroban.stellar.org/docs/fundamentals-and-concepts/invoking-contracts-with-transactions#stellar-account-signatures
                    //
                    // Encoding a contract structure as an ScVal means the map keys are supposed
                    // to be symbols, hence the forced typing here.
                    sigScVal = (0, _scval.nativeToScVal)({
                        public_key: _strkey.StrKey.decodeEd25519PublicKey(publicKey),
                        signature: signature
                    }, {
                        type: {
                            public_key: [
                                'symbol',
                                null
                            ],
                            signature: [
                                'symbol',
                                null
                            ]
                        }
                    });
                    addrAuth.signature(_xdr["default"].ScVal.scvVec([
                        sigScVal
                    ]));
                    return _context.abrupt("return", clone);
                case 23:
                case "end":
                    return _context.stop();
            }
        }, _callee);
    }));
    return _authorizeEntry.apply(this, arguments);
}
function authorizeInvocation(signer, validUntilLedgerSeq, invocation) {
    var publicKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var networkPassphrase = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _network.Networks.FUTURENET;
    // We use keypairs as a source of randomness for the nonce to avoid mucking
    // with any crypto dependencies. Note that this just has to be random and
    // unique, not cryptographically secure, so it's fine.
    var kp = _keypair.Keypair.random().rawPublicKey();
    var nonce = new _xdr["default"].Int64(bytesToInt64(kp));
    var pk = publicKey || signer.publicKey();
    if (!pk) {
        throw new Error("authorizeInvocation requires publicKey parameter");
    }
    var entry = new _xdr["default"].SorobanAuthorizationEntry({
        rootInvocation: invocation,
        credentials: _xdr["default"].SorobanCredentials.sorobanCredentialsAddress(new _xdr["default"].SorobanAddressCredentials({
            address: new _address.Address(pk).toScAddress(),
            nonce: nonce,
            signatureExpirationLedger: 0,
            // replaced
            signature: _xdr["default"].ScVal.scvVec([]) // replaced
        }))
    });
    return authorizeEntry(entry, signer, validUntilLedgerSeq, networkPassphrase);
}
function bytesToInt64(bytes) {
    // eslint-disable-next-line no-bitwise
    return bytes.subarray(0, 8).reduce(function(accum, b) {
        return accum << 8 | b;
    }, 0);
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/invocation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildInvocationTree = buildInvocationTree;
exports.walkInvocationTree = walkInvocationTree;
var _asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)");
var _address = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/address.js [app-ssr] (ecmascript)");
var _scval = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/scval.js [app-ssr] (ecmascript)");
function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/**
 * @typedef CreateInvocation
 *
 * @prop {'wasm'|'sac'} type  a type indicating if this creation was a custom
 *    contract or a wrapping of an existing Stellar asset
 * @prop {string} [token] when `type=='sac'`, the canonical {@link Asset} that
 *    is being wrapped by this Stellar Asset Contract
 * @prop {object} [wasm]  when `type=='wasm'`, add'l creation parameters
 *
 * @prop {string} wasm.hash     hex hash of WASM bytecode backing this contract
 * @prop {string} wasm.address  contract address of this deployment
 * @prop {string} wasm.salt     hex salt that the user consumed when creating
 *    this contract (encoded in the resulting address)
 * @prop {any[]}  [wasm.constructorArgs] a list of natively-represented values
 *    (see {@link scValToNative}) that are passed to the constructor when
 *    creating this contract
 */ /**
 * @typedef ExecuteInvocation
 *
 * @prop {string} source    the strkey of the contract (C...) being invoked
 * @prop {string} function  the name of the function being invoked
 * @prop {any[]}  args      the natively-represented parameters to the function
 *    invocation (see {@link scValToNative} for rules on how they're
 *    represented a JS types)
 */ /**
 * @typedef InvocationTree
 * @prop {'execute' | 'create'} type  the type of invocation occurring, either
 *    contract creation or host function execution
 * @prop {CreateInvocation | ExecuteInvocation} args  the parameters to the
 *    invocation, depending on the type
 * @prop {InvocationTree[]} invocations   any sub-invocations that (may) occur
 *    as a result of this invocation (i.e. a tree of call stacks)
 */ /**
 * Turns a raw invocation tree into a human-readable format.
 *
 * This is designed to make the invocation tree easier to understand in order to
 * inform users about the side-effects of their contract calls. This will help
 * make informed decisions about whether or not a particular invocation will
 * result in what you expect it to.
 *
 * @param {xdr.SorobanAuthorizedInvocation} root  the raw XDR of the invocation,
 *    likely acquired from transaction simulation. this is either from the
 *    {@link Operation.invokeHostFunction} itself (the `func` field), or from
 *    the authorization entries ({@link xdr.SorobanAuthorizationEntry}, the
 *    `rootInvocation` field)
 *
 * @returns {InvocationTree}  a human-readable version of the invocation tree
 *
 * @example
 * Here, we show a browser modal after simulating an arbitrary transaction,
 * `tx`, which we assume has an `Operation.invokeHostFunction` inside of it:
 *
 * ```typescript
 * import { Server, buildInvocationTree } from '@stellar/stellar-sdk';
 *
 * const s = new Server("fill in accordingly");
 *
 * s.simulateTransaction(tx).then(
 *  (resp: SorobanRpc.SimulateTransactionResponse) => {
 *    if (SorobanRpc.isSuccessfulSim(resp) && ) {
 *      // bold assumption: there's a valid result with an auth entry
 *      alert(
 *        "You are authorizing the following invocation:\n" +
 *        JSON.stringify(
 *          buildInvocationTree(resp.result!.auth[0].rootInvocation()),
 *          null,
 *          2
 *        )
 *      );
 *    }
 *  }
 * );
 * ```
 */ function buildInvocationTree(root) {
    var fn = root["function"]();
    /** @type {InvocationTree} */ var output = {};
    /** @type {xdr.CreateContractArgs|xdr.CreateContractArgsV2|xdr.InvokeContractArgs} */ var inner = fn.value();
    switch(fn["switch"]().value){
        // sorobanAuthorizedFunctionTypeContractFn
        case 0:
            output.type = 'execute';
            output.args = {
                source: _address.Address.fromScAddress(inner.contractAddress()).toString(),
                "function": inner.functionName(),
                args: inner.args().map(function(arg) {
                    return (0, _scval.scValToNative)(arg);
                })
            };
            break;
        // sorobanAuthorizedFunctionTypeCreateContractHostFn
        // sorobanAuthorizedFunctionTypeCreateContractV2HostFn
        case 1:
        case 2:
            {
                var createV2 = fn["switch"]().value === 2;
                output.type = 'create';
                output.args = {};
                // If the executable is a WASM, the preimage MUST be an address. If it's a
                // token, the preimage MUST be an asset. This is a cheeky way to check
                // that, because wasm=0, token=1 and address=0, asset=1 in the XDR switch
                // values.
                //
                // The first part may not be true in V2, but we'd need to update this code
                // anyway so it can still be an error.
                var _ref = [
                    inner.executable(),
                    inner.contractIdPreimage()
                ], exec = _ref[0], preimage = _ref[1];
                if (!!exec["switch"]().value !== !!preimage["switch"]().value) {
                    throw new Error("creation function appears invalid: ".concat(JSON.stringify(inner), " (should be wasm+address or token+asset)"));
                }
                switch(exec["switch"]().value){
                    // contractExecutableWasm
                    case 0:
                        {
                            /** @type {xdr.ContractIdPreimageFromAddress} */ var details = preimage.fromAddress();
                            output.args.type = 'wasm';
                            output.args.wasm = _objectSpread({
                                salt: details.salt().toString('hex'),
                                hash: exec.wasmHash().toString('hex'),
                                address: _address.Address.fromScAddress(details.address()).toString()
                            }, createV2 && {
                                constructorArgs: inner.constructorArgs().map(function(arg) {
                                    return (0, _scval.scValToNative)(arg);
                                })
                            });
                            break;
                        }
                    // contractExecutableStellarAsset
                    case 1:
                        output.args.type = 'sac';
                        output.args.asset = _asset.Asset.fromOperation(preimage.fromAsset()).toString();
                        break;
                    default:
                        throw new Error("unknown creation type: ".concat(JSON.stringify(exec)));
                }
                break;
            }
        default:
            throw new Error("unknown invocation type (".concat(fn["switch"](), "): ").concat(JSON.stringify(fn)));
    }
    output.invocations = root.subInvocations().map(function(i) {
        return buildInvocationTree(i);
    });
    return output;
}
/**
 * @callback InvocationWalker
 *
 * @param {xdr.SorobanAuthorizedInvocation} node  the currently explored node
 * @param {number} depth  the depth of the tree this node is occurring at (the
 *    root starts at a depth of 1)
 * @param {xdr.SorobanAuthorizedInvocation} [parent]  this `node`s parent node,
 *    if any (i.e. this doesn't exist at the root)
 *
 * @returns {boolean|null|void}   returning exactly `false` is a hint to stop
 *    exploring, other values are ignored
 */ /**
 * Executes a callback function on each node in the tree until stopped.
 *
 * Nodes are walked in a depth-first order. Returning `false` from the callback
 * stops further depth exploration at that node, but it does not stop the walk
 * in a "global" view.
 *
 * @param {xdr.SorobanAuthorizedInvocation} root  the tree to explore
 * @param {InvocationWalker} callback  the callback to execute for each node
 * @returns {void}
 */ function walkInvocationTree(root, callback) {
    walkHelper(root, 1, callback);
}
function walkHelper(node, depth, callback, parent) {
    if (callback(node, depth, parent) === false) {
        return;
    }
    node.subInvocations().forEach(function(i) {
        return walkHelper(i, depth + 1, callback, node);
    });
}
}}),
"[project]/node_modules/@stellar/stellar-base/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _exportNames = {
    xdr: true,
    cereal: true,
    hash: true,
    sign: true,
    verify: true,
    FastSigning: true,
    getLiquidityPoolId: true,
    LiquidityPoolFeeV18: true,
    Keypair: true,
    UnsignedHyper: true,
    Hyper: true,
    TransactionBase: true,
    Transaction: true,
    FeeBumpTransaction: true,
    TransactionBuilder: true,
    TimeoutInfinite: true,
    BASE_FEE: true,
    Asset: true,
    LiquidityPoolAsset: true,
    LiquidityPoolId: true,
    Operation: true,
    AuthRequiredFlag: true,
    AuthRevocableFlag: true,
    AuthImmutableFlag: true,
    AuthClawbackEnabledFlag: true,
    Account: true,
    MuxedAccount: true,
    Claimant: true,
    Networks: true,
    StrKey: true,
    SignerKey: true,
    Soroban: true,
    decodeAddressToMuxedAccount: true,
    encodeMuxedAccountToAddress: true,
    extractBaseAddress: true,
    encodeMuxedAccount: true,
    Contract: true,
    Address: true
};
Object.defineProperty(exports, "Account", {
    enumerable: true,
    get: function get() {
        return _account.Account;
    }
});
Object.defineProperty(exports, "Address", {
    enumerable: true,
    get: function get() {
        return _address.Address;
    }
});
Object.defineProperty(exports, "Asset", {
    enumerable: true,
    get: function get() {
        return _asset.Asset;
    }
});
Object.defineProperty(exports, "AuthClawbackEnabledFlag", {
    enumerable: true,
    get: function get() {
        return _operation.AuthClawbackEnabledFlag;
    }
});
Object.defineProperty(exports, "AuthImmutableFlag", {
    enumerable: true,
    get: function get() {
        return _operation.AuthImmutableFlag;
    }
});
Object.defineProperty(exports, "AuthRequiredFlag", {
    enumerable: true,
    get: function get() {
        return _operation.AuthRequiredFlag;
    }
});
Object.defineProperty(exports, "AuthRevocableFlag", {
    enumerable: true,
    get: function get() {
        return _operation.AuthRevocableFlag;
    }
});
Object.defineProperty(exports, "BASE_FEE", {
    enumerable: true,
    get: function get() {
        return _transaction_builder.BASE_FEE;
    }
});
Object.defineProperty(exports, "Claimant", {
    enumerable: true,
    get: function get() {
        return _claimant.Claimant;
    }
});
Object.defineProperty(exports, "Contract", {
    enumerable: true,
    get: function get() {
        return _contract.Contract;
    }
});
Object.defineProperty(exports, "FastSigning", {
    enumerable: true,
    get: function get() {
        return _signing.FastSigning;
    }
});
Object.defineProperty(exports, "FeeBumpTransaction", {
    enumerable: true,
    get: function get() {
        return _fee_bump_transaction.FeeBumpTransaction;
    }
});
Object.defineProperty(exports, "Hyper", {
    enumerable: true,
    get: function get() {
        return _jsXdr.Hyper;
    }
});
Object.defineProperty(exports, "Keypair", {
    enumerable: true,
    get: function get() {
        return _keypair.Keypair;
    }
});
Object.defineProperty(exports, "LiquidityPoolAsset", {
    enumerable: true,
    get: function get() {
        return _liquidity_pool_asset.LiquidityPoolAsset;
    }
});
Object.defineProperty(exports, "LiquidityPoolFeeV18", {
    enumerable: true,
    get: function get() {
        return _get_liquidity_pool_id.LiquidityPoolFeeV18;
    }
});
Object.defineProperty(exports, "LiquidityPoolId", {
    enumerable: true,
    get: function get() {
        return _liquidity_pool_id.LiquidityPoolId;
    }
});
Object.defineProperty(exports, "MuxedAccount", {
    enumerable: true,
    get: function get() {
        return _muxed_account.MuxedAccount;
    }
});
Object.defineProperty(exports, "Networks", {
    enumerable: true,
    get: function get() {
        return _network.Networks;
    }
});
Object.defineProperty(exports, "Operation", {
    enumerable: true,
    get: function get() {
        return _operation.Operation;
    }
});
Object.defineProperty(exports, "SignerKey", {
    enumerable: true,
    get: function get() {
        return _signerkey.SignerKey;
    }
});
Object.defineProperty(exports, "Soroban", {
    enumerable: true,
    get: function get() {
        return _soroban.Soroban;
    }
});
Object.defineProperty(exports, "StrKey", {
    enumerable: true,
    get: function get() {
        return _strkey.StrKey;
    }
});
Object.defineProperty(exports, "TimeoutInfinite", {
    enumerable: true,
    get: function get() {
        return _transaction_builder.TimeoutInfinite;
    }
});
Object.defineProperty(exports, "Transaction", {
    enumerable: true,
    get: function get() {
        return _transaction.Transaction;
    }
});
Object.defineProperty(exports, "TransactionBase", {
    enumerable: true,
    get: function get() {
        return _transaction_base.TransactionBase;
    }
});
Object.defineProperty(exports, "TransactionBuilder", {
    enumerable: true,
    get: function get() {
        return _transaction_builder.TransactionBuilder;
    }
});
Object.defineProperty(exports, "UnsignedHyper", {
    enumerable: true,
    get: function get() {
        return _jsXdr.UnsignedHyper;
    }
});
Object.defineProperty(exports, "cereal", {
    enumerable: true,
    get: function get() {
        return _jsxdr["default"];
    }
});
Object.defineProperty(exports, "decodeAddressToMuxedAccount", {
    enumerable: true,
    get: function get() {
        return _decode_encode_muxed_account.decodeAddressToMuxedAccount;
    }
});
exports["default"] = void 0;
Object.defineProperty(exports, "encodeMuxedAccount", {
    enumerable: true,
    get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccount;
    }
});
Object.defineProperty(exports, "encodeMuxedAccountToAddress", {
    enumerable: true,
    get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccountToAddress;
    }
});
Object.defineProperty(exports, "extractBaseAddress", {
    enumerable: true,
    get: function get() {
        return _decode_encode_muxed_account.extractBaseAddress;
    }
});
Object.defineProperty(exports, "getLiquidityPoolId", {
    enumerable: true,
    get: function get() {
        return _get_liquidity_pool_id.getLiquidityPoolId;
    }
});
Object.defineProperty(exports, "hash", {
    enumerable: true,
    get: function get() {
        return _hashing.hash;
    }
});
Object.defineProperty(exports, "sign", {
    enumerable: true,
    get: function get() {
        return _signing.sign;
    }
});
Object.defineProperty(exports, "verify", {
    enumerable: true,
    get: function get() {
        return _signing.verify;
    }
});
Object.defineProperty(exports, "xdr", {
    enumerable: true,
    get: function get() {
        return _xdr["default"];
    }
});
var _xdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/xdr.js [app-ssr] (ecmascript)"));
var _jsxdr = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/jsxdr.js [app-ssr] (ecmascript)"));
var _hashing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/hashing.js [app-ssr] (ecmascript)");
var _signing = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/signing.js [app-ssr] (ecmascript)");
var _get_liquidity_pool_id = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js [app-ssr] (ecmascript)");
var _keypair = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/keypair.js [app-ssr] (ecmascript)");
var _jsXdr = __turbopack_context__.r("[project]/node_modules/@stellar/js-xdr/src/index.js [app-ssr] (ecmascript)");
var _transaction_base = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/transaction_base.js [app-ssr] (ecmascript)");
var _transaction = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/transaction.js [app-ssr] (ecmascript)");
var _fee_bump_transaction = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js [app-ssr] (ecmascript)");
var _transaction_builder = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/transaction_builder.js [app-ssr] (ecmascript)");
var _asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/asset.js [app-ssr] (ecmascript)");
var _liquidity_pool_asset = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js [app-ssr] (ecmascript)");
var _liquidity_pool_id = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js [app-ssr] (ecmascript)");
var _operation = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/operation.js [app-ssr] (ecmascript)");
var _memo = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/memo.js [app-ssr] (ecmascript)");
Object.keys(_memo).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _memo[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _memo[key];
        }
    });
});
var _account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/account.js [app-ssr] (ecmascript)");
var _muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/muxed_account.js [app-ssr] (ecmascript)");
var _claimant = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/claimant.js [app-ssr] (ecmascript)");
var _network = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/network.js [app-ssr] (ecmascript)");
var _strkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/strkey.js [app-ssr] (ecmascript)");
var _signerkey = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/signerkey.js [app-ssr] (ecmascript)");
var _soroban = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/soroban.js [app-ssr] (ecmascript)");
var _decode_encode_muxed_account = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js [app-ssr] (ecmascript)");
var _contract = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/contract.js [app-ssr] (ecmascript)");
var _address = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/address.js [app-ssr] (ecmascript)");
var _numbers = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/numbers/index.js [app-ssr] (ecmascript)");
Object.keys(_numbers).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _numbers[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _numbers[key];
        }
    });
});
var _scval = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/scval.js [app-ssr] (ecmascript)");
Object.keys(_scval).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _scval[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _scval[key];
        }
    });
});
var _events = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/events.js [app-ssr] (ecmascript)");
Object.keys(_events).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _events[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _events[key];
        }
    });
});
var _sorobandata_builder = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js [app-ssr] (ecmascript)");
Object.keys(_sorobandata_builder).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _sorobandata_builder[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _sorobandata_builder[key];
        }
    });
});
var _auth = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/auth.js [app-ssr] (ecmascript)");
Object.keys(_auth).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _auth[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _auth[key];
        }
    });
});
var _invocation = __turbopack_context__.r("[project]/node_modules/@stellar/stellar-base/lib/invocation.js [app-ssr] (ecmascript)");
Object.keys(_invocation).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _invocation[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _invocation[key];
        }
    });
});
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
/* eslint-disable import/no-import-module-exports */ //
// Soroban
//
var _default = exports["default"] = module.exports;
}}),

};

//# sourceMappingURL=node_modules_%40stellar_stellar-base_lib_99fdc334._.js.map